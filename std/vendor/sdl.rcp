module SDL;

#if Windows {
	wchar_t :: u16;
}
#else {
	wchar_t :: u32;
}

intptr_t :: int;

MAX_SINT8 :: ( 0x7F as Sint8 );
MIN_SINT8 :: ( ( ~ 0x7F as Sint8 ) );
MAX_UINT8 :: ( 0xFF as Uint8 );
MIN_UINT8 :: ( 0x00 as Uint8 );
MAX_SINT16 :: ( 0x7FFF as Sint16 );
MIN_SINT16 :: ( ( ~ 0x7FFF as Sint16 ) );
MAX_UINT16 :: ( 0xFFFF as Uint16 );
MIN_UINT16 :: ( 0x0000 as Uint16 );
MAX_SINT32 :: ( 0x7FFFFFFF as Sint32 );
MIN_SINT32 :: ( ( ~ 0x7FFFFFFF as Sint32 ) );
MAX_UINT32 :: ( 0xFFFFFFFF as Uint32 );
MIN_UINT32 :: ( 0x00000000 as Uint32 );
MAX_SINT64  :: 0x7FFFFFFFFFFFFFFF as i64;   /* 9223372036854775807 */
MIN_SINT64  :: ~0x7FFFFFFFFFFFFFFF as i64;  /* -9223372036854775808 */
MAX_UINT64  :: 0xFFFFFFFFFFFFFFFF as u64;   /* 18446744073709551615 */
MIN_UINT64  :: 0x0000000000000000 as u64;   /* 0 */
MAX_TIME :: MAX_SINT64;
MIN_TIME :: MIN_SINT64;
PRIs64 :: "I64d";
PRIu64 :: "I64u";
PRIx64 :: "I64x";
PRIX64 :: "I64X";
INVALID_UNICODE_CODEPOINT :: 0xFFFD;
PI_D :: 3.141592653589793238462643383279502884 as f64;
PI_F :: 3.141592653589793238462643383279502884;
ICONV_ERROR  :: (-1) as uint;
ICONV_E2BIG  :: (-2) as uint;
ICONV_EILSEQ :: (-3) as uint;
ICONV_EINVAL :: (-4) as uint;
ASSERT_LEVEL :: 1;
LIL_ENDIAN :: 1234;
BIG_ENDIAN :: 4321;
BYTEORDER :: LIL_ENDIAN;
FLOATWORDORDER :: BYTEORDER;
//BeginThreadFunction :: _beginthreadex;
//EndThreadFunction :: _endthreadex;
PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER :: "SDL.thread.create.entry_function";
PROP_THREAD_CREATE_NAME_STRING :: "SDL.thread.create.name";
PROP_THREAD_CREATE_USERDATA_POINTER :: "SDL.thread.create.userdata";
PROP_THREAD_CREATE_STACKSIZE_NUMBER :: "SDL.thread.create.stacksize";
PROP_IOSTREAM_WINDOWS_HANDLE_POINTER :: "SDL.iostream.windows.handle";
PROP_IOSTREAM_STDIO_FILE_POINTER :: "SDL.iostream.stdio.file";
PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER :: "SDL.iostream.file_descriptor";
PROP_IOSTREAM_ANDROID_AASSET_POINTER :: "SDL.iostream.android.aasset";
PROP_IOSTREAM_MEMORY_POINTER :: "SDL.iostream.memory.base";
PROP_IOSTREAM_MEMORY_SIZE_NUMBER :: "SDL.iostream.memory.size";
PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER :: "SDL.iostream.dynamic.memory";
PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER :: "SDL.iostream.dynamic.chunksize";
AUDIO_MASK_BITSIZE :: ( 0xFF );
AUDIO_MASK_FLOAT :: ( 1 << 8 );
AUDIO_MASK_BIG_ENDIAN :: ( 1 << 12 );
AUDIO_MASK_SIGNED :: ( 1 << 15 );
AUDIO_DEVICE_DEFAULT_PLAYBACK :: ( 0xFFFFFFFF as AudioDeviceID );
AUDIO_DEVICE_DEFAULT_RECORDING :: ( 0xFFFFFFFE as AudioDeviceID );
BLENDMODE_NONE :: 0x00000000;
BLENDMODE_BLEND :: 0x00000001;
BLENDMODE_BLEND_PREMULTIPLIED :: 0x00000010;
BLENDMODE_ADD :: 0x00000002;
BLENDMODE_ADD_PREMULTIPLIED :: 0x00000020;
BLENDMODE_MOD :: 0x00000004;
BLENDMODE_MUL :: 0x00000008;
BLENDMODE_INVALID :: 0x7FFFFFFF;
ALPHA_OPAQUE :: 255;
ALPHA_OPAQUE_FLOAT :: 1.0;
ALPHA_TRANSPARENT :: 0;
ALPHA_TRANSPARENT_FLOAT :: 0.0;
SURFACE_PREALLOCATED :: 0x00000001;
SURFACE_LOCK_NEEDED :: 0x00000002;
SURFACE_LOCKED :: 0x00000004;
SURFACE_SIMD_ALIGNED :: 0x00000008;
PROP_SURFACE_SDR_WHITE_POINT_FLOAT :: "SDL.surface.SDR_white_point";
PROP_SURFACE_HDR_HEADROOM_FLOAT :: "SDL.surface.HDR_headroom";
PROP_SURFACE_TONEMAP_OPERATOR_STRING :: "SDL.surface.tonemap";
PROP_SURFACE_HOTSPOT_X_NUMBER :: "SDL.surface.hotspot.x";
PROP_SURFACE_HOTSPOT_Y_NUMBER :: "SDL.surface.hotspot.y";
CACHELINE_SIZE :: 128;
PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER :: "SDL.video.wayland.wl_display";
WINDOWPOS_UNDEFINED_MASK :: 0x1FFF0000;
WINDOWPOS_CENTERED_MASK :: 0x2FFF0000;
GL_CONTEXT_PROFILE_CORE :: 0x0001;
GL_CONTEXT_PROFILE_COMPATIBILITY :: 0x0002;
GL_CONTEXT_PROFILE_ES :: 0x0004;
GL_CONTEXT_DEBUG_FLAG :: 0x0001;
GL_CONTEXT_FORWARD_COMPATIBLE_FLAG :: 0x0002;
GL_CONTEXT_ROBUST_ACCESS_FLAG :: 0x0004;
GL_CONTEXT_RESET_ISOLATION_FLAG :: 0x0008;
GL_CONTEXT_RELEASE_BEHAVIOR_NONE :: 0x0000;
GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH :: 0x0001;
GL_CONTEXT_RESET_NO_NOTIFICATION :: 0x0000;
GL_CONTEXT_RESET_LOSE_CONTEXT :: 0x0001;
PROP_DISPLAY_HDR_ENABLED_BOOLEAN :: "SDL.display.HDR_enabled";
PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER :: "SDL.display.KMSDRM.panel_orientation";
PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN :: "SDL.window.create.always_on_top";
PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN :: "SDL.window.create.borderless";
PROP_WINDOW_CREATE_CONSTRAIN_POPUP_BOOLEAN :: "SDL.window.create.constrain_popup";
PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN :: "SDL.window.create.focusable";
PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN :: "SDL.window.create.external_graphics_context";
PROP_WINDOW_CREATE_FLAGS_NUMBER :: "SDL.window.create.flags";
PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN :: "SDL.window.create.fullscreen";
PROP_WINDOW_CREATE_HEIGHT_NUMBER :: "SDL.window.create.height";
PROP_WINDOW_CREATE_HIDDEN_BOOLEAN :: "SDL.window.create.hidden";
PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN :: "SDL.window.create.high_pixel_density";
PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN :: "SDL.window.create.maximized";
PROP_WINDOW_CREATE_MENU_BOOLEAN :: "SDL.window.create.menu";
PROP_WINDOW_CREATE_METAL_BOOLEAN :: "SDL.window.create.metal";
PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN :: "SDL.window.create.minimized";
PROP_WINDOW_CREATE_MODAL_BOOLEAN :: "SDL.window.create.modal";
PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN :: "SDL.window.create.mouse_grabbed";
PROP_WINDOW_CREATE_OPENGL_BOOLEAN :: "SDL.window.create.opengl";
PROP_WINDOW_CREATE_PARENT_POINTER :: "SDL.window.create.parent";
PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN :: "SDL.window.create.resizable";
PROP_WINDOW_CREATE_TITLE_STRING :: "SDL.window.create.title";
PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN :: "SDL.window.create.transparent";
PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN :: "SDL.window.create.tooltip";
PROP_WINDOW_CREATE_UTILITY_BOOLEAN :: "SDL.window.create.utility";
PROP_WINDOW_CREATE_VULKAN_BOOLEAN :: "SDL.window.create.vulkan";
PROP_WINDOW_CREATE_WIDTH_NUMBER :: "SDL.window.create.width";
PROP_WINDOW_CREATE_X_NUMBER :: "SDL.window.create.x";
PROP_WINDOW_CREATE_Y_NUMBER :: "SDL.window.create.y";
PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER :: "SDL.window.create.cocoa.window";
PROP_WINDOW_CREATE_COCOA_VIEW_POINTER :: "SDL.window.create.cocoa.view";
PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN :: "SDL.window.create.wayland.surface_role_custom";
PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN :: "SDL.window.create.wayland.create_egl_window";
PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER :: "SDL.window.create.wayland.wl_surface";
PROP_WINDOW_CREATE_WIN32_HWND_POINTER :: "SDL.window.create.win32.hwnd";
PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER :: "SDL.window.create.win32.pixel_format_hwnd";
PROP_WINDOW_CREATE_X11_WINDOW_NUMBER :: "SDL.window.create.x11.window";
PROP_WINDOW_SHAPE_POINTER :: "SDL.window.shape";
PROP_WINDOW_HDR_ENABLED_BOOLEAN :: "SDL.window.HDR_enabled";
PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT :: "SDL.window.SDR_white_level";
PROP_WINDOW_HDR_HEADROOM_FLOAT :: "SDL.window.HDR_headroom";
PROP_WINDOW_ANDROID_WINDOW_POINTER :: "SDL.window.android.window";
PROP_WINDOW_ANDROID_SURFACE_POINTER :: "SDL.window.android.surface";
PROP_WINDOW_UIKIT_WINDOW_POINTER :: "SDL.window.uikit.window";
PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER :: "SDL.window.uikit.metal_view_tag";
PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER :: "SDL.window.uikit.opengl.framebuffer";
PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER :: "SDL.window.uikit.opengl.renderbuffer";
PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER :: "SDL.window.uikit.opengl.resolve_framebuffer";
PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER :: "SDL.window.kmsdrm.dev_index";
PROP_WINDOW_KMSDRM_DRM_FD_NUMBER :: "SDL.window.kmsdrm.drm_fd";
PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER :: "SDL.window.kmsdrm.gbm_dev";
PROP_WINDOW_COCOA_WINDOW_POINTER :: "SDL.window.cocoa.window";
PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER :: "SDL.window.cocoa.metal_view_tag";
PROP_WINDOW_OPENVR_OVERLAY_ID :: "SDL.window.openvr.overlay_id";
PROP_WINDOW_VIVANTE_DISPLAY_POINTER :: "SDL.window.vivante.display";
PROP_WINDOW_VIVANTE_WINDOW_POINTER :: "SDL.window.vivante.window";
PROP_WINDOW_VIVANTE_SURFACE_POINTER :: "SDL.window.vivante.surface";
PROP_WINDOW_WIN32_HWND_POINTER :: "SDL.window.win32.hwnd";
PROP_WINDOW_WIN32_HDC_POINTER :: "SDL.window.win32.hdc";
PROP_WINDOW_WIN32_INSTANCE_POINTER :: "SDL.window.win32.instance";
PROP_WINDOW_WAYLAND_DISPLAY_POINTER :: "SDL.window.wayland.display";
PROP_WINDOW_WAYLAND_SURFACE_POINTER :: "SDL.window.wayland.surface";
PROP_WINDOW_WAYLAND_VIEWPORT_POINTER :: "SDL.window.wayland.viewport";
PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER :: "SDL.window.wayland.egl_window";
PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER :: "SDL.window.wayland.xdg_surface";
PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER :: "SDL.window.wayland.xdg_toplevel";
PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING :: "SDL.window.wayland.xdg_toplevel_export_handle";
PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER :: "SDL.window.wayland.xdg_popup";
PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER :: "SDL.window.wayland.xdg_positioner";
PROP_WINDOW_X11_DISPLAY_POINTER :: "SDL.window.x11.display";
PROP_WINDOW_X11_SCREEN_NUMBER :: "SDL.window.x11.screen";
PROP_WINDOW_X11_WINDOW_NUMBER :: "SDL.window.x11.window";
WINDOW_SURFACE_VSYNC_DISABLED :: 0;
WINDOW_SURFACE_VSYNC_ADAPTIVE :: ( - 1 );
PROP_FILE_DIALOG_FILTERS_POINTER :: "SDL.filedialog.filters";
PROP_FILE_DIALOG_NFILTERS_NUMBER :: "SDL.filedialog.nfilters";
PROP_FILE_DIALOG_WINDOW_POINTER :: "SDL.filedialog.window";
PROP_FILE_DIALOG_LOCATION_STRING :: "SDL.filedialog.location";
PROP_FILE_DIALOG_MANY_BOOLEAN :: "SDL.filedialog.many";
PROP_FILE_DIALOG_TITLE_STRING :: "SDL.filedialog.title";
PROP_FILE_DIALOG_ACCEPT_STRING :: "SDL.filedialog.accept";
PROP_FILE_DIALOG_CANCEL_STRING :: "SDL.filedialog.cancel";
STANDARD_GRAVITY :: 9.80665;
JOYSTICK_AXIS_MAX :: 32767;
JOYSTICK_AXIS_MIN :: - 32768;
PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN :: "SDL.joystick.cap.mono_led";
PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN :: "SDL.joystick.cap.rgb_led";
PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN :: "SDL.joystick.cap.player_led";
PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN :: "SDL.joystick.cap.rumble";
PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN :: "SDL.joystick.cap.trigger_rumble";
HAT_CENTERED :: 0x00;
HAT_UP :: 0x01;
HAT_RIGHT :: 0x02;
HAT_DOWN :: 0x04;
HAT_LEFT :: 0x08;
HAT_RIGHTUP :: ( HAT_RIGHT | HAT_UP );
HAT_RIGHTDOWN :: ( HAT_RIGHT | HAT_DOWN );
HAT_LEFTUP :: ( HAT_LEFT | HAT_UP );
HAT_LEFTDOWN :: ( HAT_LEFT | HAT_DOWN );
PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN :: PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN;
PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN :: PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN;
PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN :: PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN;
PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN :: PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN;
PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN :: PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN;
K_EXTENDED_MASK :: ( 1 << 29 );
K_SCANCODE_MASK :: ( 1 << 30 );
K_UNKNOWN :: 0x00000000;
K_RETURN :: 0x0000000d;
K_ESCAPE :: 0x0000001b;
K_BACKSPACE :: 0x00000008;
K_TAB :: 0x00000009;
K_SPACE :: 0x00000020;
K_EXCLAIM :: 0x00000021;
K_DBLAPOSTROPHE :: 0x00000022;
K_HASH :: 0x00000023;
K_DOLLAR :: 0x00000024;
K_PERCENT :: 0x00000025;
K_AMPERSAND :: 0x00000026;
K_APOSTROPHE :: 0x00000027;
K_LEFTPAREN :: 0x00000028;
K_RIGHTPAREN :: 0x00000029;
K_ASTERISK :: 0x0000002a;
K_PLUS :: 0x0000002b;
K_COMMA :: 0x0000002c;
K_MINUS :: 0x0000002d;
K_PERIOD :: 0x0000002e;
K_SLASH :: 0x0000002f;
K_0 :: 0x00000030;
K_1 :: 0x00000031;
K_2 :: 0x00000032;
K_3 :: 0x00000033;
K_4 :: 0x00000034;
K_5 :: 0x00000035;
K_6 :: 0x00000036;
K_7 :: 0x00000037;
K_8 :: 0x00000038;
K_9 :: 0x00000039;
K_COLON :: 0x0000003a;
K_SEMICOLON :: 0x0000003b;
K_LESS :: 0x0000003c;
K_EQUALS :: 0x0000003d;
K_GREATER :: 0x0000003e;
K_QUESTION :: 0x0000003f;
K_AT :: 0x00000040;
K_LEFTBRACKET :: 0x0000005b;
K_BACKSLASH :: 0x0000005c;
K_RIGHTBRACKET :: 0x0000005d;
K_CARET :: 0x0000005e;
K_UNDERSCORE :: 0x0000005f;
K_GRAVE :: 0x00000060;
K_A :: 0x00000061;
K_B :: 0x00000062;
K_C :: 0x00000063;
K_D :: 0x00000064;
K_E :: 0x00000065;
K_F :: 0x00000066;
K_G :: 0x00000067;
K_H :: 0x00000068;
K_I :: 0x00000069;
K_J :: 0x0000006a;
K_K :: 0x0000006b;
K_L :: 0x0000006c;
K_M :: 0x0000006d;
K_N :: 0x0000006e;
K_O :: 0x0000006f;
K_P :: 0x00000070;
K_Q :: 0x00000071;
K_R :: 0x00000072;
K_S :: 0x00000073;
K_T :: 0x00000074;
K_U :: 0x00000075;
K_V :: 0x00000076;
K_W :: 0x00000077;
K_X :: 0x00000078;
K_Y :: 0x00000079;
K_Z :: 0x0000007a;
K_LEFTBRACE :: 0x0000007b;
K_PIPE :: 0x0000007c;
K_RIGHTBRACE :: 0x0000007d;
K_TILDE :: 0x0000007e;
K_DELETE :: 0x0000007f;
K_PLUSMINUS :: 0x000000b1;
K_CAPSLOCK :: 0x40000039;
K_F1 :: 0x4000003a;
K_F2 :: 0x4000003b;
K_F3 :: 0x4000003c;
K_F4 :: 0x4000003d;
K_F5 :: 0x4000003e;
K_F6 :: 0x4000003f;
K_F7 :: 0x40000040;
K_F8 :: 0x40000041;
K_F9 :: 0x40000042;
K_F10 :: 0x40000043;
K_F11 :: 0x40000044;
K_F12 :: 0x40000045;
K_PRINTSCREEN :: 0x40000046;
K_SCROLLLOCK :: 0x40000047;
K_PAUSE :: 0x40000048;
K_INSERT :: 0x40000049;
K_HOME :: 0x4000004a;
K_PAGEUP :: 0x4000004b;
K_END :: 0x4000004d;
K_PAGEDOWN :: 0x4000004e;
K_RIGHT :: 0x4000004f;
K_LEFT :: 0x40000050;
K_DOWN :: 0x40000051;
K_UP :: 0x40000052;
K_NUMLOCKCLEAR :: 0x40000053;
K_KP_DIVIDE :: 0x40000054;
K_KP_MULTIPLY :: 0x40000055;
K_KP_MINUS :: 0x40000056;
K_KP_PLUS :: 0x40000057;
K_KP_ENTER :: 0x40000058;
K_KP_1 :: 0x40000059;
K_KP_2 :: 0x4000005a;
K_KP_3 :: 0x4000005b;
K_KP_4 :: 0x4000005c;
K_KP_5 :: 0x4000005d;
K_KP_6 :: 0x4000005e;
K_KP_7 :: 0x4000005f;
K_KP_8 :: 0x40000060;
K_KP_9 :: 0x40000061;
K_KP_0 :: 0x40000062;
K_KP_PERIOD :: 0x40000063;
K_APPLICATION :: 0x40000065;
K_POWER :: 0x40000066;
K_KP_EQUALS :: 0x40000067;
K_F13 :: 0x40000068;
K_F14 :: 0x40000069;
K_F15 :: 0x4000006a;
K_F16 :: 0x4000006b;
K_F17 :: 0x4000006c;
K_F18 :: 0x4000006d;
K_F19 :: 0x4000006e;
K_F20 :: 0x4000006f;
K_F21 :: 0x40000070;
K_F22 :: 0x40000071;
K_F23 :: 0x40000072;
K_F24 :: 0x40000073;
K_EXECUTE :: 0x40000074;
K_HELP :: 0x40000075;
K_MENU :: 0x40000076;
K_SELECT :: 0x40000077;
K_STOP :: 0x40000078;
K_AGAIN :: 0x40000079;
K_UNDO :: 0x4000007a;
K_CUT :: 0x4000007b;
K_COPY :: 0x4000007c;
K_PASTE :: 0x4000007d;
K_FIND :: 0x4000007e;
K_MUTE :: 0x4000007f;
K_VOLUMEUP :: 0x40000080;
K_VOLUMEDOWN :: 0x40000081;
K_KP_COMMA :: 0x40000085;
K_KP_EQUALSAS400 :: 0x40000086;
K_ALTERASE :: 0x40000099;
K_SYSREQ :: 0x4000009a;
K_CANCEL :: 0x4000009b;
K_CLEAR :: 0x4000009c;
K_PRIOR :: 0x4000009d;
K_RETURN2 :: 0x4000009e;
K_SEPARATOR :: 0x4000009f;
K_OUT :: 0x400000a0;
K_OPER :: 0x400000a1;
K_CLEARAGAIN :: 0x400000a2;
K_CRSEL :: 0x400000a3;
K_EXSEL :: 0x400000a4;
K_KP_00 :: 0x400000b0;
K_KP_000 :: 0x400000b1;
K_THOUSANDSSEPARATOR :: 0x400000b2;
K_DECIMALSEPARATOR :: 0x400000b3;
K_CURRENCYUNIT :: 0x400000b4;
K_CURRENCYSUBUNIT :: 0x400000b5;
K_KP_LEFTPAREN :: 0x400000b6;
K_KP_RIGHTPAREN :: 0x400000b7;
K_KP_LEFTBRACE :: 0x400000b8;
K_KP_RIGHTBRACE :: 0x400000b9;
K_KP_TAB :: 0x400000ba;
K_KP_BACKSPACE :: 0x400000bb;
K_KP_A :: 0x400000bc;
K_KP_B :: 0x400000bd;
K_KP_C :: 0x400000be;
K_KP_D :: 0x400000bf;
K_KP_E :: 0x400000c0;
K_KP_F :: 0x400000c1;
K_KP_XOR :: 0x400000c2;
K_KP_POWER :: 0x400000c3;
K_KP_PERCENT :: 0x400000c4;
K_KP_LESS :: 0x400000c5;
K_KP_GREATER :: 0x400000c6;
K_KP_AMPERSAND :: 0x400000c7;
K_KP_DBLAMPERSAND :: 0x400000c8;
K_KP_VERTICALBAR :: 0x400000c9;
K_KP_DBLVERTICALBAR :: 0x400000ca;
K_KP_COLON :: 0x400000cb;
K_KP_HASH :: 0x400000cc;
K_KP_SPACE :: 0x400000cd;
K_KP_AT :: 0x400000ce;
K_KP_EXCLAM :: 0x400000cf;
K_KP_MEMSTORE :: 0x400000d0;
K_KP_MEMRECALL :: 0x400000d1;
K_KP_MEMCLEAR :: 0x400000d2;
K_KP_MEMADD :: 0x400000d3;
K_KP_MEMSUBTRACT :: 0x400000d4;
K_KP_MEMMULTIPLY :: 0x400000d5;
K_KP_MEMDIVIDE :: 0x400000d6;
K_KP_PLUSMINUS :: 0x400000d7;
K_KP_CLEAR :: 0x400000d8;
K_KP_CLEARENTRY :: 0x400000d9;
K_KP_BINARY :: 0x400000da;
K_KP_OCTAL :: 0x400000db;
K_KP_DECIMAL :: 0x400000dc;
K_KP_HEXADECIMAL :: 0x400000dd;
K_LCTRL :: 0x400000e0;
K_LSHIFT :: 0x400000e1;
K_LALT :: 0x400000e2;
K_LGUI :: 0x400000e3;
K_RCTRL :: 0x400000e4;
K_RSHIFT :: 0x400000e5;
K_RALT :: 0x400000e6;
K_RGUI :: 0x400000e7;
K_MODE :: 0x40000101;
K_SLEEP :: 0x40000102;
K_WAKE :: 0x40000103;
K_CHANNEL_INCREMENT :: 0x40000104;
K_CHANNEL_DECREMENT :: 0x40000105;
K_MEDIA_PLAY :: 0x40000106;
K_MEDIA_PAUSE :: 0x40000107;
K_MEDIA_RECORD :: 0x40000108;
K_MEDIA_FAST_FORWARD :: 0x40000109;
K_MEDIA_REWIND :: 0x4000010a;
K_MEDIA_NEXT_TRACK :: 0x4000010b;
K_MEDIA_PREVIOUS_TRACK :: 0x4000010c;
K_MEDIA_STOP :: 0x4000010d;
K_MEDIA_EJECT :: 0x4000010e;
K_MEDIA_PLAY_PAUSE :: 0x4000010f;
K_MEDIA_SELECT :: 0x40000110;
K_AC_NEW :: 0x40000111;
K_AC_OPEN :: 0x40000112;
K_AC_CLOSE :: 0x40000113;
K_AC_EXIT :: 0x40000114;
K_AC_SAVE :: 0x40000115;
K_AC_PRINT :: 0x40000116;
K_AC_PROPERTIES :: 0x40000117;
K_AC_SEARCH :: 0x40000118;
K_AC_HOME :: 0x40000119;
K_AC_BACK :: 0x4000011a;
K_AC_FORWARD :: 0x4000011b;
K_AC_STOP :: 0x4000011c;
K_AC_REFRESH :: 0x4000011d;
K_AC_BOOKMARKS :: 0x4000011e;
K_SOFTLEFT :: 0x4000011f;
K_SOFTRIGHT :: 0x40000120;
K_CALL :: 0x40000121;
K_ENDCALL :: 0x40000122;
K_LEFT_TAB :: 0x20000001;
K_LEVEL5_SHIFT :: 0x20000002;
K_MULTI_KEY_COMPOSE :: 0x20000003;
K_LMETA :: 0x20000004;
K_RMETA :: 0x20000005;
K_LHYPER :: 0x20000006;
K_RHYPER :: 0x20000007;
KMOD_NONE :: 0x0000;
KMOD_LSHIFT :: 0x0001;
KMOD_RSHIFT :: 0x0002;
KMOD_LEVEL5 :: 0x0004;
KMOD_LCTRL :: 0x0040;
KMOD_RCTRL :: 0x0080;
KMOD_LALT :: 0x0100;
KMOD_RALT :: 0x0200;
KMOD_LGUI :: 0x0400;
KMOD_RGUI :: 0x0800;
KMOD_NUM :: 0x1000;
KMOD_CAPS :: 0x2000;
KMOD_MODE :: 0x4000;
KMOD_SCROLL :: 0x8000;
KMOD_CTRL :: ( KMOD_LCTRL | KMOD_RCTRL );
KMOD_SHIFT :: ( KMOD_LSHIFT | KMOD_RSHIFT );
KMOD_ALT :: ( KMOD_LALT | KMOD_RALT );
KMOD_GUI :: ( KMOD_LGUI | KMOD_RGUI );
PROP_TEXTINPUT_TYPE_NUMBER :: "SDL.textinput.type";
PROP_TEXTINPUT_CAPITALIZATION_NUMBER :: "SDL.textinput.capitalization";
PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN :: "SDL.textinput.autocorrect";
PROP_TEXTINPUT_MULTILINE_BOOLEAN :: "SDL.textinput.multiline";
PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER :: "SDL.textinput.android.inputtype";

BUTTON_LEFT :: 1;
BUTTON_MIDDLE :: 2;
BUTTON_RIGHT :: 3;
BUTTON_X1 :: 4;
BUTTON_X2 :: 5;

BUTTON_MASK :: fn(x: int) -> u8 { return (1 << ((x-1) as Uint8)); }
BUTTON_LMASK  :: #run BUTTON_MASK(BUTTON_LEFT);
BUTTON_MMASK  :: #run BUTTON_MASK(BUTTON_MIDDLE);
BUTTON_RMASK  :: #run BUTTON_MASK(BUTTON_RIGHT);
BUTTON_X1MASK :: #run BUTTON_MASK(BUTTON_X1);
BUTTON_X2MASK :: #run BUTTON_MASK(BUTTON_X2);

TOUCH_MOUSEID :: ( (-1) as MouseID );
MOUSE_TOUCHID :: ( (-1) as TouchID );
PEN_MOUSEID :: ( (-2) as MouseID );
PEN_TOUCHID :: ( (-2) as TouchID );
PEN_INPUT_DOWN :: ( 1 << 0 );
PEN_INPUT_BUTTON_1 :: ( 1 << 1 );
PEN_INPUT_BUTTON_2 :: ( 1 << 2 );
PEN_INPUT_BUTTON_3 :: ( 1 << 3 );
PEN_INPUT_BUTTON_4 :: ( 1 << 4 );
PEN_INPUT_BUTTON_5 :: ( 1 << 5 );
PEN_INPUT_ERASER_TIP :: ( 1 << 30 );
GLOB_CASEINSENSITIVE :: ( 1 << 0 );
GPU_TEXTUREUSAGE_SAMPLER :: ( 1 << 0 );
GPU_TEXTUREUSAGE_COLOR_TARGET :: ( 1 << 1 );
GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET :: ( 1 << 2 );
GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ :: ( 1 << 3 );
GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ :: ( 1 << 4 );
GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE :: ( 1 << 5 );
GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE :: ( 1 << 6 );
GPU_BUFFERUSAGE_VERTEX :: ( 1 << 0 );
GPU_BUFFERUSAGE_INDEX :: ( 1 << 1 );
GPU_BUFFERUSAGE_INDIRECT :: ( 1 << 2 );
GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ :: ( 1 << 3 );
GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ :: ( 1 << 4 );
GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE :: ( 1 << 5 );
GPU_SHADERFORMAT_INVALID 	:: 0 as u32;
GPU_SHADERFORMAT_PRIVATE 	:: ( 1 << 0 ) as u32;
GPU_SHADERFORMAT_SPIRV   	:: ( 1 << 1 ) as u32;
GPU_SHADERFORMAT_DXBC		:: ( 1 << 2 ) as u32;
GPU_SHADERFORMAT_DXIL		:: ( 1 << 3 ) as u32;
GPU_SHADERFORMAT_MSL		:: ( 1 << 4 ) as u32;
GPU_SHADERFORMAT_METALLIB :: ( 1 << 5 );
GPU_COLORCOMPONENT_R :: ( 1 << 0 );
GPU_COLORCOMPONENT_G :: ( 1 << 1 );
GPU_COLORCOMPONENT_B :: ( 1 << 2 );
GPU_COLORCOMPONENT_A :: ( 1 << 3 );
PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN :: "SDL.gpu.device.create.debugmode";
PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN :: "SDL.gpu.device.create.preferlowpower";
PROP_GPU_DEVICE_CREATE_NAME_STRING :: "SDL.gpu.device.create.name";
PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN :: "SDL.gpu.device.create.shaders.private";
PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN :: "SDL.gpu.device.create.shaders.spirv";
PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN :: "SDL.gpu.device.create.shaders.dxbc";
PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN :: "SDL.gpu.device.create.shaders.dxil";
PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN :: "SDL.gpu.device.create.shaders.msl";
PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN :: "SDL.gpu.device.create.shaders.metallib";
PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING :: "SDL.gpu.device.create.d3d12.semantic";
PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING :: "SDL.gpu.computepipeline.create.name";
PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING :: "SDL.gpu.graphicspipeline.create.name";
PROP_GPU_SAMPLER_CREATE_NAME_STRING :: "SDL.gpu.sampler.create.name";
PROP_GPU_SHADER_CREATE_NAME_STRING :: "SDL.gpu.shader.create.name";
PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT :: "SDL.gpu.texture.create.d3d12.clear.r";
PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT :: "SDL.gpu.texture.create.d3d12.clear.g";
PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT :: "SDL.gpu.texture.create.d3d12.clear.b";
PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT :: "SDL.gpu.texture.create.d3d12.clear.a";
PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT :: "SDL.gpu.texture.create.d3d12.clear.depth";
PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_NUMBER :: "SDL.gpu.texture.create.d3d12.clear.stencil";
PROP_GPU_TEXTURE_CREATE_NAME_STRING :: "SDL.gpu.texture.create.name";
PROP_GPU_BUFFER_CREATE_NAME_STRING :: "SDL.gpu.buffer.create.name";
PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING :: "SDL.gpu.transferbuffer.create.name";
HAPTIC_CONSTANT :: ( 1 << 0 );
HAPTIC_SINE :: ( 1 << 1 );
HAPTIC_SQUARE :: ( 1 << 2 );
HAPTIC_TRIANGLE :: ( 1 << 3 );
HAPTIC_SAWTOOTHUP :: ( 1 << 4 );
HAPTIC_SAWTOOTHDOWN :: ( 1 << 5 );
HAPTIC_RAMP :: ( 1 << 6 );
HAPTIC_SPRING :: ( 1 << 7 );
HAPTIC_DAMPER :: ( 1 << 8 );
HAPTIC_INERTIA :: ( 1 << 9 );
HAPTIC_FRICTION :: ( 1 << 10 );
HAPTIC_LEFTRIGHT :: ( 1 << 11 );
HAPTIC_RESERVED1 :: ( 1 << 12 );
HAPTIC_RESERVED2 :: ( 1 << 13 );
HAPTIC_RESERVED3 :: ( 1 << 14 );
HAPTIC_CUSTOM :: ( 1 << 15 );
HAPTIC_GAIN :: ( 1 << 16 );
HAPTIC_AUTOCENTER :: ( 1 << 17 );
HAPTIC_STATUS :: ( 1 << 18 );
HAPTIC_PAUSE :: ( 1 << 19 );
HAPTIC_POLAR :: 0;
HAPTIC_CARTESIAN :: 1;
HAPTIC_SPHERICAL :: 2;
HAPTIC_STEERING_AXIS :: 3;
HAPTIC_INFINITY :: 4294967295;
HINT_ALLOW_ALT_TAB_WHILE_GRABBED :: "SDL_ALLOW_ALT_TAB_WHILE_GRABBED";
HINT_ANDROID_ALLOW_RECREATE_ACTIVITY :: "SDL_ANDROID_ALLOW_RECREATE_ACTIVITY";
HINT_ANDROID_BLOCK_ON_PAUSE :: "SDL_ANDROID_BLOCK_ON_PAUSE";
HINT_ANDROID_LOW_LATENCY_AUDIO :: "SDL_ANDROID_LOW_LATENCY_AUDIO";
HINT_ANDROID_TRAP_BACK_BUTTON :: "SDL_ANDROID_TRAP_BACK_BUTTON";
HINT_APP_ID :: "SDL_APP_ID";
HINT_APP_NAME :: "SDL_APP_NAME";
HINT_APPLE_TV_CONTROLLER_UI_EVENTS :: "SDL_APPLE_TV_CONTROLLER_UI_EVENTS";
HINT_APPLE_TV_REMOTE_ALLOW_ROTATION :: "SDL_APPLE_TV_REMOTE_ALLOW_ROTATION";
HINT_AUDIO_ALSA_DEFAULT_DEVICE :: "SDL_AUDIO_ALSA_DEFAULT_DEVICE";
HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE :: "SDL_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE";
HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE :: "SDL_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE";
HINT_AUDIO_CATEGORY :: "SDL_AUDIO_CATEGORY";
HINT_AUDIO_CHANNELS :: "SDL_AUDIO_CHANNELS";
HINT_AUDIO_DEVICE_APP_ICON_NAME :: "SDL_AUDIO_DEVICE_APP_ICON_NAME";
HINT_AUDIO_DEVICE_SAMPLE_FRAMES :: "SDL_AUDIO_DEVICE_SAMPLE_FRAMES";
HINT_AUDIO_DEVICE_STREAM_NAME :: "SDL_AUDIO_DEVICE_STREAM_NAME";
HINT_AUDIO_DEVICE_STREAM_ROLE :: "SDL_AUDIO_DEVICE_STREAM_ROLE";
HINT_AUDIO_DISK_INPUT_FILE :: "SDL_AUDIO_DISK_INPUT_FILE";
HINT_AUDIO_DISK_OUTPUT_FILE :: "SDL_AUDIO_DISK_OUTPUT_FILE";
HINT_AUDIO_DISK_TIMESCALE :: "SDL_AUDIO_DISK_TIMESCALE";
HINT_AUDIO_DRIVER :: "SDL_AUDIO_DRIVER";
HINT_AUDIO_DUMMY_TIMESCALE :: "SDL_AUDIO_DUMMY_TIMESCALE";
HINT_AUDIO_FORMAT :: "SDL_AUDIO_FORMAT";
HINT_AUDIO_FREQUENCY :: "SDL_AUDIO_FREQUENCY";
HINT_AUDIO_INCLUDE_MONITORS :: "SDL_AUDIO_INCLUDE_MONITORS";
HINT_AUTO_UPDATE_JOYSTICKS :: "SDL_AUTO_UPDATE_JOYSTICKS";
HINT_AUTO_UPDATE_SENSORS :: "SDL_AUTO_UPDATE_SENSORS";
HINT_BMP_SAVE_LEGACY_FORMAT :: "SDL_BMP_SAVE_LEGACY_FORMAT";
HINT_CAMERA_DRIVER :: "SDL_CAMERA_DRIVER";
HINT_CPU_FEATURE_MASK :: "SDL_CPU_FEATURE_MASK";
HINT_JOYSTICK_DIRECTINPUT :: "SDL_JOYSTICK_DIRECTINPUT";
HINT_FILE_DIALOG_DRIVER :: "SDL_FILE_DIALOG_DRIVER";
HINT_DISPLAY_USABLE_BOUNDS :: "SDL_DISPLAY_USABLE_BOUNDS";
HINT_EMSCRIPTEN_ASYNCIFY :: "SDL_EMSCRIPTEN_ASYNCIFY";
HINT_EMSCRIPTEN_CANVAS_SELECTOR :: "SDL_EMSCRIPTEN_CANVAS_SELECTOR";
HINT_EMSCRIPTEN_KEYBOARD_ELEMENT :: "SDL_EMSCRIPTEN_KEYBOARD_ELEMENT";
HINT_ENABLE_SCREEN_KEYBOARD :: "SDL_ENABLE_SCREEN_KEYBOARD";
HINT_EVDEV_DEVICES :: "SDL_EVDEV_DEVICES";
HINT_EVENT_LOGGING :: "SDL_EVENT_LOGGING";
HINT_FORCE_RAISEWINDOW :: "SDL_FORCE_RAISEWINDOW";
HINT_FRAMEBUFFER_ACCELERATION :: "SDL_FRAMEBUFFER_ACCELERATION";
HINT_GAMECONTROLLERCONFIG :: "SDL_GAMECONTROLLERCONFIG";
HINT_GAMECONTROLLERCONFIG_FILE :: "SDL_GAMECONTROLLERCONFIG_FILE";
HINT_GAMECONTROLLERTYPE :: "SDL_GAMECONTROLLERTYPE";
HINT_GAMECONTROLLER_IGNORE_DEVICES :: "SDL_GAMECONTROLLER_IGNORE_DEVICES";
HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT :: "SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT";
HINT_GAMECONTROLLER_SENSOR_FUSION :: "SDL_GAMECONTROLLER_SENSOR_FUSION";
HINT_GDK_TEXTINPUT_DEFAULT_TEXT :: "SDL_GDK_TEXTINPUT_DEFAULT_TEXT";
HINT_GDK_TEXTINPUT_DESCRIPTION :: "SDL_GDK_TEXTINPUT_DESCRIPTION";
HINT_GDK_TEXTINPUT_MAX_LENGTH :: "SDL_GDK_TEXTINPUT_MAX_LENGTH";
HINT_GDK_TEXTINPUT_SCOPE :: "SDL_GDK_TEXTINPUT_SCOPE";
HINT_GDK_TEXTINPUT_TITLE :: "SDL_GDK_TEXTINPUT_TITLE";
HINT_HIDAPI_LIBUSB :: "SDL_HIDAPI_LIBUSB";
HINT_HIDAPI_LIBUSB_WHITELIST :: "SDL_HIDAPI_LIBUSB_WHITELIST";
HINT_HIDAPI_UDEV :: "SDL_HIDAPI_UDEV";
HINT_GPU_DRIVER :: "SDL_GPU_DRIVER";
HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS :: "SDL_HIDAPI_ENUMERATE_ONLY_CONTROLLERS";
HINT_HIDAPI_IGNORE_DEVICES :: "SDL_HIDAPI_IGNORE_DEVICES";
HINT_IME_IMPLEMENTED_UI :: "SDL_IME_IMPLEMENTED_UI";
HINT_IOS_HIDE_HOME_INDICATOR :: "SDL_IOS_HIDE_HOME_INDICATOR";
HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS :: "SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS";
HINT_JOYSTICK_ARCADESTICK_DEVICES :: "SDL_JOYSTICK_ARCADESTICK_DEVICES";
HINT_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED :: "SDL_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED";
HINT_JOYSTICK_BLACKLIST_DEVICES :: "SDL_JOYSTICK_BLACKLIST_DEVICES";
HINT_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED :: "SDL_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED";
HINT_JOYSTICK_DEVICE :: "SDL_JOYSTICK_DEVICE";
HINT_JOYSTICK_ENHANCED_REPORTS :: "SDL_JOYSTICK_ENHANCED_REPORTS";
HINT_JOYSTICK_FLIGHTSTICK_DEVICES :: "SDL_JOYSTICK_FLIGHTSTICK_DEVICES";
HINT_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED :: "SDL_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED";
HINT_JOYSTICK_GAMEINPUT :: "SDL_JOYSTICK_GAMEINPUT";
HINT_JOYSTICK_GAMECUBE_DEVICES :: "SDL_JOYSTICK_GAMECUBE_DEVICES";
HINT_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED :: "SDL_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED";
HINT_JOYSTICK_HIDAPI :: "SDL_JOYSTICK_HIDAPI";
HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS :: "SDL_JOYSTICK_HIDAPI_COMBINE_JOY_CONS";
HINT_JOYSTICK_HIDAPI_GAMECUBE :: "SDL_JOYSTICK_HIDAPI_GAMECUBE";
HINT_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE :: "SDL_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE";
HINT_JOYSTICK_HIDAPI_JOY_CONS :: "SDL_JOYSTICK_HIDAPI_JOY_CONS";
HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED :: "SDL_JOYSTICK_HIDAPI_JOYCON_HOME_LED";
HINT_JOYSTICK_HIDAPI_LUNA :: "SDL_JOYSTICK_HIDAPI_LUNA";
HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC :: "SDL_JOYSTICK_HIDAPI_NINTENDO_CLASSIC";
HINT_JOYSTICK_HIDAPI_PS3 :: "SDL_JOYSTICK_HIDAPI_PS3";
HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER :: "SDL_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER";
HINT_JOYSTICK_HIDAPI_PS4 :: "SDL_JOYSTICK_HIDAPI_PS4";
HINT_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL :: "SDL_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL";
HINT_JOYSTICK_HIDAPI_PS5 :: "SDL_JOYSTICK_HIDAPI_PS5";
HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED :: "SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED";
HINT_JOYSTICK_HIDAPI_SHIELD :: "SDL_JOYSTICK_HIDAPI_SHIELD";
HINT_JOYSTICK_HIDAPI_STADIA :: "SDL_JOYSTICK_HIDAPI_STADIA";
HINT_JOYSTICK_HIDAPI_STEAM :: "SDL_JOYSTICK_HIDAPI_STEAM";
HINT_JOYSTICK_HIDAPI_STEAM_HOME_LED :: "SDL_JOYSTICK_HIDAPI_STEAM_HOME_LED";
HINT_JOYSTICK_HIDAPI_STEAMDECK :: "SDL_JOYSTICK_HIDAPI_STEAMDECK";
HINT_JOYSTICK_HIDAPI_STEAM_HORI :: "SDL_JOYSTICK_HIDAPI_STEAM_HORI";
HINT_JOYSTICK_HIDAPI_SWITCH :: "SDL_JOYSTICK_HIDAPI_SWITCH";
HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED :: "SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED";
HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED :: "SDL_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED";
HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS :: "SDL_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS";
HINT_JOYSTICK_HIDAPI_WII :: "SDL_JOYSTICK_HIDAPI_WII";
HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED :: "SDL_JOYSTICK_HIDAPI_WII_PLAYER_LED";
HINT_JOYSTICK_HIDAPI_XBOX :: "SDL_JOYSTICK_HIDAPI_XBOX";
HINT_JOYSTICK_HIDAPI_XBOX_360 :: "SDL_JOYSTICK_HIDAPI_XBOX_360";
HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED :: "SDL_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED";
HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS :: "SDL_JOYSTICK_HIDAPI_XBOX_360_WIRELESS";
HINT_JOYSTICK_HIDAPI_XBOX_ONE :: "SDL_JOYSTICK_HIDAPI_XBOX_ONE";
HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED :: "SDL_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED";
HINT_JOYSTICK_IOKIT :: "SDL_JOYSTICK_IOKIT";
HINT_JOYSTICK_LINUX_CLASSIC :: "SDL_JOYSTICK_LINUX_CLASSIC";
HINT_JOYSTICK_LINUX_DEADZONES :: "SDL_JOYSTICK_LINUX_DEADZONES";
HINT_JOYSTICK_LINUX_DIGITAL_HATS :: "SDL_JOYSTICK_LINUX_DIGITAL_HATS";
HINT_JOYSTICK_LINUX_HAT_DEADZONES :: "SDL_JOYSTICK_LINUX_HAT_DEADZONES";
HINT_JOYSTICK_MFI :: "SDL_JOYSTICK_MFI";
HINT_JOYSTICK_RAWINPUT :: "SDL_JOYSTICK_RAWINPUT";
HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT :: "SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT";
HINT_JOYSTICK_ROG_CHAKRAM :: "SDL_JOYSTICK_ROG_CHAKRAM";
HINT_JOYSTICK_THREAD :: "SDL_JOYSTICK_THREAD";
HINT_JOYSTICK_THROTTLE_DEVICES :: "SDL_JOYSTICK_THROTTLE_DEVICES";
HINT_JOYSTICK_THROTTLE_DEVICES_EXCLUDED :: "SDL_JOYSTICK_THROTTLE_DEVICES_EXCLUDED";
HINT_JOYSTICK_WGI :: "SDL_JOYSTICK_WGI";
HINT_JOYSTICK_WHEEL_DEVICES :: "SDL_JOYSTICK_WHEEL_DEVICES";
HINT_JOYSTICK_WHEEL_DEVICES_EXCLUDED :: "SDL_JOYSTICK_WHEEL_DEVICES_EXCLUDED";
HINT_JOYSTICK_ZERO_CENTERED_DEVICES :: "SDL_JOYSTICK_ZERO_CENTERED_DEVICES";
HINT_JOYSTICK_HAPTIC_AXES :: "SDL_JOYSTICK_HAPTIC_AXES";
HINT_KEYCODE_OPTIONS :: "SDL_KEYCODE_OPTIONS";
HINT_KMSDRM_DEVICE_INDEX :: "SDL_KMSDRM_DEVICE_INDEX";
HINT_KMSDRM_REQUIRE_DRM_MASTER :: "SDL_KMSDRM_REQUIRE_DRM_MASTER";
HINT_LOGGING :: "SDL_LOGGING";
HINT_MAC_BACKGROUND_APP :: "SDL_MAC_BACKGROUND_APP";
HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK :: "SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK";
HINT_MAC_OPENGL_ASYNC_DISPATCH :: "SDL_MAC_OPENGL_ASYNC_DISPATCH";
HINT_MAC_OPTION_AS_ALT :: "SDL_MAC_OPTION_AS_ALT";
HINT_MAC_SCROLL_MOMENTUM :: "SDL_MAC_SCROLL_MOMENTUM";
HINT_MAIN_CALLBACK_RATE :: "SDL_MAIN_CALLBACK_RATE";
HINT_MOUSE_AUTO_CAPTURE :: "SDL_MOUSE_AUTO_CAPTURE";
HINT_MOUSE_DOUBLE_CLICK_RADIUS :: "SDL_MOUSE_DOUBLE_CLICK_RADIUS";
HINT_MOUSE_DOUBLE_CLICK_TIME :: "SDL_MOUSE_DOUBLE_CLICK_TIME";
HINT_MOUSE_DEFAULT_SYSTEM_CURSOR :: "SDL_MOUSE_DEFAULT_SYSTEM_CURSOR";
HINT_MOUSE_EMULATE_WARP_WITH_RELATIVE :: "SDL_MOUSE_EMULATE_WARP_WITH_RELATIVE";
HINT_MOUSE_FOCUS_CLICKTHROUGH :: "SDL_MOUSE_FOCUS_CLICKTHROUGH";
HINT_MOUSE_NORMAL_SPEED_SCALE :: "SDL_MOUSE_NORMAL_SPEED_SCALE";
HINT_MOUSE_RELATIVE_MODE_CENTER :: "SDL_MOUSE_RELATIVE_MODE_CENTER";
HINT_MOUSE_RELATIVE_SPEED_SCALE :: "SDL_MOUSE_RELATIVE_SPEED_SCALE";
HINT_MOUSE_RELATIVE_SYSTEM_SCALE :: "SDL_MOUSE_RELATIVE_SYSTEM_SCALE";
HINT_MOUSE_RELATIVE_WARP_MOTION :: "SDL_MOUSE_RELATIVE_WARP_MOTION";
HINT_MOUSE_RELATIVE_CURSOR_VISIBLE :: "SDL_MOUSE_RELATIVE_CURSOR_VISIBLE";
HINT_MOUSE_TOUCH_EVENTS :: "SDL_MOUSE_TOUCH_EVENTS";
HINT_MUTE_CONSOLE_KEYBOARD :: "SDL_MUTE_CONSOLE_KEYBOARD";
HINT_NO_SIGNAL_HANDLERS :: "SDL_NO_SIGNAL_HANDLERS";
HINT_OPENGL_LIBRARY :: "SDL_OPENGL_LIBRARY";
HINT_EGL_LIBRARY :: "SDL_EGL_LIBRARY";
HINT_OPENGL_ES_DRIVER :: "SDL_OPENGL_ES_DRIVER";
HINT_OPENVR_LIBRARY :: "SDL_OPENVR_LIBRARY";
HINT_ORIENTATIONS :: "SDL_ORIENTATIONS";
HINT_POLL_SENTINEL :: "SDL_POLL_SENTINEL";
HINT_PREFERRED_LOCALES :: "SDL_PREFERRED_LOCALES";
HINT_QUIT_ON_LAST_WINDOW_CLOSE :: "SDL_QUIT_ON_LAST_WINDOW_CLOSE";
HINT_RENDER_DIRECT3D_THREADSAFE :: "SDL_RENDER_DIRECT3D_THREADSAFE";
HINT_RENDER_DIRECT3D11_DEBUG :: "SDL_RENDER_DIRECT3D11_DEBUG";
HINT_RENDER_VULKAN_DEBUG :: "SDL_RENDER_VULKAN_DEBUG";
HINT_RENDER_GPU_DEBUG :: "SDL_RENDER_GPU_DEBUG";
HINT_RENDER_GPU_LOW_POWER :: "SDL_RENDER_GPU_LOW_POWER";
HINT_RENDER_DRIVER :: "SDL_RENDER_DRIVER";
HINT_RENDER_LINE_METHOD :: "SDL_RENDER_LINE_METHOD";
HINT_RENDER_METAL_PREFER_LOW_POWER_DEVICE :: "SDL_RENDER_METAL_PREFER_LOW_POWER_DEVICE";
HINT_RENDER_VSYNC :: "SDL_RENDER_VSYNC";
HINT_RETURN_KEY_HIDES_IME :: "SDL_RETURN_KEY_HIDES_IME";
HINT_ROG_GAMEPAD_MICE :: "SDL_ROG_GAMEPAD_MICE";
HINT_ROG_GAMEPAD_MICE_EXCLUDED :: "SDL_ROG_GAMEPAD_MICE_EXCLUDED";
HINT_RPI_VIDEO_LAYER :: "SDL_RPI_VIDEO_LAYER";
HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME :: "SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME";
HINT_SHUTDOWN_DBUS_ON_QUIT :: "SDL_SHUTDOWN_DBUS_ON_QUIT";
HINT_STORAGE_TITLE_DRIVER :: "SDL_STORAGE_TITLE_DRIVER";
HINT_STORAGE_USER_DRIVER :: "SDL_STORAGE_USER_DRIVER";
HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL :: "SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL";
HINT_THREAD_PRIORITY_POLICY :: "SDL_THREAD_PRIORITY_POLICY";
HINT_TIMER_RESOLUTION :: "SDL_TIMER_RESOLUTION";
HINT_TOUCH_MOUSE_EVENTS :: "SDL_TOUCH_MOUSE_EVENTS";
HINT_TRACKPAD_IS_TOUCH_ONLY :: "SDL_TRACKPAD_IS_TOUCH_ONLY";
HINT_TV_REMOTE_AS_JOYSTICK :: "SDL_TV_REMOTE_AS_JOYSTICK";
HINT_VIDEO_ALLOW_SCREENSAVER :: "SDL_VIDEO_ALLOW_SCREENSAVER";
HINT_VIDEO_DISPLAY_PRIORITY :: "SDL_VIDEO_DISPLAY_PRIORITY";
HINT_VIDEO_DOUBLE_BUFFER :: "SDL_VIDEO_DOUBLE_BUFFER";
HINT_VIDEO_DRIVER :: "SDL_VIDEO_DRIVER";
HINT_VIDEO_DUMMY_SAVE_FRAMES :: "SDL_VIDEO_DUMMY_SAVE_FRAMES";
HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK :: "SDL_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK";
HINT_VIDEO_FORCE_EGL :: "SDL_VIDEO_FORCE_EGL";
HINT_VIDEO_MAC_FULLSCREEN_SPACES :: "SDL_VIDEO_MAC_FULLSCREEN_SPACES";
HINT_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY :: "SDL_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY";
HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS :: "SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS";
HINT_VIDEO_OFFSCREEN_SAVE_FRAMES :: "SDL_VIDEO_OFFSCREEN_SAVE_FRAMES";
HINT_VIDEO_SYNC_WINDOW_OPERATIONS :: "SDL_VIDEO_SYNC_WINDOW_OPERATIONS";
HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR :: "SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR";
HINT_VIDEO_WAYLAND_MODE_EMULATION :: "SDL_VIDEO_WAYLAND_MODE_EMULATION";
HINT_VIDEO_WAYLAND_MODE_SCALING :: "SDL_VIDEO_WAYLAND_MODE_SCALING";
HINT_VIDEO_WAYLAND_PREFER_LIBDECOR :: "SDL_VIDEO_WAYLAND_PREFER_LIBDECOR";
HINT_VIDEO_WAYLAND_SCALE_TO_DISPLAY :: "SDL_VIDEO_WAYLAND_SCALE_TO_DISPLAY";
HINT_VIDEO_WIN_D3DCOMPILER :: "SDL_VIDEO_WIN_D3DCOMPILER";
HINT_VIDEO_X11_EXTERNAL_WINDOW_INPUT :: "SDL_VIDEO_X11_EXTERNAL_WINDOW_INPUT";
HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR :: "SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR";
HINT_VIDEO_X11_NET_WM_PING :: "SDL_VIDEO_X11_NET_WM_PING";
HINT_VIDEO_X11_NODIRECTCOLOR :: "SDL_VIDEO_X11_NODIRECTCOLOR";
HINT_VIDEO_X11_SCALING_FACTOR :: "SDL_VIDEO_X11_SCALING_FACTOR";
HINT_VIDEO_X11_VISUALID :: "SDL_VIDEO_X11_VISUALID";
HINT_VIDEO_X11_WINDOW_VISUALID :: "SDL_VIDEO_X11_WINDOW_VISUALID";
HINT_VIDEO_X11_XRANDR :: "SDL_VIDEO_X11_XRANDR";
HINT_VITA_ENABLE_BACK_TOUCH :: "SDL_VITA_ENABLE_BACK_TOUCH";
HINT_VITA_ENABLE_FRONT_TOUCH :: "SDL_VITA_ENABLE_FRONT_TOUCH";
HINT_VITA_MODULE_PATH :: "SDL_VITA_MODULE_PATH";
HINT_VITA_PVR_INIT :: "SDL_VITA_PVR_INIT";
HINT_VITA_RESOLUTION :: "SDL_VITA_RESOLUTION";
HINT_VITA_PVR_OPENGL :: "SDL_VITA_PVR_OPENGL";
HINT_VITA_TOUCH_MOUSE_DEVICE :: "SDL_VITA_TOUCH_MOUSE_DEVICE";
HINT_VULKAN_DISPLAY :: "SDL_VULKAN_DISPLAY";
HINT_VULKAN_LIBRARY :: "SDL_VULKAN_LIBRARY";
HINT_WAVE_FACT_CHUNK :: "SDL_WAVE_FACT_CHUNK";
HINT_WAVE_CHUNK_LIMIT :: "SDL_WAVE_CHUNK_LIMIT";
HINT_WAVE_RIFF_CHUNK_SIZE :: "SDL_WAVE_RIFF_CHUNK_SIZE";
HINT_WAVE_TRUNCATION :: "SDL_WAVE_TRUNCATION";
HINT_WINDOW_ACTIVATE_WHEN_RAISED :: "SDL_WINDOW_ACTIVATE_WHEN_RAISED";
HINT_WINDOW_ACTIVATE_WHEN_SHOWN :: "SDL_WINDOW_ACTIVATE_WHEN_SHOWN";
HINT_WINDOW_ALLOW_TOPMOST :: "SDL_WINDOW_ALLOW_TOPMOST";
HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN :: "SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN";
HINT_WINDOWS_CLOSE_ON_ALT_F4 :: "SDL_WINDOWS_CLOSE_ON_ALT_F4";
HINT_WINDOWS_ENABLE_MENU_MNEMONICS :: "SDL_WINDOWS_ENABLE_MENU_MNEMONICS";
HINT_WINDOWS_ENABLE_MESSAGELOOP :: "SDL_WINDOWS_ENABLE_MESSAGELOOP";
HINT_WINDOWS_GAMEINPUT :: "SDL_WINDOWS_GAMEINPUT";
HINT_WINDOWS_RAW_KEYBOARD :: "SDL_WINDOWS_RAW_KEYBOARD";
HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL :: "SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL";
HINT_WINDOWS_INTRESOURCE_ICON :: "SDL_WINDOWS_INTRESOURCE_ICON";
HINT_WINDOWS_INTRESOURCE_ICON_SMALL :: "SDL_WINDOWS_INTRESOURCE_ICON_SMALL";
HINT_WINDOWS_USE_D3D9EX :: "SDL_WINDOWS_USE_D3D9EX";
HINT_WINDOWS_ERASE_BACKGROUND_MODE :: "SDL_WINDOWS_ERASE_BACKGROUND_MODE";
HINT_X11_FORCE_OVERRIDE_REDIRECT :: "SDL_X11_FORCE_OVERRIDE_REDIRECT";
HINT_X11_WINDOW_TYPE :: "SDL_X11_WINDOW_TYPE";
HINT_X11_XCB_LIBRARY :: "SDL_X11_XCB_LIBRARY";
HINT_XINPUT_ENABLED :: "SDL_XINPUT_ENABLED";
HINT_ASSERT :: "SDL_ASSERT";
HINT_PEN_MOUSE_EVENTS :: "SDL_PEN_MOUSE_EVENTS";
HINT_PEN_TOUCH_EVENTS :: "SDL_PEN_TOUCH_EVENTS";
INIT_AUDIO    :: 0x00000010 as u32;
INIT_VIDEO    :: 0x00000020 as u32;
INIT_JOYSTICK :: 0x00000200 as u32;
INIT_HAPTIC   :: 0x00001000 as u32;
INIT_GAMEPAD  :: 0x00002000 as u32;
INIT_EVENTS   :: 0x00004000 as u32;
INIT_SENSOR   :: 0x00008000 as u32;
INIT_CAMERA   :: 0x00010000 as u32;
PROP_APP_METADATA_NAME_STRING :: "SDL.app.metadata.name";
PROP_APP_METADATA_VERSION_STRING :: "SDL.app.metadata.version";
PROP_APP_METADATA_IDENTIFIER_STRING :: "SDL.app.metadata.identifier";
PROP_APP_METADATA_CREATOR_STRING :: "SDL.app.metadata.creator";
PROP_APP_METADATA_COPYRIGHT_STRING :: "SDL.app.metadata.copyright";
PROP_APP_METADATA_URL_STRING :: "SDL.app.metadata.url";
PROP_APP_METADATA_TYPE_STRING :: "SDL.app.metadata.type";
MESSAGEBOX_ERROR 					:: 0x00000010 as u32;
MESSAGEBOX_WARNING					:: 0x00000020 as u32;
MESSAGEBOX_INFORMATION				:: 0x00000040 as u32;
MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT	:: 0x00000080 as u32;
MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT 	:: 0x00000100 as u32;
MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT :: 0x00000001 as u32;
MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT :: 0x00000002 as u32;
PROP_PROCESS_CREATE_ARGS_POINTER :: "SDL.process.create.args";
PROP_PROCESS_CREATE_ENVIRONMENT_POINTER :: "SDL.process.create.environment";
PROP_PROCESS_CREATE_STDIN_NUMBER :: "SDL.process.create.stdin_option";
PROP_PROCESS_CREATE_STDIN_POINTER :: "SDL.process.create.stdin_source";
PROP_PROCESS_CREATE_STDOUT_NUMBER :: "SDL.process.create.stdout_option";
PROP_PROCESS_CREATE_STDOUT_POINTER :: "SDL.process.create.stdout_source";
PROP_PROCESS_CREATE_STDERR_NUMBER :: "SDL.process.create.stderr_option";
PROP_PROCESS_CREATE_STDERR_POINTER :: "SDL.process.create.stderr_source";
PROP_PROCESS_CREATE_STDERR_TO_STDOUT_BOOLEAN :: "SDL.process.create.stderr_to_stdout";
PROP_PROCESS_CREATE_BACKGROUND_BOOLEAN :: "SDL.process.create.background";
PROP_PROCESS_PID_NUMBER :: "SDL.process.pid";
PROP_PROCESS_STDIN_POINTER :: "SDL.process.stdin";
PROP_PROCESS_STDOUT_POINTER :: "SDL.process.stdout";
PROP_PROCESS_STDERR_POINTER :: "SDL.process.stderr";
PROP_PROCESS_BACKGROUND_BOOLEAN :: "SDL.process.background";
SOFTWARE_RENDERER :: "software";
PROP_RENDERER_CREATE_NAME_STRING :: "SDL.renderer.create.name";
PROP_RENDERER_CREATE_WINDOW_POINTER :: "SDL.renderer.create.window";
PROP_RENDERER_CREATE_SURFACE_POINTER :: "SDL.renderer.create.surface";
PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER :: "SDL.renderer.create.output_colorspace";
PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER :: "SDL.renderer.create.present_vsync";
PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER :: "SDL.renderer.create.vulkan.instance";
PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER :: "SDL.renderer.create.vulkan.surface";
PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER :: "SDL.renderer.create.vulkan.physical_device";
PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER :: "SDL.renderer.create.vulkan.device";
PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER :: "SDL.renderer.create.vulkan.graphics_queue_family_index";
PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER :: "SDL.renderer.create.vulkan.present_queue_family_index";
PROP_RENDERER_NAME_STRING :: "SDL.renderer.name";
PROP_RENDERER_WINDOW_POINTER :: "SDL.renderer.window";
PROP_RENDERER_SURFACE_POINTER :: "SDL.renderer.surface";
PROP_RENDERER_VSYNC_NUMBER :: "SDL.renderer.vsync";
PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER :: "SDL.renderer.max_texture_size";
PROP_RENDERER_TEXTURE_FORMATS_POINTER :: "SDL.renderer.texture_formats";
PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER :: "SDL.renderer.output_colorspace";
PROP_RENDERER_HDR_ENABLED_BOOLEAN :: "SDL.renderer.HDR_enabled";
PROP_RENDERER_SDR_WHITE_POINT_FLOAT :: "SDL.renderer.SDR_white_point";
PROP_RENDERER_HDR_HEADROOM_FLOAT :: "SDL.renderer.HDR_headroom";
PROP_RENDERER_D3D9_DEVICE_POINTER :: "SDL.renderer.d3d9.device";
PROP_RENDERER_D3D11_DEVICE_POINTER :: "SDL.renderer.d3d11.device";
PROP_RENDERER_D3D11_SWAPCHAIN_POINTER :: "SDL.renderer.d3d11.swap_chain";
PROP_RENDERER_D3D12_DEVICE_POINTER :: "SDL.renderer.d3d12.device";
PROP_RENDERER_D3D12_SWAPCHAIN_POINTER :: "SDL.renderer.d3d12.swap_chain";
PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER :: "SDL.renderer.d3d12.command_queue";
PROP_RENDERER_VULKAN_INSTANCE_POINTER :: "SDL.renderer.vulkan.instance";
PROP_RENDERER_VULKAN_SURFACE_NUMBER :: "SDL.renderer.vulkan.surface";
PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER :: "SDL.renderer.vulkan.physical_device";
PROP_RENDERER_VULKAN_DEVICE_POINTER :: "SDL.renderer.vulkan.device";
PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER :: "SDL.renderer.vulkan.graphics_queue_family_index";
PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER :: "SDL.renderer.vulkan.present_queue_family_index";
PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER :: "SDL.renderer.vulkan.swapchain_image_count";
PROP_RENDERER_GPU_DEVICE_POINTER :: "SDL.renderer.gpu.device";
PROP_TEXTURE_CREATE_COLORSPACE_NUMBER :: "SDL.texture.create.colorspace";
PROP_TEXTURE_CREATE_FORMAT_NUMBER :: "SDL.texture.create.format";
PROP_TEXTURE_CREATE_ACCESS_NUMBER :: "SDL.texture.create.access";
PROP_TEXTURE_CREATE_WIDTH_NUMBER :: "SDL.texture.create.width";
PROP_TEXTURE_CREATE_HEIGHT_NUMBER :: "SDL.texture.create.height";
PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT :: "SDL.texture.create.SDR_white_point";
PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT :: "SDL.texture.create.HDR_headroom";
PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER :: "SDL.texture.create.d3d11.texture";
PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER :: "SDL.texture.create.d3d11.texture_u";
PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER :: "SDL.texture.create.d3d11.texture_v";
PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER :: "SDL.texture.create.d3d12.texture";
PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER :: "SDL.texture.create.d3d12.texture_u";
PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER :: "SDL.texture.create.d3d12.texture_v";
PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER :: "SDL.texture.create.metal.pixelbuffer";
PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER :: "SDL.texture.create.opengl.texture";
PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER :: "SDL.texture.create.opengl.texture_uv";
PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER :: "SDL.texture.create.opengl.texture_u";
PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER :: "SDL.texture.create.opengl.texture_v";
PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER :: "SDL.texture.create.opengles2.texture";
PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER :: "SDL.texture.create.opengles2.texture_uv";
PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER :: "SDL.texture.create.opengles2.texture_u";
PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER :: "SDL.texture.create.opengles2.texture_v";
PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER :: "SDL.texture.create.vulkan.texture";
PROP_TEXTURE_COLORSPACE_NUMBER :: "SDL.texture.colorspace";
PROP_TEXTURE_FORMAT_NUMBER :: "SDL.texture.format";
PROP_TEXTURE_ACCESS_NUMBER :: "SDL.texture.access";
PROP_TEXTURE_WIDTH_NUMBER :: "SDL.texture.width";
PROP_TEXTURE_HEIGHT_NUMBER :: "SDL.texture.height";
PROP_TEXTURE_SDR_WHITE_POINT_FLOAT :: "SDL.texture.SDR_white_point";
PROP_TEXTURE_HDR_HEADROOM_FLOAT :: "SDL.texture.HDR_headroom";
PROP_TEXTURE_D3D11_TEXTURE_POINTER :: "SDL.texture.d3d11.texture";
PROP_TEXTURE_D3D11_TEXTURE_U_POINTER :: "SDL.texture.d3d11.texture_u";
PROP_TEXTURE_D3D11_TEXTURE_V_POINTER :: "SDL.texture.d3d11.texture_v";
PROP_TEXTURE_D3D12_TEXTURE_POINTER :: "SDL.texture.d3d12.texture";
PROP_TEXTURE_D3D12_TEXTURE_U_POINTER :: "SDL.texture.d3d12.texture_u";
PROP_TEXTURE_D3D12_TEXTURE_V_POINTER :: "SDL.texture.d3d12.texture_v";
PROP_TEXTURE_OPENGL_TEXTURE_NUMBER :: "SDL.texture.opengl.texture";
PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER :: "SDL.texture.opengl.texture_uv";
PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER :: "SDL.texture.opengl.texture_u";
PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER :: "SDL.texture.opengl.texture_v";
PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER :: "SDL.texture.opengl.target";
PROP_TEXTURE_OPENGL_TEX_W_FLOAT :: "SDL.texture.opengl.tex_w";
PROP_TEXTURE_OPENGL_TEX_H_FLOAT :: "SDL.texture.opengl.tex_h";
PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER :: "SDL.texture.opengles2.texture";
PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER :: "SDL.texture.opengles2.texture_uv";
PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER :: "SDL.texture.opengles2.texture_u";
PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER :: "SDL.texture.opengles2.texture_v";
PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER :: "SDL.texture.opengles2.target";
PROP_TEXTURE_VULKAN_TEXTURE_NUMBER :: "SDL.texture.vulkan.texture";
RENDERER_VSYNC_DISABLED :: 0;
RENDERER_VSYNC_ADAPTIVE :: ( - 1 );
DEBUG_TEXT_FONT_CHARACTER_SIZE :: 8;
MS_PER_SECOND :: 1000;
US_PER_SECOND :: 1000000;
NS_PER_SECOND :: 1000000000;
NS_PER_MS :: 1000000;
NS_PER_US :: 1000;
TRAYENTRY_BUTTON :: 0x00000001;
TRAYENTRY_CHECKBOX :: 0x00000002;
TRAYENTRY_SUBMENU :: 0x00000004;
TRAYENTRY_DISABLED :: 0x80000000;
TRAYENTRY_CHECKED :: 0x40000000;
MAJOR_VERSION :: 3;
MINOR_VERSION :: 2;
MICRO_VERSION :: 20;

Sint8 :: i8;

Uint8 :: u8;

Sint16 :: i16;

Uint16 :: u16;

Sint32 :: i32;

Uint32 :: u32;

Sint64 :: i64;

Uint64 :: u64;

Time :: Sint64;

struct alignment_test {
	a: Uint8,
	b: ?*,
}

enum DUMMY_ENUM: u32 {
	VALUE = 0x0,
}

malloc :: fn(
	size: uint
) -> ?* #foreign #link="SDL_malloc";

calloc :: fn(
	nmemb: uint,
	size: uint
) -> ?* #foreign #link="SDL_calloc";

realloc :: fn(
	mem: ?*,
	size: uint
) -> ?* #foreign #link="SDL_realloc";

free :: fn(
	mem: ?*
) #foreign #link="SDL_free";

malloc_func :: ?*fn(a: uint) -> ?* #foreign;

calloc_func :: ?*fn(a: uint, b: uint) -> ?* #foreign;

realloc_func :: ?*fn(a: ?*, b: uint) -> ?* #foreign;

free_func :: ?*fn(a: ?*) #foreign;

GetOriginalMemoryFunctions :: fn(
	malloc_func: ?*malloc_func,
	calloc_func: ?*calloc_func,
	realloc_func: ?*realloc_func,
	free_func: ?*free_func
) #foreign #link="SDL_GetOriginalMemoryFunctions";

GetMemoryFunctions :: fn(
	malloc_func: ?*malloc_func,
	calloc_func: ?*calloc_func,
	realloc_func: ?*realloc_func,
	free_func: ?*free_func
) #foreign #link="SDL_GetMemoryFunctions";

SetMemoryFunctions :: fn(
	malloc_func: malloc_func,
	calloc_func: calloc_func,
	realloc_func: realloc_func,
	free_func: free_func
) -> bool #foreign #link="SDL_SetMemoryFunctions";

aligned_alloc :: fn(
	alignment: uint,
	size: uint
) -> ?* #foreign #link="SDL_aligned_alloc";

aligned_free :: fn(
	mem: ?*
) #foreign #link="SDL_aligned_free";

GetNumAllocations :: fn() -> i32 #foreign #link="SDL_GetNumAllocations";

struct Environment {
}

GetEnvironment :: fn() -> ?*Environment #foreign #link="SDL_GetEnvironment";

CreateEnvironment :: fn(
	populated: bool
) -> ?*Environment #foreign #link="SDL_CreateEnvironment";

GetEnvironmentVariable :: fn(
	env: ?*Environment,
	name: ?*u8
) -> ?*u8 #foreign #link="SDL_GetEnvironmentVariable";

GetEnvironmentVariables :: fn(
	env: ?*Environment
) -> ?*?*u8 #foreign #link="SDL_GetEnvironmentVariables";

SetEnvironmentVariable :: fn(
	env: ?*Environment,
	name: ?*u8,
	value: ?*u8,
	overwrite: bool
) -> bool #foreign #link="SDL_SetEnvironmentVariable";

UnsetEnvironmentVariable :: fn(
	env: ?*Environment,
	name: ?*u8
) -> bool #foreign #link="SDL_UnsetEnvironmentVariable";

DestroyEnvironment :: fn(
	env: ?*Environment
) #foreign #link="SDL_DestroyEnvironment";

getenv :: fn(
	name: ?*u8
) -> ?*u8 #foreign #link="SDL_getenv";

getenv_unsafe :: fn(
	name: ?*u8
) -> ?*u8 #foreign #link="SDL_getenv_unsafe";

setenv_unsafe :: fn(
	name: ?*u8,
	value: ?*u8,
	overwrite: i32
) -> i32 #foreign #link="SDL_setenv_unsafe";

unsetenv_unsafe :: fn(
	name: ?*u8
) -> i32 #foreign #link="SDL_unsetenv_unsafe";

CompareCallback :: ?*fn(a: ?*, b: ?*) -> i32 #foreign;

qsort :: fn(
	base: ?*,
	nmemb: uint,
	size: uint,
	compare: CompareCallback
) #foreign #link="SDL_qsort";

bsearch :: fn(
	key: ?*,
	base: ?*,
	nmemb: uint,
	size: uint,
	compare: CompareCallback
) -> ?* #foreign #link="SDL_bsearch";

CompareCallback_r :: ?*fn(a: ?*, b: ?*, c: ?*) -> i32 #foreign;

qsort_r :: fn(
	base: ?*,
	nmemb: uint,
	size: uint,
	compare: CompareCallback_r,
	userdata: ?*
) #foreign #link="SDL_qsort_r";

bsearch_r :: fn(
	key: ?*,
	base: ?*,
	nmemb: uint,
	size: uint,
	compare: CompareCallback_r,
	userdata: ?*
) -> ?* #foreign #link="SDL_bsearch_r";

abs :: fn(
	x: i32
) -> i32 #foreign #link="SDL_abs";

isalpha :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isalpha";

isalnum :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isalnum";

isblank :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isblank";

iscntrl :: fn(
	x: i32
) -> i32 #foreign #link="SDL_iscntrl";

isdigit :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isdigit";

isxdigit :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isxdigit";

ispunct :: fn(
	x: i32
) -> i32 #foreign #link="SDL_ispunct";

isspace :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isspace";

isupper :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isupper";

islower :: fn(
	x: i32
) -> i32 #foreign #link="SDL_islower";

isprint :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isprint";

isgraph :: fn(
	x: i32
) -> i32 #foreign #link="SDL_isgraph";

toupper :: fn(
	x: i32
) -> i32 #foreign #link="SDL_toupper";

tolower :: fn(
	x: i32
) -> i32 #foreign #link="SDL_tolower";

crc16 :: fn(
	crc: Uint16,
	data: ?*,
	len: uint
) -> Uint16 #foreign #link="SDL_crc16";

crc32 :: fn(
	crc: Uint32,
	data: ?*,
	len: uint
) -> Uint32 #foreign #link="SDL_crc32";

murmur3_32 :: fn(
	data: ?*,
	len: uint,
	seed: Uint32
) -> Uint32 #foreign #link="SDL_murmur3_32";

memcpy :: fn(
	dst: ?*,
	src: ?*,
	len: uint
) -> ?* #foreign #link="SDL_memcpy";

memmove :: fn(
	dst: ?*,
	src: ?*,
	len: uint
) -> ?* #foreign #link="SDL_memmove";

memset :: fn(
	dst: ?*,
	c: i32,
	len: uint
) -> ?* #foreign #link="SDL_memset";

memset4 :: fn(
	dst: ?*,
	val: Uint32,
	dwords: uint
) -> ?* #foreign #link="SDL_memset4";

memcmp :: fn(
	s1: ?*,
	s2: ?*,
	len: uint
) -> i32 #foreign #link="SDL_memcmp";

wcslen :: fn(
	wstr: ?*wchar_t
) -> uint #foreign #link="SDL_wcslen";

wcsnlen :: fn(
	wstr: ?*wchar_t,
	maxlen: uint
) -> uint #foreign #link="SDL_wcsnlen";

wcslcpy :: fn(
	dst: ?*wchar_t,
	src: ?*wchar_t,
	maxlen: uint
) -> uint #foreign #link="SDL_wcslcpy";

wcslcat :: fn(
	dst: ?*wchar_t,
	src: ?*wchar_t,
	maxlen: uint
) -> uint #foreign #link="SDL_wcslcat";

wcsdup :: fn(
	wstr: ?*wchar_t
) -> ?*wchar_t #foreign #link="SDL_wcsdup";

wcsstr :: fn(
	haystack: ?*wchar_t,
	needle: ?*wchar_t
) -> ?*wchar_t #foreign #link="SDL_wcsstr";

wcsnstr :: fn(
	haystack: ?*wchar_t,
	needle: ?*wchar_t,
	maxlen: uint
) -> ?*wchar_t #foreign #link="SDL_wcsnstr";

wcscmp :: fn(
	str1: ?*wchar_t,
	str2: ?*wchar_t
) -> i32 #foreign #link="SDL_wcscmp";

wcsncmp :: fn(
	str1: ?*wchar_t,
	str2: ?*wchar_t,
	maxlen: uint
) -> i32 #foreign #link="SDL_wcsncmp";

wcscasecmp :: fn(
	str1: ?*wchar_t,
	str2: ?*wchar_t
) -> i32 #foreign #link="SDL_wcscasecmp";

wcsncasecmp :: fn(
	str1: ?*wchar_t,
	str2: ?*wchar_t,
	maxlen: uint
) -> i32 #foreign #link="SDL_wcsncasecmp";

wcstol :: fn(
	str: ?*wchar_t,
	endp: ?*?*wchar_t,
	base: i32
) -> i32 #foreign #link="SDL_wcstol";

strlen :: fn(
	str: ?*u8
) -> uint #foreign #link="SDL_strlen";

strnlen :: fn(
	str: ?*u8,
	maxlen: uint
) -> uint #foreign #link="SDL_strnlen";

strlcpy :: fn(
	dst: ?*u8,
	src: ?*u8,
	maxlen: uint
) -> uint #foreign #link="SDL_strlcpy";

utf8strlcpy :: fn(
	dst: ?*u8,
	src: ?*u8,
	dst_bytes: uint
) -> uint #foreign #link="SDL_utf8strlcpy";

strlcat :: fn(
	dst: ?*u8,
	src: ?*u8,
	maxlen: uint
) -> uint #foreign #link="SDL_strlcat";

strdup :: fn(
	str: ?*u8
) -> ?*u8 #foreign #link="SDL_strdup";

strndup :: fn(
	str: ?*u8,
	maxlen: uint
) -> ?*u8 #foreign #link="SDL_strndup";

strrev :: fn(
	str: ?*u8
) -> ?*u8 #foreign #link="SDL_strrev";

strupr :: fn(
	str: ?*u8
) -> ?*u8 #foreign #link="SDL_strupr";

strlwr :: fn(
	str: ?*u8
) -> ?*u8 #foreign #link="SDL_strlwr";

strchr :: fn(
	str: ?*u8,
	c: i32
) -> ?*u8 #foreign #link="SDL_strchr";

strrchr :: fn(
	str: ?*u8,
	c: i32
) -> ?*u8 #foreign #link="SDL_strrchr";

strstr :: fn(
	haystack: ?*u8,
	needle: ?*u8
) -> ?*u8 #foreign #link="SDL_strstr";

strnstr :: fn(
	haystack: ?*u8,
	needle: ?*u8,
	maxlen: uint
) -> ?*u8 #foreign #link="SDL_strnstr";

strcasestr :: fn(
	haystack: ?*u8,
	needle: ?*u8
) -> ?*u8 #foreign #link="SDL_strcasestr";

strtok_r :: fn(
	str: ?*u8,
	delim: ?*u8,
	saveptr: ?*?*u8
) -> ?*u8 #foreign #link="SDL_strtok_r";

utf8strlen :: fn(
	str: ?*u8
) -> uint #foreign #link="SDL_utf8strlen";

utf8strnlen :: fn(
	str: ?*u8,
	bytes: uint
) -> uint #foreign #link="SDL_utf8strnlen";

itoa :: fn(
	value: i32,
	str: ?*u8,
	radix: i32
) -> ?*u8 #foreign #link="SDL_itoa";

uitoa :: fn(
	value: u32,
	str: ?*u8,
	radix: i32
) -> ?*u8 #foreign #link="SDL_uitoa";

ltoa :: fn(
	value: i32,
	str: ?*u8,
	radix: i32
) -> ?*u8 #foreign #link="SDL_ltoa";

ultoa :: fn(
	value: u32,
	str: ?*u8,
	radix: i32
) -> ?*u8 #foreign #link="SDL_ultoa";

lltoa :: fn(
	value: i64,
	str: ?*u8,
	radix: i32
) -> ?*u8 #foreign #link="SDL_lltoa";

ulltoa :: fn(
	value: u64,
	str: ?*u8,
	radix: i32
) -> ?*u8 #foreign #link="SDL_ulltoa";

atoi :: fn(
	str: ?*u8
) -> i32 #foreign #link="SDL_atoi";

atof :: fn(
	str: ?*u8
) -> f64 #foreign #link="SDL_atof";

strtol :: fn(
	str: ?*u8,
	endp: ?*?*u8,
	base: i32
) -> i32 #foreign #link="SDL_strtol";

strtoul :: fn(
	str: ?*u8,
	endp: ?*?*u8,
	base: i32
) -> u32 #foreign #link="SDL_strtoul";

strtoll :: fn(
	str: ?*u8,
	endp: ?*?*u8,
	base: i32
) -> i64 #foreign #link="SDL_strtoll";

strtoull :: fn(
	str: ?*u8,
	endp: ?*?*u8,
	base: i32
) -> u64 #foreign #link="SDL_strtoull";

strtod :: fn(
	str: ?*u8,
	endp: ?*?*u8
) -> f64 #foreign #link="SDL_strtod";

strcmp :: fn(
	str1: ?*u8,
	str2: ?*u8
) -> i32 #foreign #link="SDL_strcmp";

strncmp :: fn(
	str1: ?*u8,
	str2: ?*u8,
	maxlen: uint
) -> i32 #foreign #link="SDL_strncmp";

strcasecmp :: fn(
	str1: ?*u8,
	str2: ?*u8
) -> i32 #foreign #link="SDL_strcasecmp";

strncasecmp :: fn(
	str1: ?*u8,
	str2: ?*u8,
	maxlen: uint
) -> i32 #foreign #link="SDL_strncasecmp";

strpbrk :: fn(
	str: ?*u8,
	breakset: ?*u8
) -> ?*u8 #foreign #link="SDL_strpbrk";

StepUTF8 :: fn(
	pstr: ?*?*u8,
	pslen: ?*uint
) -> Uint32 #foreign #link="SDL_StepUTF8";

StepBackUTF8 :: fn(
	start: ?*u8,
	pstr: ?*?*u8
) -> Uint32 #foreign #link="SDL_StepBackUTF8";

UCS4ToUTF8 :: fn(
	codepoint: Uint32,
	dst: ?*u8
) -> ?*u8 #foreign #link="SDL_UCS4ToUTF8";

sscanf :: fn(
	text: ?*u8,
	fmt: ?*u8
) -> i32 #foreign #link="SDL_sscanf";

snprintf :: fn(
	text: ?*u8,
	maxlen: uint,
	fmt: ?*u8
) -> i32 #foreign #link="SDL_snprintf";

swprintf :: fn(
	text: ?*wchar_t,
	maxlen: uint,
	fmt: ?*wchar_t
) -> i32 #foreign #link="SDL_swprintf";

asprintf :: fn(
	strp: ?*?*u8,
	fmt: ?*u8
) -> i32 #foreign #link="SDL_asprintf";

srand :: fn(
	seed: Uint64
) #foreign #link="SDL_srand";

rand :: fn(
	n: Sint32
) -> Sint32 #foreign #link="SDL_rand";

randf :: fn() -> f32 #foreign #link="SDL_randf";

rand_bits :: fn() -> Uint32 #foreign #link="SDL_rand_bits";

rand_r :: fn(
	state: ?*Uint64,
	n: Sint32
) -> Sint32 #foreign #link="SDL_rand_r";

randf_r :: fn(
	state: ?*Uint64
) -> f32 #foreign #link="SDL_randf_r";

rand_bits_r :: fn(
	state: ?*Uint64
) -> Uint32 #foreign #link="SDL_rand_bits_r";

acos :: fn(
	x: f64
) -> f64 #foreign #link="SDL_acos";

acosf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_acosf";

asin :: fn(
	x: f64
) -> f64 #foreign #link="SDL_asin";

asinf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_asinf";

atan :: fn(
	x: f64
) -> f64 #foreign #link="SDL_atan";

atanf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_atanf";

atan2 :: fn(
	y: f64,
	x: f64
) -> f64 #foreign #link="SDL_atan2";

atan2f :: fn(
	y: f32,
	x: f32
) -> f32 #foreign #link="SDL_atan2f";

ceil :: fn(
	x: f64
) -> f64 #foreign #link="SDL_ceil";

ceilf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_ceilf";

copysign :: fn(
	x: f64,
	y: f64
) -> f64 #foreign #link="SDL_copysign";

copysignf :: fn(
	x: f32,
	y: f32
) -> f32 #foreign #link="SDL_copysignf";

cos :: fn(
	x: f64
) -> f64 #foreign #link="SDL_cos";

cosf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_cosf";

exp :: fn(
	x: f64
) -> f64 #foreign #link="SDL_exp";

expf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_expf";

fabs :: fn(
	x: f64
) -> f64 #foreign #link="SDL_fabs";

fabsf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_fabsf";

floor :: fn(
	x: f64
) -> f64 #foreign #link="SDL_floor";

floorf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_floorf";

trunc :: fn(
	x: f64
) -> f64 #foreign #link="SDL_trunc";

truncf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_truncf";

fmod :: fn(
	x: f64,
	y: f64
) -> f64 #foreign #link="SDL_fmod";

fmodf :: fn(
	x: f32,
	y: f32
) -> f32 #foreign #link="SDL_fmodf";

isinf :: fn(
	x: f64
) -> i32 #foreign #link="SDL_isinf";

isinff :: fn(
	x: f32
) -> i32 #foreign #link="SDL_isinff";

isnan :: fn(
	x: f64
) -> i32 #foreign #link="SDL_isnan";

isnanf :: fn(
	x: f32
) -> i32 #foreign #link="SDL_isnanf";

log :: fn(
	x: f64
) -> f64 #foreign #link="SDL_log";

logf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_logf";

log10 :: fn(
	x: f64
) -> f64 #foreign #link="SDL_log10";

log10f :: fn(
	x: f32
) -> f32 #foreign #link="SDL_log10f";

modf :: fn(
	x: f64,
	y: ?*f64
) -> f64 #foreign #link="SDL_modf";

modff :: fn(
	x: f32,
	y: ?*f32
) -> f32 #foreign #link="SDL_modff";

pow :: fn(
	x: f64,
	y: f64
) -> f64 #foreign #link="SDL_pow";

powf :: fn(
	x: f32,
	y: f32
) -> f32 #foreign #link="SDL_powf";

round :: fn(
	x: f64
) -> f64 #foreign #link="SDL_round";

roundf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_roundf";

lround :: fn(
	x: f64
) -> i32 #foreign #link="SDL_lround";

lroundf :: fn(
	x: f32
) -> i32 #foreign #link="SDL_lroundf";

scalbn :: fn(
	x: f64,
	n: i32
) -> f64 #foreign #link="SDL_scalbn";

scalbnf :: fn(
	x: f32,
	n: i32
) -> f32 #foreign #link="SDL_scalbnf";

sin :: fn(
	x: f64
) -> f64 #foreign #link="SDL_sin";

sinf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_sinf";

sqrt :: fn(
	x: f64
) -> f64 #foreign #link="SDL_sqrt";

sqrtf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_sqrtf";

tan :: fn(
	x: f64
) -> f64 #foreign #link="SDL_tan";

tanf :: fn(
	x: f32
) -> f32 #foreign #link="SDL_tanf";

struct iconv_data_t {
}

iconv_t :: ?*iconv_data_t;

iconv_open :: fn(
	tocode: ?*u8,
	fromcode: ?*u8
) -> iconv_t #foreign #link="SDL_iconv_open";

iconv_close :: fn(
	cd: iconv_t
) -> i32 #foreign #link="SDL_iconv_close";

iconv :: fn(
	cd: iconv_t,
	inbuf: ?*?*u8,
	inbytesleft: ?*uint,
	outbuf: ?*?*u8,
	outbytesleft: ?*uint
) -> uint #foreign #link="SDL_iconv";

iconv_string :: fn(
	tocode: ?*u8,
	fromcode: ?*u8,
	inbuf: ?*u8,
	inbytesleft: uint
) -> ?*u8 #foreign #link="SDL_iconv_string";

size_mul_check_overflow :: fn(
	a: uint,
	b: uint,
	ret: ?*uint
) -> bool #foreign #link="SDL_size_mul_check_overflow";

size_mul_check_overflow_builtin :: fn(
	a: uint,
	b: uint,
	ret: ?*uint
) -> bool #foreign #link="SDL_size_mul_check_overflow_builtin";

size_add_check_overflow :: fn(
	a: uint,
	b: uint,
	ret: ?*uint
) -> bool #foreign #link="SDL_size_add_check_overflow";

size_add_check_overflow_builtin :: fn(
	a: uint,
	b: uint,
	ret: ?*uint
) -> bool #foreign #link="SDL_size_add_check_overflow_builtin";

FunctionPointer :: ?*fn() #foreign;

enum AssertState: u32 {
	ASSERTION_RETRY = 0x0,
	ASSERTION_BREAK = 0x1,
	ASSERTION_ABORT = 0x2,
	ASSERTION_IGNORE = 0x3,
	ASSERTION_ALWAYS_IGNORE = 0x4,
}

struct AssertData {
	always_ignore: bool,
	trigger_count: u32,
	condition: ?*u8,
	filename: ?*u8,
	linenum: i32,
	function: ?*u8,
	next: ?*AssertData,
}

ReportAssertion :: fn(
	data: ?*AssertData,
	func: ?*u8,
	file: ?*u8,
	line: i32
) -> AssertState #foreign #link="SDL_ReportAssertion";

AssertionHandler :: ?*fn(a: ?*AssertData, b: ?*) -> AssertState #foreign;

SetAssertionHandler :: fn(
	handler: AssertionHandler,
	userdata: ?*
) #foreign #link="SDL_SetAssertionHandler";

GetDefaultAssertionHandler :: fn() -> AssertionHandler #foreign #link="SDL_GetDefaultAssertionHandler";

GetAssertionHandler :: fn(
	puserdata: ?*?*
) -> AssertionHandler #foreign #link="SDL_GetAssertionHandler";

GetAssertionReport :: fn() -> ?*AssertData #foreign #link="SDL_GetAssertionReport";

ResetAssertionReport :: fn() #foreign #link="SDL_ResetAssertionReport";

struct AsyncIO {
}

enum AsyncIOTaskType: u32 {
	ASYNCIO_TASK_READ = 0x0,
	ASYNCIO_TASK_WRITE = 0x1,
	ASYNCIO_TASK_CLOSE = 0x2,
}

enum AsyncIOResult: u32 {
	ASYNCIO_COMPLETE = 0x0,
	ASYNCIO_FAILURE = 0x1,
	ASYNCIO_CANCELED = 0x2,
}

struct AsyncIOOutcome {
	asyncio: ?*AsyncIO,
	type: AsyncIOTaskType,
	result: AsyncIOResult,
	buffer: ?*,
	offset: Uint64,
	bytes_requested: Uint64,
	bytes_transferred: Uint64,
	userdata: ?*,
}

struct AsyncIOQueue {
}

AsyncIOFromFile :: fn(
	file: ?*u8,
	mode: ?*u8
) -> ?*AsyncIO #foreign #link="SDL_AsyncIOFromFile";

GetAsyncIOSize :: fn(
	asyncio: ?*AsyncIO
) -> Sint64 #foreign #link="SDL_GetAsyncIOSize";

ReadAsyncIO :: fn(
	asyncio: ?*AsyncIO,
	ptr: ?*,
	offset: Uint64,
	size: Uint64,
	queue: ?*AsyncIOQueue,
	userdata: ?*
) -> bool #foreign #link="SDL_ReadAsyncIO";

WriteAsyncIO :: fn(
	asyncio: ?*AsyncIO,
	ptr: ?*,
	offset: Uint64,
	size: Uint64,
	queue: ?*AsyncIOQueue,
	userdata: ?*
) -> bool #foreign #link="SDL_WriteAsyncIO";

CloseAsyncIO :: fn(
	asyncio: ?*AsyncIO,
	flush: bool,
	queue: ?*AsyncIOQueue,
	userdata: ?*
) -> bool #foreign #link="SDL_CloseAsyncIO";

CreateAsyncIOQueue :: fn() -> ?*AsyncIOQueue #foreign #link="SDL_CreateAsyncIOQueue";

DestroyAsyncIOQueue :: fn(
	queue: ?*AsyncIOQueue
) #foreign #link="SDL_DestroyAsyncIOQueue";

GetAsyncIOResult :: fn(
	queue: ?*AsyncIOQueue,
	outcome: ?*AsyncIOOutcome
) -> bool #foreign #link="SDL_GetAsyncIOResult";

WaitAsyncIOResult :: fn(
	queue: ?*AsyncIOQueue,
	outcome: ?*AsyncIOOutcome,
	timeoutMS: Sint32
) -> bool #foreign #link="SDL_WaitAsyncIOResult";

SignalAsyncIOQueue :: fn(
	queue: ?*AsyncIOQueue
) #foreign #link="SDL_SignalAsyncIOQueue";

LoadFileAsync :: fn(
	file: ?*u8,
	queue: ?*AsyncIOQueue,
	userdata: ?*
) -> bool #foreign #link="SDL_LoadFileAsync";

SpinLock :: i32;

TryLockSpinlock :: fn(
	lock: ?*SpinLock
) -> bool #foreign #link="SDL_TryLockSpinlock";

LockSpinlock :: fn(
	lock: ?*SpinLock
) #foreign #link="SDL_LockSpinlock";

UnlockSpinlock :: fn(
	lock: ?*SpinLock
) #foreign #link="SDL_UnlockSpinlock";

MemoryBarrierReleaseFunction :: fn() #foreign #link="SDL_MemoryBarrierReleaseFunction";

MemoryBarrierAcquireFunction :: fn() #foreign #link="SDL_MemoryBarrierAcquireFunction";

struct AtomicInt {
	value: i32,
}

CompareAndSwapAtomicInt :: fn(
	a: ?*AtomicInt,
	oldval: i32,
	newval: i32
) -> bool #foreign #link="SDL_CompareAndSwapAtomicInt";

SetAtomicInt :: fn(
	a: ?*AtomicInt,
	v: i32
) -> i32 #foreign #link="SDL_SetAtomicInt";

GetAtomicInt :: fn(
	a: ?*AtomicInt
) -> i32 #foreign #link="SDL_GetAtomicInt";

AddAtomicInt :: fn(
	a: ?*AtomicInt,
	v: i32
) -> i32 #foreign #link="SDL_AddAtomicInt";

struct AtomicU32 {
	value: Uint32,
}

CompareAndSwapAtomicU32 :: fn(
	a: ?*AtomicU32,
	oldval: Uint32,
	newval: Uint32
) -> bool #foreign #link="SDL_CompareAndSwapAtomicU32";

SetAtomicU32 :: fn(
	a: ?*AtomicU32,
	v: Uint32
) -> Uint32 #foreign #link="SDL_SetAtomicU32";

GetAtomicU32 :: fn(
	a: ?*AtomicU32
) -> Uint32 #foreign #link="SDL_GetAtomicU32";

CompareAndSwapAtomicPointer :: fn(
	a: ?*?*,
	oldval: ?*,
	newval: ?*
) -> bool #foreign #link="SDL_CompareAndSwapAtomicPointer";

SetAtomicPointer :: fn(
	a: ?*?*,
	v: ?*
) -> ?* #foreign #link="SDL_SetAtomicPointer";

GetAtomicPointer :: fn(
	a: ?*?*
) -> ?* #foreign #link="SDL_GetAtomicPointer";

_m_prefetch :: fn(
	__P: ?*
) #foreign #link="_m_prefetch";

SwapFloat :: fn(
	x: f32
) -> f32 #foreign #link="SDL_SwapFloat";

SetError :: fn(
	fmt: ?*u8
) -> bool #foreign #link="SDL_SetError";

OutOfMemory :: fn() -> bool #foreign #link="SDL_OutOfMemory";

GetError :: fn() -> ?*u8 #foreign #link="SDL_GetError";

ClearError :: fn() -> bool #foreign #link="SDL_ClearError";

PropertiesID :: Uint32;

enum PropertyType: u32 {
	PROPERTY_TYPE_INVALID = 0x0,
	PROPERTY_TYPE_POINTER = 0x1,
	PROPERTY_TYPE_STRING = 0x2,
	PROPERTY_TYPE_NUMBER = 0x3,
	PROPERTY_TYPE_FLOAT = 0x4,
	PROPERTY_TYPE_BOOLEAN = 0x5,
}

GetGlobalProperties :: fn() -> PropertiesID #foreign #link="SDL_GetGlobalProperties";

CreateProperties :: fn() -> PropertiesID #foreign #link="SDL_CreateProperties";

CopyProperties :: fn(
	src: PropertiesID,
	dst: PropertiesID
) -> bool #foreign #link="SDL_CopyProperties";

LockProperties :: fn(
	props: PropertiesID
) -> bool #foreign #link="SDL_LockProperties";

UnlockProperties :: fn(
	props: PropertiesID
) #foreign #link="SDL_UnlockProperties";

CleanupPropertyCallback :: ?*fn(a: ?*, b: ?*) #foreign;

SetPointerPropertyWithCleanup :: fn(
	props: PropertiesID,
	name: ?*u8,
	value: ?*,
	cleanup: CleanupPropertyCallback,
	userdata: ?*
) -> bool #foreign #link="SDL_SetPointerPropertyWithCleanup";

SetPointerProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	value: ?*
) -> bool #foreign #link="SDL_SetPointerProperty";

SetStringProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	value: ?*u8
) -> bool #foreign #link="SDL_SetStringProperty";

SetNumberProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	value: Sint64
) -> bool #foreign #link="SDL_SetNumberProperty";

SetFloatProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	value: f32
) -> bool #foreign #link="SDL_SetFloatProperty";

SetBooleanProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	value: bool
) -> bool #foreign #link="SDL_SetBooleanProperty";

HasProperty :: fn(
	props: PropertiesID,
	name: ?*u8
) -> bool #foreign #link="SDL_HasProperty";

GetPropertyType :: fn(
	props: PropertiesID,
	name: ?*u8
) -> PropertyType #foreign #link="SDL_GetPropertyType";

GetPointerProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	default_value: ?*
) -> ?* #foreign #link="SDL_GetPointerProperty";

GetStringProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	default_value: ?*u8
) -> ?*u8 #foreign #link="SDL_GetStringProperty";

GetNumberProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	default_value: Sint64
) -> Sint64 #foreign #link="SDL_GetNumberProperty";

GetFloatProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	default_value: f32
) -> f32 #foreign #link="SDL_GetFloatProperty";

GetBooleanProperty :: fn(
	props: PropertiesID,
	name: ?*u8,
	default_value: bool
) -> bool #foreign #link="SDL_GetBooleanProperty";

ClearProperty :: fn(
	props: PropertiesID,
	name: ?*u8
) -> bool #foreign #link="SDL_ClearProperty";

EnumeratePropertiesCallback :: ?*fn(a: ?*, b: PropertiesID, c: ?*u8) #foreign;

EnumerateProperties :: fn(
	props: PropertiesID,
	callback: EnumeratePropertiesCallback,
	userdata: ?*
) -> bool #foreign #link="SDL_EnumerateProperties";

DestroyProperties :: fn(
	props: PropertiesID
) #foreign #link="SDL_DestroyProperties";

struct Thread {
}

ThreadID :: Uint64;

TLSID :: AtomicInt;

enum ThreadPriority: u32 {
	THREAD_PRIORITY_LOW = 0x0,
	THREAD_PRIORITY_NORMAL = 0x1,
	THREAD_PRIORITY_HIGH = 0x2,
	THREAD_PRIORITY_TIME_CRITICAL = 0x3,
}

enum ThreadState: u32 {
	THREAD_UNKNOWN = 0x0,
	THREAD_ALIVE = 0x1,
	THREAD_DETACHED = 0x2,
	THREAD_COMPLETE = 0x3,
}

ThreadFunction :: ?*fn(a: ?*) -> i32 #foreign;

CreateThreadRuntime :: fn(
	fn_: ThreadFunction,
	name: ?*u8,
	data: ?*,
	pfnBeginThread: FunctionPointer,
	pfnEndThread: FunctionPointer
) -> ?*Thread #foreign #link="SDL_CreateThreadRuntime";

CreateThreadWithPropertiesRuntime :: fn(
	props: PropertiesID,
	pfnBeginThread: FunctionPointer,
	pfnEndThread: FunctionPointer
) -> ?*Thread #foreign #link="SDL_CreateThreadWithPropertiesRuntime";

GetThreadName :: fn(
	thread: ?*Thread
) -> ?*u8 #foreign #link="SDL_GetThreadName";

GetCurrentThreadID :: fn() -> ThreadID #foreign #link="SDL_GetCurrentThreadID";

GetThreadID :: fn(
	thread: ?*Thread
) -> ThreadID #foreign #link="SDL_GetThreadID";

SetCurrentThreadPriority :: fn(
	priority: ThreadPriority
) -> bool #foreign #link="SDL_SetCurrentThreadPriority";

WaitThread :: fn(
	thread: ?*Thread,
	status: ?*i32
) #foreign #link="SDL_WaitThread";

GetThreadState :: fn(
	thread: ?*Thread
) -> ThreadState #foreign #link="SDL_GetThreadState";

DetachThread :: fn(
	thread: ?*Thread
) #foreign #link="SDL_DetachThread";

GetTLS :: fn(
	id: ?*TLSID
) -> ?* #foreign #link="SDL_GetTLS";

TLSDestructorCallback :: ?*fn(a: ?*) #foreign;

SetTLS :: fn(
	id: ?*TLSID,
	value: ?*,
	destructor: TLSDestructorCallback
) -> bool #foreign #link="SDL_SetTLS";

CleanupTLS :: fn() #foreign #link="SDL_CleanupTLS";

struct Mutex {
}

CreateMutex :: fn() -> ?*Mutex #foreign #link="SDL_CreateMutex";

LockMutex :: fn(
	mutex: ?*Mutex
) #foreign #link="SDL_LockMutex";

TryLockMutex :: fn(
	mutex: ?*Mutex
) -> bool #foreign #link="SDL_TryLockMutex";

UnlockMutex :: fn(
	mutex: ?*Mutex
) #foreign #link="SDL_UnlockMutex";

DestroyMutex :: fn(
	mutex: ?*Mutex
) #foreign #link="SDL_DestroyMutex";

struct RWLock {
}

CreateRWLock :: fn() -> ?*RWLock #foreign #link="SDL_CreateRWLock";

LockRWLockForReading :: fn(
	rwlock: ?*RWLock
) #foreign #link="SDL_LockRWLockForReading";

LockRWLockForWriting :: fn(
	rwlock: ?*RWLock
) #foreign #link="SDL_LockRWLockForWriting";

TryLockRWLockForReading :: fn(
	rwlock: ?*RWLock
) -> bool #foreign #link="SDL_TryLockRWLockForReading";

TryLockRWLockForWriting :: fn(
	rwlock: ?*RWLock
) -> bool #foreign #link="SDL_TryLockRWLockForWriting";

UnlockRWLock :: fn(
	rwlock: ?*RWLock
) #foreign #link="SDL_UnlockRWLock";

DestroyRWLock :: fn(
	rwlock: ?*RWLock
) #foreign #link="SDL_DestroyRWLock";

struct Semaphore {
}

CreateSemaphore :: fn(
	initial_value: Uint32
) -> ?*Semaphore #foreign #link="SDL_CreateSemaphore";

DestroySemaphore :: fn(
	sem: ?*Semaphore
) #foreign #link="SDL_DestroySemaphore";

WaitSemaphore :: fn(
	sem: ?*Semaphore
) #foreign #link="SDL_WaitSemaphore";

TryWaitSemaphore :: fn(
	sem: ?*Semaphore
) -> bool #foreign #link="SDL_TryWaitSemaphore";

WaitSemaphoreTimeout :: fn(
	sem: ?*Semaphore,
	timeoutMS: Sint32
) -> bool #foreign #link="SDL_WaitSemaphoreTimeout";

SignalSemaphore :: fn(
	sem: ?*Semaphore
) #foreign #link="SDL_SignalSemaphore";

GetSemaphoreValue :: fn(
	sem: ?*Semaphore
) -> Uint32 #foreign #link="SDL_GetSemaphoreValue";

struct Condition {
}

CreateCondition :: fn() -> ?*Condition #foreign #link="SDL_CreateCondition";

DestroyCondition :: fn(
	cond: ?*Condition
) #foreign #link="SDL_DestroyCondition";

SignalCondition :: fn(
	cond: ?*Condition
) #foreign #link="SDL_SignalCondition";

BroadcastCondition :: fn(
	cond: ?*Condition
) #foreign #link="SDL_BroadcastCondition";

WaitCondition :: fn(
	cond: ?*Condition,
	mutex: ?*Mutex
) #foreign #link="SDL_WaitCondition";

WaitConditionTimeout :: fn(
	cond: ?*Condition,
	mutex: ?*Mutex,
	timeoutMS: Sint32
) -> bool #foreign #link="SDL_WaitConditionTimeout";

enum InitStatus: u32 {
	INIT_STATUS_UNINITIALIZED = 0x0,
	INIT_STATUS_INITIALIZING = 0x1,
	INIT_STATUS_INITIALIZED = 0x2,
	INIT_STATUS_UNINITIALIZING = 0x3,
}

struct InitState {
	status: AtomicInt,
	thread: ThreadID,
	reserved: ?*,
}

ShouldInit :: fn(
	state: ?*InitState
) -> bool #foreign #link="SDL_ShouldInit";

ShouldQuit :: fn(
	state: ?*InitState
) -> bool #foreign #link="SDL_ShouldQuit";

SetInitialized :: fn(
	state: ?*InitState,
	initialized: bool
) #foreign #link="SDL_SetInitialized";

enum IOStatus: u32 {
	IO_STATUS_READY = 0x0,
	IO_STATUS_ERROR = 0x1,
	IO_STATUS_EOF = 0x2,
	IO_STATUS_NOT_READY = 0x3,
	IO_STATUS_READONLY = 0x4,
	IO_STATUS_WRITEONLY = 0x5,
}

enum IOWhence: u32 {
	IO_SEEK_SET = 0x0,
	IO_SEEK_CUR = 0x1,
	IO_SEEK_END = 0x2,
}

struct IOStreamInterface {
	version: Uint32,
	size: ?*fn(a: ?*) -> Sint64 #foreign,
	seek: ?*fn(a: ?*, b: Sint64, c: IOWhence) -> Sint64 #foreign,
	read: ?*fn(a: ?*, b: ?*, c: uint, d: ?*IOStatus) -> uint #foreign,
	write: ?*fn(a: ?*, b: ?*, c: uint, d: ?*IOStatus) -> uint #foreign,
	flush: ?*fn(a: ?*, b: ?*IOStatus) -> bool #foreign,
	close: ?*fn(a: ?*) -> bool #foreign,
}

struct IOStream {
}

IOFromFile :: fn(
	file: ?*u8,
	mode: ?*u8
) -> ?*IOStream #foreign #link="SDL_IOFromFile";

IOFromMem :: fn(
	mem: ?*,
	size: uint
) -> ?*IOStream #foreign #link="SDL_IOFromMem";

IOFromConstMem :: fn(
	mem: ?*,
	size: uint
) -> ?*IOStream #foreign #link="SDL_IOFromConstMem";

IOFromDynamicMem :: fn() -> ?*IOStream #foreign #link="SDL_IOFromDynamicMem";

OpenIO :: fn(
	iface: ?*IOStreamInterface,
	userdata: ?*
) -> ?*IOStream #foreign #link="SDL_OpenIO";

CloseIO :: fn(
	context: ?*IOStream
) -> bool #foreign #link="SDL_CloseIO";

GetIOProperties :: fn(
	context: ?*IOStream
) -> PropertiesID #foreign #link="SDL_GetIOProperties";

GetIOStatus :: fn(
	context: ?*IOStream
) -> IOStatus #foreign #link="SDL_GetIOStatus";

GetIOSize :: fn(
	context: ?*IOStream
) -> Sint64 #foreign #link="SDL_GetIOSize";

SeekIO :: fn(
	context: ?*IOStream,
	offset: Sint64,
	whence: IOWhence
) -> Sint64 #foreign #link="SDL_SeekIO";

TellIO :: fn(
	context: ?*IOStream
) -> Sint64 #foreign #link="SDL_TellIO";

ReadIO :: fn(
	context: ?*IOStream,
	ptr: ?*,
	size: uint
) -> uint #foreign #link="SDL_ReadIO";

WriteIO :: fn(
	context: ?*IOStream,
	ptr: ?*,
	size: uint
) -> uint #foreign #link="SDL_WriteIO";

IOprintf :: fn(
	context: ?*IOStream,
	fmt: ?*u8
) -> uint #foreign #link="SDL_IOprintf";

FlushIO :: fn(
	context: ?*IOStream
) -> bool #foreign #link="SDL_FlushIO";

LoadFile_IO :: fn(
	src: ?*IOStream,
	datasize: ?*uint,
	closeio: bool
) -> ?* #foreign #link="SDL_LoadFile_IO";

LoadFile :: fn(
	file: ?*u8,
	datasize: ?*uint
) -> ?* #foreign #link="SDL_LoadFile";

SaveFile_IO :: fn(
	src: ?*IOStream,
	data: ?*,
	datasize: uint,
	closeio: bool
) -> bool #foreign #link="SDL_SaveFile_IO";

SaveFile :: fn(
	file: ?*u8,
	data: ?*,
	datasize: uint
) -> bool #foreign #link="SDL_SaveFile";

ReadU8 :: fn(
	src: ?*IOStream,
	value: ?*Uint8
) -> bool #foreign #link="SDL_ReadU8";

ReadS8 :: fn(
	src: ?*IOStream,
	value: ?*Sint8
) -> bool #foreign #link="SDL_ReadS8";

ReadU16LE :: fn(
	src: ?*IOStream,
	value: ?*Uint16
) -> bool #foreign #link="SDL_ReadU16LE";

ReadS16LE :: fn(
	src: ?*IOStream,
	value: ?*Sint16
) -> bool #foreign #link="SDL_ReadS16LE";

ReadU16BE :: fn(
	src: ?*IOStream,
	value: ?*Uint16
) -> bool #foreign #link="SDL_ReadU16BE";

ReadS16BE :: fn(
	src: ?*IOStream,
	value: ?*Sint16
) -> bool #foreign #link="SDL_ReadS16BE";

ReadU32LE :: fn(
	src: ?*IOStream,
	value: ?*Uint32
) -> bool #foreign #link="SDL_ReadU32LE";

ReadS32LE :: fn(
	src: ?*IOStream,
	value: ?*Sint32
) -> bool #foreign #link="SDL_ReadS32LE";

ReadU32BE :: fn(
	src: ?*IOStream,
	value: ?*Uint32
) -> bool #foreign #link="SDL_ReadU32BE";

ReadS32BE :: fn(
	src: ?*IOStream,
	value: ?*Sint32
) -> bool #foreign #link="SDL_ReadS32BE";

ReadU64LE :: fn(
	src: ?*IOStream,
	value: ?*Uint64
) -> bool #foreign #link="SDL_ReadU64LE";

ReadS64LE :: fn(
	src: ?*IOStream,
	value: ?*Sint64
) -> bool #foreign #link="SDL_ReadS64LE";

ReadU64BE :: fn(
	src: ?*IOStream,
	value: ?*Uint64
) -> bool #foreign #link="SDL_ReadU64BE";

ReadS64BE :: fn(
	src: ?*IOStream,
	value: ?*Sint64
) -> bool #foreign #link="SDL_ReadS64BE";

WriteU8 :: fn(
	dst: ?*IOStream,
	value: Uint8
) -> bool #foreign #link="SDL_WriteU8";

WriteS8 :: fn(
	dst: ?*IOStream,
	value: Sint8
) -> bool #foreign #link="SDL_WriteS8";

WriteU16LE :: fn(
	dst: ?*IOStream,
	value: Uint16
) -> bool #foreign #link="SDL_WriteU16LE";

WriteS16LE :: fn(
	dst: ?*IOStream,
	value: Sint16
) -> bool #foreign #link="SDL_WriteS16LE";

WriteU16BE :: fn(
	dst: ?*IOStream,
	value: Uint16
) -> bool #foreign #link="SDL_WriteU16BE";

WriteS16BE :: fn(
	dst: ?*IOStream,
	value: Sint16
) -> bool #foreign #link="SDL_WriteS16BE";

WriteU32LE :: fn(
	dst: ?*IOStream,
	value: Uint32
) -> bool #foreign #link="SDL_WriteU32LE";

WriteS32LE :: fn(
	dst: ?*IOStream,
	value: Sint32
) -> bool #foreign #link="SDL_WriteS32LE";

WriteU32BE :: fn(
	dst: ?*IOStream,
	value: Uint32
) -> bool #foreign #link="SDL_WriteU32BE";

WriteS32BE :: fn(
	dst: ?*IOStream,
	value: Sint32
) -> bool #foreign #link="SDL_WriteS32BE";

WriteU64LE :: fn(
	dst: ?*IOStream,
	value: Uint64
) -> bool #foreign #link="SDL_WriteU64LE";

WriteS64LE :: fn(
	dst: ?*IOStream,
	value: Sint64
) -> bool #foreign #link="SDL_WriteS64LE";

WriteU64BE :: fn(
	dst: ?*IOStream,
	value: Uint64
) -> bool #foreign #link="SDL_WriteU64BE";

WriteS64BE :: fn(
	dst: ?*IOStream,
	value: Sint64
) -> bool #foreign #link="SDL_WriteS64BE";

enum AudioFormat: u32 {
	AUDIO_UNKNOWN = 0x0,
	AUDIO_U8 = 0x8,
	AUDIO_S8 = 0x8008,
	AUDIO_S16LE = 0x8010,
	AUDIO_S16BE = 0x9010,
	AUDIO_S32LE = 0x8020,
	AUDIO_S32BE = 0x9020,
	AUDIO_F32LE = 0x8120,
	AUDIO_F32BE = 0x9120,
	AUDIO_S16 = 0x8010,
	AUDIO_S32 = 0x8020,
	AUDIO_F32 = 0x8120,
}

AudioDeviceID :: Uint32;

struct AudioSpec {
	format: AudioFormat,
	channels: i32,
	freq: i32,
}

struct AudioStream {
}

GetNumAudioDrivers :: fn() -> i32 #foreign #link="SDL_GetNumAudioDrivers";

GetAudioDriver :: fn(
	index: i32
) -> ?*u8 #foreign #link="SDL_GetAudioDriver";

GetCurrentAudioDriver :: fn() -> ?*u8 #foreign #link="SDL_GetCurrentAudioDriver";

GetAudioPlaybackDevices :: fn(
	count: ?*i32
) -> ?*AudioDeviceID #foreign #link="SDL_GetAudioPlaybackDevices";

GetAudioRecordingDevices :: fn(
	count: ?*i32
) -> ?*AudioDeviceID #foreign #link="SDL_GetAudioRecordingDevices";

GetAudioDeviceName :: fn(
	devid: AudioDeviceID
) -> ?*u8 #foreign #link="SDL_GetAudioDeviceName";

GetAudioDeviceFormat :: fn(
	devid: AudioDeviceID,
	spec: ?*AudioSpec,
	sample_frames: ?*i32
) -> bool #foreign #link="SDL_GetAudioDeviceFormat";

GetAudioDeviceChannelMap :: fn(
	devid: AudioDeviceID,
	count: ?*i32
) -> ?*i32 #foreign #link="SDL_GetAudioDeviceChannelMap";

OpenAudioDevice :: fn(
	devid: AudioDeviceID,
	spec: ?*AudioSpec
) -> AudioDeviceID #foreign #link="SDL_OpenAudioDevice";

IsAudioDevicePhysical :: fn(
	devid: AudioDeviceID
) -> bool #foreign #link="SDL_IsAudioDevicePhysical";

IsAudioDevicePlayback :: fn(
	devid: AudioDeviceID
) -> bool #foreign #link="SDL_IsAudioDevicePlayback";

PauseAudioDevice :: fn(
	devid: AudioDeviceID
) -> bool #foreign #link="SDL_PauseAudioDevice";

ResumeAudioDevice :: fn(
	devid: AudioDeviceID
) -> bool #foreign #link="SDL_ResumeAudioDevice";

AudioDevicePaused :: fn(
	devid: AudioDeviceID
) -> bool #foreign #link="SDL_AudioDevicePaused";

GetAudioDeviceGain :: fn(
	devid: AudioDeviceID
) -> f32 #foreign #link="SDL_GetAudioDeviceGain";

SetAudioDeviceGain :: fn(
	devid: AudioDeviceID,
	gain: f32
) -> bool #foreign #link="SDL_SetAudioDeviceGain";

CloseAudioDevice :: fn(
	devid: AudioDeviceID
) #foreign #link="SDL_CloseAudioDevice";

BindAudioStreams :: fn(
	devid: AudioDeviceID,
	streams: ?*?*AudioStream,
	num_streams: i32
) -> bool #foreign #link="SDL_BindAudioStreams";

BindAudioStream :: fn(
	devid: AudioDeviceID,
	stream: ?*AudioStream
) -> bool #foreign #link="SDL_BindAudioStream";

UnbindAudioStreams :: fn(
	streams: ?*?*AudioStream,
	num_streams: i32
) #foreign #link="SDL_UnbindAudioStreams";

UnbindAudioStream :: fn(
	stream: ?*AudioStream
) #foreign #link="SDL_UnbindAudioStream";

GetAudioStreamDevice :: fn(
	stream: ?*AudioStream
) -> AudioDeviceID #foreign #link="SDL_GetAudioStreamDevice";

CreateAudioStream :: fn(
	src_spec: ?*AudioSpec,
	dst_spec: ?*AudioSpec
) -> ?*AudioStream #foreign #link="SDL_CreateAudioStream";

GetAudioStreamProperties :: fn(
	stream: ?*AudioStream
) -> PropertiesID #foreign #link="SDL_GetAudioStreamProperties";

GetAudioStreamFormat :: fn(
	stream: ?*AudioStream,
	src_spec: ?*AudioSpec,
	dst_spec: ?*AudioSpec
) -> bool #foreign #link="SDL_GetAudioStreamFormat";

SetAudioStreamFormat :: fn(
	stream: ?*AudioStream,
	src_spec: ?*AudioSpec,
	dst_spec: ?*AudioSpec
) -> bool #foreign #link="SDL_SetAudioStreamFormat";

GetAudioStreamFrequencyRatio :: fn(
	stream: ?*AudioStream
) -> f32 #foreign #link="SDL_GetAudioStreamFrequencyRatio";

SetAudioStreamFrequencyRatio :: fn(
	stream: ?*AudioStream,
	ratio: f32
) -> bool #foreign #link="SDL_SetAudioStreamFrequencyRatio";

GetAudioStreamGain :: fn(
	stream: ?*AudioStream
) -> f32 #foreign #link="SDL_GetAudioStreamGain";

SetAudioStreamGain :: fn(
	stream: ?*AudioStream,
	gain: f32
) -> bool #foreign #link="SDL_SetAudioStreamGain";

GetAudioStreamInputChannelMap :: fn(
	stream: ?*AudioStream,
	count: ?*i32
) -> ?*i32 #foreign #link="SDL_GetAudioStreamInputChannelMap";

GetAudioStreamOutputChannelMap :: fn(
	stream: ?*AudioStream,
	count: ?*i32
) -> ?*i32 #foreign #link="SDL_GetAudioStreamOutputChannelMap";

SetAudioStreamInputChannelMap :: fn(
	stream: ?*AudioStream,
	chmap: ?*i32,
	count: i32
) -> bool #foreign #link="SDL_SetAudioStreamInputChannelMap";

SetAudioStreamOutputChannelMap :: fn(
	stream: ?*AudioStream,
	chmap: ?*i32,
	count: i32
) -> bool #foreign #link="SDL_SetAudioStreamOutputChannelMap";

PutAudioStreamData :: fn(
	stream: ?*AudioStream,
	buf: ?*,
	len: i32
) -> bool #foreign #link="SDL_PutAudioStreamData";

GetAudioStreamData :: fn(
	stream: ?*AudioStream,
	buf: ?*,
	len: i32
) -> i32 #foreign #link="SDL_GetAudioStreamData";

GetAudioStreamAvailable :: fn(
	stream: ?*AudioStream
) -> i32 #foreign #link="SDL_GetAudioStreamAvailable";

GetAudioStreamQueued :: fn(
	stream: ?*AudioStream
) -> i32 #foreign #link="SDL_GetAudioStreamQueued";

FlushAudioStream :: fn(
	stream: ?*AudioStream
) -> bool #foreign #link="SDL_FlushAudioStream";

ClearAudioStream :: fn(
	stream: ?*AudioStream
) -> bool #foreign #link="SDL_ClearAudioStream";

PauseAudioStreamDevice :: fn(
	stream: ?*AudioStream
) -> bool #foreign #link="SDL_PauseAudioStreamDevice";

ResumeAudioStreamDevice :: fn(
	stream: ?*AudioStream
) -> bool #foreign #link="SDL_ResumeAudioStreamDevice";

AudioStreamDevicePaused :: fn(
	stream: ?*AudioStream
) -> bool #foreign #link="SDL_AudioStreamDevicePaused";

LockAudioStream :: fn(
	stream: ?*AudioStream
) -> bool #foreign #link="SDL_LockAudioStream";

UnlockAudioStream :: fn(
	stream: ?*AudioStream
) -> bool #foreign #link="SDL_UnlockAudioStream";

AudioStreamCallback :: ?*fn(a: ?*, b: ?*AudioStream, c: i32, d: i32) #foreign;

SetAudioStreamGetCallback :: fn(
	stream: ?*AudioStream,
	callback: AudioStreamCallback,
	userdata: ?*
) -> bool #foreign #link="SDL_SetAudioStreamGetCallback";

SetAudioStreamPutCallback :: fn(
	stream: ?*AudioStream,
	callback: AudioStreamCallback,
	userdata: ?*
) -> bool #foreign #link="SDL_SetAudioStreamPutCallback";

DestroyAudioStream :: fn(
	stream: ?*AudioStream
) #foreign #link="SDL_DestroyAudioStream";

OpenAudioDeviceStream :: fn(
	devid: AudioDeviceID,
	spec: ?*AudioSpec,
	callback: AudioStreamCallback,
	userdata: ?*
) -> ?*AudioStream #foreign #link="SDL_OpenAudioDeviceStream";

AudioPostmixCallback :: ?*fn(a: ?*, b: ?*AudioSpec, c: ?*f32, d: i32) #foreign;

SetAudioPostmixCallback :: fn(
	devid: AudioDeviceID,
	callback: AudioPostmixCallback,
	userdata: ?*
) -> bool #foreign #link="SDL_SetAudioPostmixCallback";

LoadWAV_IO :: fn(
	src: ?*IOStream,
	closeio: bool,
	spec: ?*AudioSpec,
	audio_buf: ?*?*Uint8,
	audio_len: ?*Uint32
) -> bool #foreign #link="SDL_LoadWAV_IO";

LoadWAV :: fn(
	path: ?*u8,
	spec: ?*AudioSpec,
	audio_buf: ?*?*Uint8,
	audio_len: ?*Uint32
) -> bool #foreign #link="SDL_LoadWAV";

MixAudio :: fn(
	dst: ?*Uint8,
	src: ?*Uint8,
	format: AudioFormat,
	len: Uint32,
	volume: f32
) -> bool #foreign #link="SDL_MixAudio";

ConvertAudioSamples :: fn(
	src_spec: ?*AudioSpec,
	src_data: ?*Uint8,
	src_len: i32,
	dst_spec: ?*AudioSpec,
	dst_data: ?*?*Uint8,
	dst_len: ?*i32
) -> bool #foreign #link="SDL_ConvertAudioSamples";

GetAudioFormatName :: fn(
	format: AudioFormat
) -> ?*u8 #foreign #link="SDL_GetAudioFormatName";

GetSilenceValueForFormat :: fn(
	format: AudioFormat
) -> i32 #foreign #link="SDL_GetSilenceValueForFormat";

MostSignificantBitIndex32 :: fn(
	x: Uint32
) -> i32 #foreign #link="SDL_MostSignificantBitIndex32";

HasExactlyOneBitSet32 :: fn(
	x: Uint32
) -> bool #foreign #link="SDL_HasExactlyOneBitSet32";

BlendMode :: Uint32;

enum BlendOperation: u32 {
	ADD = 0x1,
	SUBTRACT = 0x2,
	REV_SUBTRACT = 0x3,
	MINIMUM = 0x4,
	MAXIMUM = 0x5,
}

enum BlendFactor: u32 {
	ZERO = 0x1,
	ONE = 0x2,
	SRC_COLOR = 0x3,
	ONE_MINUS_SRC_COLOR = 0x4,
	SRC_ALPHA = 0x5,
	ONE_MINUS_SRC_ALPHA = 0x6,
	DST_COLOR = 0x7,
	ONE_MINUS_DST_COLOR = 0x8,
	DST_ALPHA = 0x9,
	ONE_MINUS_DST_ALPHA = 0xa,
}

ComposeCustomBlendMode :: fn(
	srcColorFactor: BlendFactor,
	dstColorFactor: BlendFactor,
	colorOperation: BlendOperation,
	srcAlphaFactor: BlendFactor,
	dstAlphaFactor: BlendFactor,
	alphaOperation: BlendOperation
) -> BlendMode #foreign #link="SDL_ComposeCustomBlendMode";

enum PixelType: u32 {
	UNKNOWN = 0x0,
	INDEX1 = 0x1,
	INDEX4 = 0x2,
	INDEX8 = 0x3,
	PACKED8 = 0x4,
	PACKED16 = 0x5,
	PACKED32 = 0x6,
	ARRAYU8 = 0x7,
	ARRAYU16 = 0x8,
	ARRAYU32 = 0x9,
	ARRAYF16 = 0xa,
	ARRAYF32 = 0xb,
	INDEX2 = 0xc,
}

enum BitmapOrder: u32 {
	NONE = 0x0,
	_4321 = 0x1,
	_1234 = 0x2,
}

enum PackedOrder: u32 {
	NONE = 0x0,
	XRGB = 0x1,
	RGBX = 0x2,
	ARGB = 0x3,
	RGBA = 0x4,
	XBGR = 0x5,
	BGRX = 0x6,
	ABGR = 0x7,
	BGRA = 0x8,
}

enum ArrayOrder: u32 {
	NONE = 0x0,
	RGB = 0x1,
	RGBA = 0x2,
	ARGB = 0x3,
	BGR = 0x4,
	BGRA = 0x5,
	ABGR = 0x6,
}

enum PackedLayout: u32 {
	NONE = 0x0,
	_332 = 0x1,
	_4444 = 0x2,
	_1555 = 0x3,
	_5551 = 0x4,
	_565 = 0x5,
	_8888 = 0x6,
	_2101010 = 0x7,
	_1010102 = 0x8,
}

enum PixelFormat: u32 {
	UNKNOWN = 0x0,
	INDEX1LSB = 0x11100100,
	INDEX1MSB = 0x11200100,
	INDEX2LSB = 0x1c100200,
	INDEX2MSB = 0x1c200200,
	INDEX4LSB = 0x12100400,
	INDEX4MSB = 0x12200400,
	INDEX8 = 0x13000801,
	RGB332 = 0x14110801,
	XRGB4444 = 0x15120c02,
	XBGR4444 = 0x15520c02,
	XRGB1555 = 0x15130f02,
	XBGR1555 = 0x15530f02,
	ARGB4444 = 0x15321002,
	RGBA4444 = 0x15421002,
	ABGR4444 = 0x15721002,
	BGRA4444 = 0x15821002,
	ARGB1555 = 0x15331002,
	RGBA5551 = 0x15441002,
	ABGR1555 = 0x15731002,
	BGRA5551 = 0x15841002,
	RGB565 = 0x15151002,
	BGR565 = 0x15551002,
	RGB24 = 0x17101803,
	BGR24 = 0x17401803,
	XRGB8888 = 0x16161804,
	RGBX8888 = 0x16261804,
	XBGR8888 = 0x16561804,
	BGRX8888 = 0x16661804,
	ARGB8888 = 0x16362004,
	RGBA8888 = 0x16462004,
	ABGR8888 = 0x16762004,
	BGRA8888 = 0x16862004,
	XRGB2101010 = 0x16172004,
	XBGR2101010 = 0x16572004,
	ARGB2101010 = 0x16372004,
	ABGR2101010 = 0x16772004,
	RGB48 = 0x18103006,
	BGR48 = 0x18403006,
	RGBA64 = 0x18204008,
	ARGB64 = 0x18304008,
	BGRA64 = 0x18504008,
	ABGR64 = 0x18604008,
	RGB48_FLOAT = 0x1a103006,
	BGR48_FLOAT = 0x1a403006,
	RGBA64_FLOAT = 0x1a204008,
	ARGB64_FLOAT = 0x1a304008,
	BGRA64_FLOAT = 0x1a504008,
	ABGR64_FLOAT = 0x1a604008,
	RGB96_FLOAT = 0x1b10600c,
	BGR96_FLOAT = 0x1b40600c,
	RGBA128_FLOAT = 0x1b208010,
	ARGB128_FLOAT = 0x1b308010,
	BGRA128_FLOAT = 0x1b508010,
	ABGR128_FLOAT = 0x1b608010,
	YV12 = 0x32315659,
	IYUV = 0x56555949,
	YUY2 = 0x32595559,
	UYVY = 0x59565955,
	YVYU = 0x55595659,
	NV12 = 0x3231564e,
	NV21 = 0x3132564e,
	P010 = 0x30313050,
	EXTERNAL_OES = 0x2053454f,
	MJPG = 0x47504a4d,
	RGBA32 = 0x16762004,
	ARGB32 = 0x16862004,
	BGRA32 = 0x16362004,
	ABGR32 = 0x16462004,
	RGBX32 = 0x16561804,
	XRGB32 = 0x16661804,
	BGRX32 = 0x16161804,
	XBGR32 = 0x16261804,
}

enum ColorType: u32 {
	COLOR_TYPE_UNKNOWN = 0x0,
	COLOR_TYPE_RGB = 0x1,
	COLOR_TYPE_YCBCR = 0x2,
}

enum ColorRange: u32 {
	COLOR_RANGE_UNKNOWN = 0x0,
	COLOR_RANGE_LIMITED = 0x1,
	COLOR_RANGE_FULL = 0x2,
}

enum ColorPrimaries: u32 {
	COLOR_PRIMARIES_UNKNOWN = 0x0,
	COLOR_PRIMARIES_BT709 = 0x1,
	COLOR_PRIMARIES_UNSPECIFIED = 0x2,
	COLOR_PRIMARIES_BT470M = 0x4,
	COLOR_PRIMARIES_BT470BG = 0x5,
	COLOR_PRIMARIES_BT601 = 0x6,
	COLOR_PRIMARIES_SMPTE240 = 0x7,
	COLOR_PRIMARIES_GENERIC_FILM = 0x8,
	COLOR_PRIMARIES_BT2020 = 0x9,
	COLOR_PRIMARIES_XYZ = 0xa,
	COLOR_PRIMARIES_SMPTE431 = 0xb,
	COLOR_PRIMARIES_SMPTE432 = 0xc,
	COLOR_PRIMARIES_EBU3213 = 0x16,
	COLOR_PRIMARIES_CUSTOM = 0x1f,
}

enum TransferCharacteristics: u32 {
	TRANSFER_CHARACTERISTICS_UNKNOWN = 0x0,
	TRANSFER_CHARACTERISTICS_BT709 = 0x1,
	TRANSFER_CHARACTERISTICS_UNSPECIFIED = 0x2,
	TRANSFER_CHARACTERISTICS_GAMMA22 = 0x4,
	TRANSFER_CHARACTERISTICS_GAMMA28 = 0x5,
	TRANSFER_CHARACTERISTICS_BT601 = 0x6,
	TRANSFER_CHARACTERISTICS_SMPTE240 = 0x7,
	TRANSFER_CHARACTERISTICS_LINEAR = 0x8,
	TRANSFER_CHARACTERISTICS_LOG100 = 0x9,
	TRANSFER_CHARACTERISTICS_LOG100_SQRT10 = 0xa,
	TRANSFER_CHARACTERISTICS_IEC61966 = 0xb,
	TRANSFER_CHARACTERISTICS_BT1361 = 0xc,
	TRANSFER_CHARACTERISTICS_SRGB = 0xd,
	TRANSFER_CHARACTERISTICS_BT2020_10BIT = 0xe,
	TRANSFER_CHARACTERISTICS_BT2020_12BIT = 0xf,
	TRANSFER_CHARACTERISTICS_PQ = 0x10,
	TRANSFER_CHARACTERISTICS_SMPTE428 = 0x11,
	TRANSFER_CHARACTERISTICS_HLG = 0x12,
	TRANSFER_CHARACTERISTICS_CUSTOM = 0x1f,
}

enum MatrixCoefficients: u32 {
	MATRIX_COEFFICIENTS_IDENTITY = 0x0,
	MATRIX_COEFFICIENTS_BT709 = 0x1,
	MATRIX_COEFFICIENTS_UNSPECIFIED = 0x2,
	MATRIX_COEFFICIENTS_FCC = 0x4,
	MATRIX_COEFFICIENTS_BT470BG = 0x5,
	MATRIX_COEFFICIENTS_BT601 = 0x6,
	MATRIX_COEFFICIENTS_SMPTE240 = 0x7,
	MATRIX_COEFFICIENTS_YCGCO = 0x8,
	MATRIX_COEFFICIENTS_BT2020_NCL = 0x9,
	MATRIX_COEFFICIENTS_BT2020_CL = 0xa,
	MATRIX_COEFFICIENTS_SMPTE2085 = 0xb,
	MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL = 0xc,
	MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL = 0xd,
	MATRIX_COEFFICIENTS_ICTCP = 0xe,
	MATRIX_COEFFICIENTS_CUSTOM = 0x1f,
}

enum ChromaLocation: u32 {
	CHROMA_LOCATION_NONE = 0x0,
	CHROMA_LOCATION_LEFT = 0x1,
	CHROMA_LOCATION_CENTER = 0x2,
	CHROMA_LOCATION_TOPLEFT = 0x3,
}

enum Colorspace: u32 {
	UNKNOWN = 0x0,
	SRGB = 0x120005a0,
	SRGB_LINEAR = 0x12000500,
	HDR10 = 0x12002600,
	JPEG = 0x220004c6,
	BT601_LIMITED = 0x211018c6,
	BT601_FULL = 0x221018c6,
	BT709_LIMITED = 0x21100421,
	BT709_FULL = 0x22100421,
	BT2020_LIMITED = 0x21102609,
	BT2020_FULL = 0x22102609,
	RGB_DEFAULT = 0x120005a0,
	YUV_DEFAULT = 0x220004c6,
}

struct Color {
	r: Uint8,
	g: Uint8,
	b: Uint8,
	a: Uint8,
}

struct FColor {
	r: f32,
	g: f32,
	b: f32,
	a: f32,
}

struct Palette {
	ncolors: i32,
	colors: ?*Color,
	version: Uint32,
	refcount: i32,
}

struct PixelFormatDetails {
	format: PixelFormat,
	bits_per_pixel: Uint8,
	bytes_per_pixel: Uint8,
	padding: [2]Uint8,
	Rmask: Uint32,
	Gmask: Uint32,
	Bmask: Uint32,
	Amask: Uint32,
	Rbits: Uint8,
	Gbits: Uint8,
	Bbits: Uint8,
	Abits: Uint8,
	Rshift: Uint8,
	Gshift: Uint8,
	Bshift: Uint8,
	Ashift: Uint8,
}

GetPixelFormatName :: fn(
	format: PixelFormat
) -> ?*u8 #foreign #link="SDL_GetPixelFormatName";

GetMasksForPixelFormat :: fn(
	format: PixelFormat,
	bpp: ?*i32,
	Rmask: ?*Uint32,
	Gmask: ?*Uint32,
	Bmask: ?*Uint32,
	Amask: ?*Uint32
) -> bool #foreign #link="SDL_GetMasksForPixelFormat";

GetPixelFormatForMasks :: fn(
	bpp: i32,
	Rmask: Uint32,
	Gmask: Uint32,
	Bmask: Uint32,
	Amask: Uint32
) -> PixelFormat #foreign #link="SDL_GetPixelFormatForMasks";

GetPixelFormatDetails :: fn(
	format: PixelFormat
) -> ?*PixelFormatDetails #foreign #link="SDL_GetPixelFormatDetails";

CreatePalette :: fn(
	ncolors: i32
) -> ?*Palette #foreign #link="SDL_CreatePalette";

SetPaletteColors :: fn(
	palette: ?*Palette,
	colors: ?*Color,
	firstcolor: i32,
	ncolors: i32
) -> bool #foreign #link="SDL_SetPaletteColors";

DestroyPalette :: fn(
	palette: ?*Palette
) #foreign #link="SDL_DestroyPalette";

MapRGB :: fn(
	format: ?*PixelFormatDetails,
	palette: ?*Palette,
	r: Uint8,
	g: Uint8,
	b: Uint8
) -> Uint32 #foreign #link="SDL_MapRGB";

MapRGBA :: fn(
	format: ?*PixelFormatDetails,
	palette: ?*Palette,
	r: Uint8,
	g: Uint8,
	b: Uint8,
	a: Uint8
) -> Uint32 #foreign #link="SDL_MapRGBA";

GetRGB :: fn(
	pixel: Uint32,
	format: ?*PixelFormatDetails,
	palette: ?*Palette,
	r: ?*Uint8,
	g: ?*Uint8,
	b: ?*Uint8
) #foreign #link="SDL_GetRGB";

GetRGBA :: fn(
	pixel: Uint32,
	format: ?*PixelFormatDetails,
	palette: ?*Palette,
	r: ?*Uint8,
	g: ?*Uint8,
	b: ?*Uint8,
	a: ?*Uint8
) #foreign #link="SDL_GetRGBA";

struct Point {
	x: i32,
	y: i32,
}

struct FPoint {
	x: f32,
	y: f32,
}

struct Rect {
	x: i32,
	y: i32,
	w: i32,
	h: i32,
}

struct FRect {
	x: f32,
	y: f32,
	w: f32,
	h: f32,
}

RectToFRect :: fn(
	rect: ?*Rect,
	frect: ?*FRect
) #foreign #link="SDL_RectToFRect";

PointInRect :: fn(
	p: ?*Point,
	r: ?*Rect
) -> bool #foreign #link="SDL_PointInRect";

RectEmpty :: fn(
	r: ?*Rect
) -> bool #foreign #link="SDL_RectEmpty";

RectsEqual :: fn(
	a: ?*Rect,
	b: ?*Rect
) -> bool #foreign #link="SDL_RectsEqual";

HasRectIntersection :: fn(
	A: ?*Rect,
	B: ?*Rect
) -> bool #foreign #link="SDL_HasRectIntersection";

GetRectIntersection :: fn(
	A: ?*Rect,
	B: ?*Rect,
	result: ?*Rect
) -> bool #foreign #link="SDL_GetRectIntersection";

GetRectUnion :: fn(
	A: ?*Rect,
	B: ?*Rect,
	result: ?*Rect
) -> bool #foreign #link="SDL_GetRectUnion";

GetRectEnclosingPoints :: fn(
	points: ?*Point,
	count: i32,
	clip: ?*Rect,
	result: ?*Rect
) -> bool #foreign #link="SDL_GetRectEnclosingPoints";

GetRectAndLineIntersection :: fn(
	rect: ?*Rect,
	X1: ?*i32,
	Y1: ?*i32,
	X2: ?*i32,
	Y2: ?*i32
) -> bool #foreign #link="SDL_GetRectAndLineIntersection";

PointInRectFloat :: fn(
	p: ?*FPoint,
	r: ?*FRect
) -> bool #foreign #link="SDL_PointInRectFloat";

RectEmptyFloat :: fn(
	r: ?*FRect
) -> bool #foreign #link="SDL_RectEmptyFloat";

RectsEqualEpsilon :: fn(
	a: ?*FRect,
	b: ?*FRect,
	epsilon: f32
) -> bool #foreign #link="SDL_RectsEqualEpsilon";

RectsEqualFloat :: fn(
	a: ?*FRect,
	b: ?*FRect
) -> bool #foreign #link="SDL_RectsEqualFloat";

HasRectIntersectionFloat :: fn(
	A: ?*FRect,
	B: ?*FRect
) -> bool #foreign #link="SDL_HasRectIntersectionFloat";

GetRectIntersectionFloat :: fn(
	A: ?*FRect,
	B: ?*FRect,
	result: ?*FRect
) -> bool #foreign #link="SDL_GetRectIntersectionFloat";

GetRectUnionFloat :: fn(
	A: ?*FRect,
	B: ?*FRect,
	result: ?*FRect
) -> bool #foreign #link="SDL_GetRectUnionFloat";

GetRectEnclosingPointsFloat :: fn(
	points: ?*FPoint,
	count: i32,
	clip: ?*FRect,
	result: ?*FRect
) -> bool #foreign #link="SDL_GetRectEnclosingPointsFloat";

GetRectAndLineIntersectionFloat :: fn(
	rect: ?*FRect,
	X1: ?*f32,
	Y1: ?*f32,
	X2: ?*f32,
	Y2: ?*f32
) -> bool #foreign #link="SDL_GetRectAndLineIntersectionFloat";

SurfaceFlags :: Uint32;

enum ScaleMode: u32 {
	INVALID = 0xffffffffffffffff,
	NEAREST = 0x0,
	LINEAR = 0x1,
}

enum FlipMode: u32 {
	FLIP_NONE = 0x0,
	FLIP_HORIZONTAL = 0x1,
	FLIP_VERTICAL = 0x2,
}

struct Surface {
	flags: SurfaceFlags,
	format: PixelFormat,
	w: i32,
	h: i32,
	pitch: i32,
	pixels: ?*,
	refcount: i32,
	reserved: ?*,
}

CreateSurface :: fn(
	width: i32,
	height: i32,
	format: PixelFormat
) -> ?*Surface #foreign #link="SDL_CreateSurface";

CreateSurfaceFrom :: fn(
	width: i32,
	height: i32,
	format: PixelFormat,
	pixels: ?*,
	pitch: i32
) -> ?*Surface #foreign #link="SDL_CreateSurfaceFrom";

DestroySurface :: fn(
	surface: ?*Surface
) #foreign #link="SDL_DestroySurface";

GetSurfaceProperties :: fn(
	surface: ?*Surface
) -> PropertiesID #foreign #link="SDL_GetSurfaceProperties";

SetSurfaceColorspace :: fn(
	surface: ?*Surface,
	colorspace: Colorspace
) -> bool #foreign #link="SDL_SetSurfaceColorspace";

GetSurfaceColorspace :: fn(
	surface: ?*Surface
) -> Colorspace #foreign #link="SDL_GetSurfaceColorspace";

CreateSurfacePalette :: fn(
	surface: ?*Surface
) -> ?*Palette #foreign #link="SDL_CreateSurfacePalette";

SetSurfacePalette :: fn(
	surface: ?*Surface,
	palette: ?*Palette
) -> bool #foreign #link="SDL_SetSurfacePalette";

GetSurfacePalette :: fn(
	surface: ?*Surface
) -> ?*Palette #foreign #link="SDL_GetSurfacePalette";

AddSurfaceAlternateImage :: fn(
	surface: ?*Surface,
	image: ?*Surface
) -> bool #foreign #link="SDL_AddSurfaceAlternateImage";

SurfaceHasAlternateImages :: fn(
	surface: ?*Surface
) -> bool #foreign #link="SDL_SurfaceHasAlternateImages";

GetSurfaceImages :: fn(
	surface: ?*Surface,
	count: ?*i32
) -> ?*?*Surface #foreign #link="SDL_GetSurfaceImages";

RemoveSurfaceAlternateImages :: fn(
	surface: ?*Surface
) #foreign #link="SDL_RemoveSurfaceAlternateImages";

LockSurface :: fn(
	surface: ?*Surface
) -> bool #foreign #link="SDL_LockSurface";

UnlockSurface :: fn(
	surface: ?*Surface
) #foreign #link="SDL_UnlockSurface";

LoadBMP_IO :: fn(
	src: ?*IOStream,
	closeio: bool
) -> ?*Surface #foreign #link="SDL_LoadBMP_IO";

LoadBMP :: fn(
	file: ?*u8
) -> ?*Surface #foreign #link="SDL_LoadBMP";

SaveBMP_IO :: fn(
	surface: ?*Surface,
	dst: ?*IOStream,
	closeio: bool
) -> bool #foreign #link="SDL_SaveBMP_IO";

SaveBMP :: fn(
	surface: ?*Surface,
	file: ?*u8
) -> bool #foreign #link="SDL_SaveBMP";

SetSurfaceRLE :: fn(
	surface: ?*Surface,
	enabled: bool
) -> bool #foreign #link="SDL_SetSurfaceRLE";

SurfaceHasRLE :: fn(
	surface: ?*Surface
) -> bool #foreign #link="SDL_SurfaceHasRLE";

SetSurfaceColorKey :: fn(
	surface: ?*Surface,
	enabled: bool,
	key: Uint32
) -> bool #foreign #link="SDL_SetSurfaceColorKey";

SurfaceHasColorKey :: fn(
	surface: ?*Surface
) -> bool #foreign #link="SDL_SurfaceHasColorKey";

GetSurfaceColorKey :: fn(
	surface: ?*Surface,
	key: ?*Uint32
) -> bool #foreign #link="SDL_GetSurfaceColorKey";

SetSurfaceColorMod :: fn(
	surface: ?*Surface,
	r: Uint8,
	g: Uint8,
	b: Uint8
) -> bool #foreign #link="SDL_SetSurfaceColorMod";

GetSurfaceColorMod :: fn(
	surface: ?*Surface,
	r: ?*Uint8,
	g: ?*Uint8,
	b: ?*Uint8
) -> bool #foreign #link="SDL_GetSurfaceColorMod";

SetSurfaceAlphaMod :: fn(
	surface: ?*Surface,
	alpha: Uint8
) -> bool #foreign #link="SDL_SetSurfaceAlphaMod";

GetSurfaceAlphaMod :: fn(
	surface: ?*Surface,
	alpha: ?*Uint8
) -> bool #foreign #link="SDL_GetSurfaceAlphaMod";

SetSurfaceBlendMode :: fn(
	surface: ?*Surface,
	blendMode: BlendMode
) -> bool #foreign #link="SDL_SetSurfaceBlendMode";

GetSurfaceBlendMode :: fn(
	surface: ?*Surface,
	blendMode: ?*BlendMode
) -> bool #foreign #link="SDL_GetSurfaceBlendMode";

SetSurfaceClipRect :: fn(
	surface: ?*Surface,
	rect: ?*Rect
) -> bool #foreign #link="SDL_SetSurfaceClipRect";

GetSurfaceClipRect :: fn(
	surface: ?*Surface,
	rect: ?*Rect
) -> bool #foreign #link="SDL_GetSurfaceClipRect";

FlipSurface :: fn(
	surface: ?*Surface,
	flip: FlipMode
) -> bool #foreign #link="SDL_FlipSurface";

DuplicateSurface :: fn(
	surface: ?*Surface
) -> ?*Surface #foreign #link="SDL_DuplicateSurface";

ScaleSurface :: fn(
	surface: ?*Surface,
	width: i32,
	height: i32,
	scaleMode: ScaleMode
) -> ?*Surface #foreign #link="SDL_ScaleSurface";

ConvertSurface :: fn(
	surface: ?*Surface,
	format: PixelFormat
) -> ?*Surface #foreign #link="SDL_ConvertSurface";

ConvertSurfaceAndColorspace :: fn(
	surface: ?*Surface,
	format: PixelFormat,
	palette: ?*Palette,
	colorspace: Colorspace,
	props: PropertiesID
) -> ?*Surface #foreign #link="SDL_ConvertSurfaceAndColorspace";

ConvertPixels :: fn(
	width: i32,
	height: i32,
	src_format: PixelFormat,
	src: ?*,
	src_pitch: i32,
	dst_format: PixelFormat,
	dst: ?*,
	dst_pitch: i32
) -> bool #foreign #link="SDL_ConvertPixels";

ConvertPixelsAndColorspace :: fn(
	width: i32,
	height: i32,
	src_format: PixelFormat,
	src_colorspace: Colorspace,
	src_properties: PropertiesID,
	src: ?*,
	src_pitch: i32,
	dst_format: PixelFormat,
	dst_colorspace: Colorspace,
	dst_properties: PropertiesID,
	dst: ?*,
	dst_pitch: i32
) -> bool #foreign #link="SDL_ConvertPixelsAndColorspace";

PremultiplyAlpha :: fn(
	width: i32,
	height: i32,
	src_format: PixelFormat,
	src: ?*,
	src_pitch: i32,
	dst_format: PixelFormat,
	dst: ?*,
	dst_pitch: i32,
	linear: bool
) -> bool #foreign #link="SDL_PremultiplyAlpha";

PremultiplySurfaceAlpha :: fn(
	surface: ?*Surface,
	linear: bool
) -> bool #foreign #link="SDL_PremultiplySurfaceAlpha";

ClearSurface :: fn(
	surface: ?*Surface,
	r: f32,
	g: f32,
	b: f32,
	a: f32
) -> bool #foreign #link="SDL_ClearSurface";

FillSurfaceRect :: fn(
	dst: ?*Surface,
	rect: ?*Rect,
	color: Uint32
) -> bool #foreign #link="SDL_FillSurfaceRect";

FillSurfaceRects :: fn(
	dst: ?*Surface,
	rects: ?*Rect,
	count: i32,
	color: Uint32
) -> bool #foreign #link="SDL_FillSurfaceRects";

BlitSurface :: fn(
	src: ?*Surface,
	srcrect: ?*Rect,
	dst: ?*Surface,
	dstrect: ?*Rect
) -> bool #foreign #link="SDL_BlitSurface";

BlitSurfaceUnchecked :: fn(
	src: ?*Surface,
	srcrect: ?*Rect,
	dst: ?*Surface,
	dstrect: ?*Rect
) -> bool #foreign #link="SDL_BlitSurfaceUnchecked";

BlitSurfaceScaled :: fn(
	src: ?*Surface,
	srcrect: ?*Rect,
	dst: ?*Surface,
	dstrect: ?*Rect,
	scaleMode: ScaleMode
) -> bool #foreign #link="SDL_BlitSurfaceScaled";

BlitSurfaceUncheckedScaled :: fn(
	src: ?*Surface,
	srcrect: ?*Rect,
	dst: ?*Surface,
	dstrect: ?*Rect,
	scaleMode: ScaleMode
) -> bool #foreign #link="SDL_BlitSurfaceUncheckedScaled";

StretchSurface :: fn(
	src: ?*Surface,
	srcrect: ?*Rect,
	dst: ?*Surface,
	dstrect: ?*Rect,
	scaleMode: ScaleMode
) -> bool #foreign #link="SDL_StretchSurface";

BlitSurfaceTiled :: fn(
	src: ?*Surface,
	srcrect: ?*Rect,
	dst: ?*Surface,
	dstrect: ?*Rect
) -> bool #foreign #link="SDL_BlitSurfaceTiled";

BlitSurfaceTiledWithScale :: fn(
	src: ?*Surface,
	srcrect: ?*Rect,
	scale: f32,
	scaleMode: ScaleMode,
	dst: ?*Surface,
	dstrect: ?*Rect
) -> bool #foreign #link="SDL_BlitSurfaceTiledWithScale";

BlitSurface9Grid :: fn(
	src: ?*Surface,
	srcrect: ?*Rect,
	left_width: i32,
	right_width: i32,
	top_height: i32,
	bottom_height: i32,
	scale: f32,
	scaleMode: ScaleMode,
	dst: ?*Surface,
	dstrect: ?*Rect
) -> bool #foreign #link="SDL_BlitSurface9Grid";

MapSurfaceRGB :: fn(
	surface: ?*Surface,
	r: Uint8,
	g: Uint8,
	b: Uint8
) -> Uint32 #foreign #link="SDL_MapSurfaceRGB";

MapSurfaceRGBA :: fn(
	surface: ?*Surface,
	r: Uint8,
	g: Uint8,
	b: Uint8,
	a: Uint8
) -> Uint32 #foreign #link="SDL_MapSurfaceRGBA";

ReadSurfacePixel :: fn(
	surface: ?*Surface,
	x: i32,
	y: i32,
	r: ?*Uint8,
	g: ?*Uint8,
	b: ?*Uint8,
	a: ?*Uint8
) -> bool #foreign #link="SDL_ReadSurfacePixel";

ReadSurfacePixelFloat :: fn(
	surface: ?*Surface,
	x: i32,
	y: i32,
	r: ?*f32,
	g: ?*f32,
	b: ?*f32,
	a: ?*f32
) -> bool #foreign #link="SDL_ReadSurfacePixelFloat";

WriteSurfacePixel :: fn(
	surface: ?*Surface,
	x: i32,
	y: i32,
	r: Uint8,
	g: Uint8,
	b: Uint8,
	a: Uint8
) -> bool #foreign #link="SDL_WriteSurfacePixel";

WriteSurfacePixelFloat :: fn(
	surface: ?*Surface,
	x: i32,
	y: i32,
	r: f32,
	g: f32,
	b: f32,
	a: f32
) -> bool #foreign #link="SDL_WriteSurfacePixelFloat";

CameraID :: Uint32;

struct Camera {
}

struct CameraSpec {
	format: PixelFormat,
	colorspace: Colorspace,
	width: i32,
	height: i32,
	framerate_numerator: i32,
	framerate_denominator: i32,
}

enum CameraPosition: u32 {
	CAMERA_POSITION_UNKNOWN = 0x0,
	CAMERA_POSITION_FRONT_FACING = 0x1,
	CAMERA_POSITION_BACK_FACING = 0x2,
}

GetNumCameraDrivers :: fn() -> i32 #foreign #link="SDL_GetNumCameraDrivers";

GetCameraDriver :: fn(
	index: i32
) -> ?*u8 #foreign #link="SDL_GetCameraDriver";

GetCurrentCameraDriver :: fn() -> ?*u8 #foreign #link="SDL_GetCurrentCameraDriver";

GetCameras :: fn(
	count: ?*i32
) -> ?*CameraID #foreign #link="SDL_GetCameras";

GetCameraSupportedFormats :: fn(
	instance_id: CameraID,
	count: ?*i32
) -> ?*?*CameraSpec #foreign #link="SDL_GetCameraSupportedFormats";

GetCameraName :: fn(
	instance_id: CameraID
) -> ?*u8 #foreign #link="SDL_GetCameraName";

GetCameraPosition :: fn(
	instance_id: CameraID
) -> CameraPosition #foreign #link="SDL_GetCameraPosition";

OpenCamera :: fn(
	instance_id: CameraID,
	spec: ?*CameraSpec
) -> ?*Camera #foreign #link="SDL_OpenCamera";

GetCameraPermissionState :: fn(
	camera: ?*Camera
) -> i32 #foreign #link="SDL_GetCameraPermissionState";

GetCameraID :: fn(
	camera: ?*Camera
) -> CameraID #foreign #link="SDL_GetCameraID";

GetCameraProperties :: fn(
	camera: ?*Camera
) -> PropertiesID #foreign #link="SDL_GetCameraProperties";

GetCameraFormat :: fn(
	camera: ?*Camera,
	spec: ?*CameraSpec
) -> bool #foreign #link="SDL_GetCameraFormat";

AcquireCameraFrame :: fn(
	camera: ?*Camera,
	timestampNS: ?*Uint64
) -> ?*Surface #foreign #link="SDL_AcquireCameraFrame";

ReleaseCameraFrame :: fn(
	camera: ?*Camera,
	frame: ?*Surface
) #foreign #link="SDL_ReleaseCameraFrame";

CloseCamera :: fn(
	camera: ?*Camera
) #foreign #link="SDL_CloseCamera";

SetClipboardText :: fn(
	text: ?*u8
) -> bool #foreign #link="SDL_SetClipboardText";

GetClipboardText :: fn() -> ?*u8 #foreign #link="SDL_GetClipboardText";

HasClipboardText :: fn() -> bool #foreign #link="SDL_HasClipboardText";

SetPrimarySelectionText :: fn(
	text: ?*u8
) -> bool #foreign #link="SDL_SetPrimarySelectionText";

GetPrimarySelectionText :: fn() -> ?*u8 #foreign #link="SDL_GetPrimarySelectionText";

HasPrimarySelectionText :: fn() -> bool #foreign #link="SDL_HasPrimarySelectionText";

ClipboardDataCallback :: ?*fn(a: ?*, b: ?*u8, c: ?*uint) -> ?* #foreign;

ClipboardCleanupCallback :: ?*fn(a: ?*) #foreign;

SetClipboardData :: fn(
	callback: ClipboardDataCallback,
	cleanup: ClipboardCleanupCallback,
	userdata: ?*,
	mime_types: ?*?*u8,
	num_mime_types: uint
) -> bool #foreign #link="SDL_SetClipboardData";

ClearClipboardData :: fn() -> bool #foreign #link="SDL_ClearClipboardData";

GetClipboardData :: fn(
	mime_type: ?*u8,
	size: ?*uint
) -> ?* #foreign #link="SDL_GetClipboardData";

HasClipboardData :: fn(
	mime_type: ?*u8
) -> bool #foreign #link="SDL_HasClipboardData";

GetClipboardMimeTypes :: fn(
	num_mime_types: ?*uint
) -> ?*?*u8 #foreign #link="SDL_GetClipboardMimeTypes";

GetNumLogicalCPUCores :: fn() -> i32 #foreign #link="SDL_GetNumLogicalCPUCores";

GetCPUCacheLineSize :: fn() -> i32 #foreign #link="SDL_GetCPUCacheLineSize";

HasAltiVec :: fn() -> bool #foreign #link="SDL_HasAltiVec";

HasMMX :: fn() -> bool #foreign #link="SDL_HasMMX";

HasSSE :: fn() -> bool #foreign #link="SDL_HasSSE";

HasSSE2 :: fn() -> bool #foreign #link="SDL_HasSSE2";

HasSSE3 :: fn() -> bool #foreign #link="SDL_HasSSE3";

HasSSE41 :: fn() -> bool #foreign #link="SDL_HasSSE41";

HasSSE42 :: fn() -> bool #foreign #link="SDL_HasSSE42";

HasAVX :: fn() -> bool #foreign #link="SDL_HasAVX";

HasAVX2 :: fn() -> bool #foreign #link="SDL_HasAVX2";

HasAVX512F :: fn() -> bool #foreign #link="SDL_HasAVX512F";

HasARMSIMD :: fn() -> bool #foreign #link="SDL_HasARMSIMD";

HasNEON :: fn() -> bool #foreign #link="SDL_HasNEON";

HasLSX :: fn() -> bool #foreign #link="SDL_HasLSX";

HasLASX :: fn() -> bool #foreign #link="SDL_HasLASX";

GetSystemRAM :: fn() -> i32 #foreign #link="SDL_GetSystemRAM";

GetSIMDAlignment :: fn() -> uint #foreign #link="SDL_GetSIMDAlignment";

DisplayID :: Uint32;

WindowID :: Uint32;

enum SystemTheme: u32 {
	SYSTEM_THEME_UNKNOWN = 0x0,
	SYSTEM_THEME_LIGHT = 0x1,
	SYSTEM_THEME_DARK = 0x2,
}

struct DisplayModeData {
}

struct DisplayMode {
	displayID: DisplayID,
	format: PixelFormat,
	w: i32,
	h: i32,
	pixel_density: f32,
	refresh_rate: f32,
	refresh_rate_numerator: i32,
	refresh_rate_denominator: i32,
	internal: ?*DisplayModeData,
}

enum DisplayOrientation: u32 {
	ORIENTATION_UNKNOWN = 0x0,
	ORIENTATION_LANDSCAPE = 0x1,
	ORIENTATION_LANDSCAPE_FLIPPED = 0x2,
	ORIENTATION_PORTRAIT = 0x3,
	ORIENTATION_PORTRAIT_FLIPPED = 0x4,
}

struct Window {
}

WindowFlags :: Uint64;

enum FlashOperation: u32 {
	FLASH_CANCEL = 0x0,
	FLASH_BRIEFLY = 0x1,
	FLASH_UNTIL_FOCUSED = 0x2,
}

struct GLContextState {
}

GLContext :: ?*GLContextState;

EGLDisplay :: ?*void;

EGLConfig :: ?*void;

EGLSurface :: ?*void;

EGLAttrib :: intptr_t;

EGLint :: i32;

EGLAttribArrayCallback :: ?*fn(a: ?*) -> ?*EGLAttrib #foreign;

EGLIntArrayCallback :: ?*fn(a: ?*, b: EGLDisplay, c: EGLConfig) -> ?*EGLint #foreign;

enum GLAttr: u32 {
	GL_RED_SIZE = 0x0,
	GL_GREEN_SIZE = 0x1,
	GL_BLUE_SIZE = 0x2,
	GL_ALPHA_SIZE = 0x3,
	GL_BUFFER_SIZE = 0x4,
	GL_DOUBLEBUFFER = 0x5,
	GL_DEPTH_SIZE = 0x6,
	GL_STENCIL_SIZE = 0x7,
	GL_ACCUM_RED_SIZE = 0x8,
	GL_ACCUM_GREEN_SIZE = 0x9,
	GL_ACCUM_BLUE_SIZE = 0xa,
	GL_ACCUM_ALPHA_SIZE = 0xb,
	GL_STEREO = 0xc,
	GL_MULTISAMPLEBUFFERS = 0xd,
	GL_MULTISAMPLESAMPLES = 0xe,
	GL_ACCELERATED_VISUAL = 0xf,
	GL_RETAINED_BACKING = 0x10,
	GL_CONTEXT_MAJOR_VERSION = 0x11,
	GL_CONTEXT_MINOR_VERSION = 0x12,
	GL_CONTEXT_FLAGS = 0x13,
	GL_CONTEXT_PROFILE_MASK = 0x14,
	GL_SHARE_WITH_CURRENT_CONTEXT = 0x15,
	GL_FRAMEBUFFER_SRGB_CAPABLE = 0x16,
	GL_CONTEXT_RELEASE_BEHAVIOR = 0x17,
	GL_CONTEXT_RESET_NOTIFICATION = 0x18,
	GL_CONTEXT_NO_ERROR = 0x19,
	GL_FLOATBUFFERS = 0x1a,
	GL_EGL_PLATFORM = 0x1b,
}

GLProfile :: Uint32;

GLContextFlag :: Uint32;

GLContextReleaseFlag :: Uint32;

GLContextResetNotification :: Uint32;

GetNumVideoDrivers :: fn() -> i32 #foreign #link="SDL_GetNumVideoDrivers";

GetVideoDriver :: fn(
	index: i32
) -> ?*u8 #foreign #link="SDL_GetVideoDriver";

GetCurrentVideoDriver :: fn() -> ?*u8 #foreign #link="SDL_GetCurrentVideoDriver";

GetSystemTheme :: fn() -> SystemTheme #foreign #link="SDL_GetSystemTheme";

GetDisplays :: fn(
	count: ?*i32
) -> ?*DisplayID #foreign #link="SDL_GetDisplays";

GetPrimaryDisplay :: fn() -> DisplayID #foreign #link="SDL_GetPrimaryDisplay";

GetDisplayProperties :: fn(
	displayID: DisplayID
) -> PropertiesID #foreign #link="SDL_GetDisplayProperties";

GetDisplayName :: fn(
	displayID: DisplayID
) -> ?*u8 #foreign #link="SDL_GetDisplayName";

GetDisplayBounds :: fn(
	displayID: DisplayID,
	rect: ?*Rect
) -> bool #foreign #link="SDL_GetDisplayBounds";

GetDisplayUsableBounds :: fn(
	displayID: DisplayID,
	rect: ?*Rect
) -> bool #foreign #link="SDL_GetDisplayUsableBounds";

GetNaturalDisplayOrientation :: fn(
	displayID: DisplayID
) -> DisplayOrientation #foreign #link="SDL_GetNaturalDisplayOrientation";

GetCurrentDisplayOrientation :: fn(
	displayID: DisplayID
) -> DisplayOrientation #foreign #link="SDL_GetCurrentDisplayOrientation";

GetDisplayContentScale :: fn(
	displayID: DisplayID
) -> f32 #foreign #link="SDL_GetDisplayContentScale";

GetFullscreenDisplayModes :: fn(
	displayID: DisplayID,
	count: ?*i32
) -> ?*?*DisplayMode #foreign #link="SDL_GetFullscreenDisplayModes";

GetClosestFullscreenDisplayMode :: fn(
	displayID: DisplayID,
	w: i32,
	h: i32,
	refresh_rate: f32,
	include_high_density_modes: bool,
	closest: ?*DisplayMode
) -> bool #foreign #link="SDL_GetClosestFullscreenDisplayMode";

GetDesktopDisplayMode :: fn(
	displayID: DisplayID
) -> ?*DisplayMode #foreign #link="SDL_GetDesktopDisplayMode";

GetCurrentDisplayMode :: fn(
	displayID: DisplayID
) -> ?*DisplayMode #foreign #link="SDL_GetCurrentDisplayMode";

GetDisplayForPoint :: fn(
	point: ?*Point
) -> DisplayID #foreign #link="SDL_GetDisplayForPoint";

GetDisplayForRect :: fn(
	rect: ?*Rect
) -> DisplayID #foreign #link="SDL_GetDisplayForRect";

GetDisplayForWindow :: fn(
	window: ?*Window
) -> DisplayID #foreign #link="SDL_GetDisplayForWindow";

GetWindowPixelDensity :: fn(
	window: ?*Window
) -> f32 #foreign #link="SDL_GetWindowPixelDensity";

GetWindowDisplayScale :: fn(
	window: ?*Window
) -> f32 #foreign #link="SDL_GetWindowDisplayScale";

SetWindowFullscreenMode :: fn(
	window: ?*Window,
	mode: ?*DisplayMode
) -> bool #foreign #link="SDL_SetWindowFullscreenMode";

GetWindowFullscreenMode :: fn(
	window: ?*Window
) -> ?*DisplayMode #foreign #link="SDL_GetWindowFullscreenMode";

GetWindowICCProfile :: fn(
	window: ?*Window,
	size: ?*uint
) -> ?* #foreign #link="SDL_GetWindowICCProfile";

GetWindowPixelFormat :: fn(
	window: ?*Window
) -> PixelFormat #foreign #link="SDL_GetWindowPixelFormat";

GetWindows :: fn(
	count: ?*i32
) -> ?*?*Window #foreign #link="SDL_GetWindows";

CreateWindow :: fn(
	title: ?*u8,
	w: i32,
	h: i32,
	flags: WindowFlags
) -> ?*Window #foreign #link="SDL_CreateWindow";

CreatePopupWindow :: fn(
	parent: ?*Window,
	offset_x: i32,
	offset_y: i32,
	w: i32,
	h: i32,
	flags: WindowFlags
) -> ?*Window #foreign #link="SDL_CreatePopupWindow";

CreateWindowWithProperties :: fn(
	props: PropertiesID
) -> ?*Window #foreign #link="SDL_CreateWindowWithProperties";

GetWindowID :: fn(
	window: ?*Window
) -> WindowID #foreign #link="SDL_GetWindowID";

GetWindowFromID :: fn(
	id: WindowID
) -> ?*Window #foreign #link="SDL_GetWindowFromID";

GetWindowParent :: fn(
	window: ?*Window
) -> ?*Window #foreign #link="SDL_GetWindowParent";

GetWindowProperties :: fn(
	window: ?*Window
) -> PropertiesID #foreign #link="SDL_GetWindowProperties";

GetWindowFlags :: fn(
	window: ?*Window
) -> WindowFlags #foreign #link="SDL_GetWindowFlags";

SetWindowTitle :: fn(
	window: ?*Window,
	title: ?*u8
) -> bool #foreign #link="SDL_SetWindowTitle";

GetWindowTitle :: fn(
	window: ?*Window
) -> ?*u8 #foreign #link="SDL_GetWindowTitle";

SetWindowIcon :: fn(
	window: ?*Window,
	icon: ?*Surface
) -> bool #foreign #link="SDL_SetWindowIcon";

SetWindowPosition :: fn(
	window: ?*Window,
	x: i32,
	y: i32
) -> bool #foreign #link="SDL_SetWindowPosition";

GetWindowPosition :: fn(
	window: ?*Window,
	x: ?*i32,
	y: ?*i32
) -> bool #foreign #link="SDL_GetWindowPosition";

SetWindowSize :: fn(
	window: ?*Window,
	w: i32,
	h: i32
) -> bool #foreign #link="SDL_SetWindowSize";

GetWindowSize :: fn(
	window: ?*Window,
	w: ?*i32,
	h: ?*i32
) -> bool #foreign #link="SDL_GetWindowSize";

GetWindowSafeArea :: fn(
	window: ?*Window,
	rect: ?*Rect
) -> bool #foreign #link="SDL_GetWindowSafeArea";

SetWindowAspectRatio :: fn(
	window: ?*Window,
	min_aspect: f32,
	max_aspect: f32
) -> bool #foreign #link="SDL_SetWindowAspectRatio";

GetWindowAspectRatio :: fn(
	window: ?*Window,
	min_aspect: ?*f32,
	max_aspect: ?*f32
) -> bool #foreign #link="SDL_GetWindowAspectRatio";

GetWindowBordersSize :: fn(
	window: ?*Window,
	top: ?*i32,
	left: ?*i32,
	bottom: ?*i32,
	right: ?*i32
) -> bool #foreign #link="SDL_GetWindowBordersSize";

GetWindowSizeInPixels :: fn(
	window: ?*Window,
	w: ?*i32,
	h: ?*i32
) -> bool #foreign #link="SDL_GetWindowSizeInPixels";

SetWindowMinimumSize :: fn(
	window: ?*Window,
	min_w: i32,
	min_h: i32
) -> bool #foreign #link="SDL_SetWindowMinimumSize";

GetWindowMinimumSize :: fn(
	window: ?*Window,
	w: ?*i32,
	h: ?*i32
) -> bool #foreign #link="SDL_GetWindowMinimumSize";

SetWindowMaximumSize :: fn(
	window: ?*Window,
	max_w: i32,
	max_h: i32
) -> bool #foreign #link="SDL_SetWindowMaximumSize";

GetWindowMaximumSize :: fn(
	window: ?*Window,
	w: ?*i32,
	h: ?*i32
) -> bool #foreign #link="SDL_GetWindowMaximumSize";

SetWindowBordered :: fn(
	window: ?*Window,
	bordered: bool
) -> bool #foreign #link="SDL_SetWindowBordered";

SetWindowResizable :: fn(
	window: ?*Window,
	resizable: bool
) -> bool #foreign #link="SDL_SetWindowResizable";

SetWindowAlwaysOnTop :: fn(
	window: ?*Window,
	on_top: bool
) -> bool #foreign #link="SDL_SetWindowAlwaysOnTop";

ShowWindow :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_ShowWindow";

HideWindow :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_HideWindow";

RaiseWindow :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_RaiseWindow";

MaximizeWindow :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_MaximizeWindow";

MinimizeWindow :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_MinimizeWindow";

RestoreWindow :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_RestoreWindow";

SetWindowFullscreen :: fn(
	window: ?*Window,
	fullscreen: bool
) -> bool #foreign #link="SDL_SetWindowFullscreen";

SyncWindow :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_SyncWindow";

WindowHasSurface :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_WindowHasSurface";

GetWindowSurface :: fn(
	window: ?*Window
) -> ?*Surface #foreign #link="SDL_GetWindowSurface";

SetWindowSurfaceVSync :: fn(
	window: ?*Window,
	vsync: i32
) -> bool #foreign #link="SDL_SetWindowSurfaceVSync";

GetWindowSurfaceVSync :: fn(
	window: ?*Window,
	vsync: ?*i32
) -> bool #foreign #link="SDL_GetWindowSurfaceVSync";

UpdateWindowSurface :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_UpdateWindowSurface";

UpdateWindowSurfaceRects :: fn(
	window: ?*Window,
	rects: ?*Rect,
	numrects: i32
) -> bool #foreign #link="SDL_UpdateWindowSurfaceRects";

DestroyWindowSurface :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_DestroyWindowSurface";

SetWindowKeyboardGrab :: fn(
	window: ?*Window,
	grabbed: bool
) -> bool #foreign #link="SDL_SetWindowKeyboardGrab";

SetWindowMouseGrab :: fn(
	window: ?*Window,
	grabbed: bool
) -> bool #foreign #link="SDL_SetWindowMouseGrab";

GetWindowKeyboardGrab :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_GetWindowKeyboardGrab";

GetWindowMouseGrab :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_GetWindowMouseGrab";

GetGrabbedWindow :: fn() -> ?*Window #foreign #link="SDL_GetGrabbedWindow";

SetWindowMouseRect :: fn(
	window: ?*Window,
	rect: ?*Rect
) -> bool #foreign #link="SDL_SetWindowMouseRect";

GetWindowMouseRect :: fn(
	window: ?*Window
) -> ?*Rect #foreign #link="SDL_GetWindowMouseRect";

SetWindowOpacity :: fn(
	window: ?*Window,
	opacity: f32
) -> bool #foreign #link="SDL_SetWindowOpacity";

GetWindowOpacity :: fn(
	window: ?*Window
) -> f32 #foreign #link="SDL_GetWindowOpacity";

SetWindowParent :: fn(
	window: ?*Window,
	parent: ?*Window
) -> bool #foreign #link="SDL_SetWindowParent";

SetWindowModal :: fn(
	window: ?*Window,
	modal: bool
) -> bool #foreign #link="SDL_SetWindowModal";

SetWindowFocusable :: fn(
	window: ?*Window,
	focusable: bool
) -> bool #foreign #link="SDL_SetWindowFocusable";

ShowWindowSystemMenu :: fn(
	window: ?*Window,
	x: i32,
	y: i32
) -> bool #foreign #link="SDL_ShowWindowSystemMenu";

enum HitTestResult: u32 {
	HITTEST_NORMAL = 0x0,
	HITTEST_DRAGGABLE = 0x1,
	HITTEST_RESIZE_TOPLEFT = 0x2,
	HITTEST_RESIZE_TOP = 0x3,
	HITTEST_RESIZE_TOPRIGHT = 0x4,
	HITTEST_RESIZE_RIGHT = 0x5,
	HITTEST_RESIZE_BOTTOMRIGHT = 0x6,
	HITTEST_RESIZE_BOTTOM = 0x7,
	HITTEST_RESIZE_BOTTOMLEFT = 0x8,
	HITTEST_RESIZE_LEFT = 0x9,
}

HitTest :: ?*fn(a: ?*Window, b: ?*Point, c: ?*) -> HitTestResult #foreign;

SetWindowHitTest :: fn(
	window: ?*Window,
	callback: HitTest,
	callback_data: ?*
) -> bool #foreign #link="SDL_SetWindowHitTest";

SetWindowShape :: fn(
	window: ?*Window,
	shape: ?*Surface
) -> bool #foreign #link="SDL_SetWindowShape";

FlashWindow :: fn(
	window: ?*Window,
	operation: FlashOperation
) -> bool #foreign #link="SDL_FlashWindow";

DestroyWindow :: fn(
	window: ?*Window
) #foreign #link="SDL_DestroyWindow";

ScreenSaverEnabled :: fn() -> bool #foreign #link="SDL_ScreenSaverEnabled";

EnableScreenSaver :: fn() -> bool #foreign #link="SDL_EnableScreenSaver";

DisableScreenSaver :: fn() -> bool #foreign #link="SDL_DisableScreenSaver";

GL_LoadLibrary :: fn(
	path: ?*u8
) -> bool #foreign #link="SDL_GL_LoadLibrary";

GL_GetProcAddress :: fn(
	proc: ?*u8
) -> FunctionPointer #foreign #link="SDL_GL_GetProcAddress";

EGL_GetProcAddress :: fn(
	proc: ?*u8
) -> FunctionPointer #foreign #link="SDL_EGL_GetProcAddress";

GL_UnloadLibrary :: fn() #foreign #link="SDL_GL_UnloadLibrary";

GL_ExtensionSupported :: fn(
	extension: ?*u8
) -> bool #foreign #link="SDL_GL_ExtensionSupported";

GL_ResetAttributes :: fn() #foreign #link="SDL_GL_ResetAttributes";

GL_SetAttribute :: fn(
	attr: GLAttr,
	value: i32
) -> bool #foreign #link="SDL_GL_SetAttribute";

GL_GetAttribute :: fn(
	attr: GLAttr,
	value: ?*i32
) -> bool #foreign #link="SDL_GL_GetAttribute";

GL_CreateContext :: fn(
	window: ?*Window
) -> GLContext #foreign #link="SDL_GL_CreateContext";

GL_MakeCurrent :: fn(
	window: ?*Window,
	context: GLContext
) -> bool #foreign #link="SDL_GL_MakeCurrent";

GL_GetCurrentWindow :: fn() -> ?*Window #foreign #link="SDL_GL_GetCurrentWindow";

GL_GetCurrentContext :: fn() -> GLContext #foreign #link="SDL_GL_GetCurrentContext";

EGL_GetCurrentDisplay :: fn() -> EGLDisplay #foreign #link="SDL_EGL_GetCurrentDisplay";

EGL_GetCurrentConfig :: fn() -> EGLConfig #foreign #link="SDL_EGL_GetCurrentConfig";

EGL_GetWindowSurface :: fn(
	window: ?*Window
) -> EGLSurface #foreign #link="SDL_EGL_GetWindowSurface";

EGL_SetAttributeCallbacks :: fn(
	platformAttribCallback: EGLAttribArrayCallback,
	surfaceAttribCallback: EGLIntArrayCallback,
	contextAttribCallback: EGLIntArrayCallback,
	userdata: ?*
) #foreign #link="SDL_EGL_SetAttributeCallbacks";

GL_SetSwapInterval :: fn(
	interval: i32
) -> bool #foreign #link="SDL_GL_SetSwapInterval";

GL_GetSwapInterval :: fn(
	interval: ?*i32
) -> bool #foreign #link="SDL_GL_GetSwapInterval";

GL_SwapWindow :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_GL_SwapWindow";

GL_DestroyContext :: fn(
	context: GLContext
) -> bool #foreign #link="SDL_GL_DestroyContext";

struct DialogFileFilter {
	name: ?*u8,
	pattern: ?*u8,
}

DialogFileCallback :: ?*fn(a: ?*, b: ?*?*u8, c: i32) #foreign;

ShowOpenFileDialog :: fn(
	callback: DialogFileCallback,
	userdata: ?*,
	window: ?*Window,
	filters: ?*DialogFileFilter,
	nfilters: i32,
	default_location: ?*u8,
	allow_many: bool
) #foreign #link="SDL_ShowOpenFileDialog";

ShowSaveFileDialog :: fn(
	callback: DialogFileCallback,
	userdata: ?*,
	window: ?*Window,
	filters: ?*DialogFileFilter,
	nfilters: i32,
	default_location: ?*u8
) #foreign #link="SDL_ShowSaveFileDialog";

ShowOpenFolderDialog :: fn(
	callback: DialogFileCallback,
	userdata: ?*,
	window: ?*Window,
	default_location: ?*u8,
	allow_many: bool
) #foreign #link="SDL_ShowOpenFolderDialog";

enum FileDialogType: u32 {
	FILEDIALOG_OPENFILE = 0x0,
	FILEDIALOG_SAVEFILE = 0x1,
	FILEDIALOG_OPENFOLDER = 0x2,
}

ShowFileDialogWithProperties :: fn(
	type: FileDialogType,
	callback: DialogFileCallback,
	userdata: ?*,
	props: PropertiesID
) #foreign #link="SDL_ShowFileDialogWithProperties";

struct GUID {
	data: [16]Uint8,
}

GUIDToString :: fn(
	guid: GUID,
	pszGUID: ?*u8,
	cbGUID: i32
) #foreign #link="SDL_GUIDToString";

StringToGUID :: fn(
	pchGUID: ?*u8
) -> GUID #foreign #link="SDL_StringToGUID";

enum PowerState: u32 {
	ERROR = 0xffffffffffffffff,
	UNKNOWN = 0x0,
	ON_BATTERY = 0x1,
	NO_BATTERY = 0x2,
	CHARGING = 0x3,
	CHARGED = 0x4,
}

GetPowerInfo :: fn(
	seconds: ?*i32,
	percent: ?*i32
) -> PowerState #foreign #link="SDL_GetPowerInfo";

struct Sensor {
}

SensorID :: Uint32;

enum SensorType: u32 {
	SENSOR_INVALID = 0xffffffffffffffff,
	SENSOR_UNKNOWN = 0x0,
	SENSOR_ACCEL = 0x1,
	SENSOR_GYRO = 0x2,
	SENSOR_ACCEL_L = 0x3,
	SENSOR_GYRO_L = 0x4,
	SENSOR_ACCEL_R = 0x5,
	SENSOR_GYRO_R = 0x6,
}

GetSensors :: fn(
	count: ?*i32
) -> ?*SensorID #foreign #link="SDL_GetSensors";

GetSensorNameForID :: fn(
	instance_id: SensorID
) -> ?*u8 #foreign #link="SDL_GetSensorNameForID";

GetSensorTypeForID :: fn(
	instance_id: SensorID
) -> SensorType #foreign #link="SDL_GetSensorTypeForID";

GetSensorNonPortableTypeForID :: fn(
	instance_id: SensorID
) -> i32 #foreign #link="SDL_GetSensorNonPortableTypeForID";

OpenSensor :: fn(
	instance_id: SensorID
) -> ?*Sensor #foreign #link="SDL_OpenSensor";

GetSensorFromID :: fn(
	instance_id: SensorID
) -> ?*Sensor #foreign #link="SDL_GetSensorFromID";

GetSensorProperties :: fn(
	sensor: ?*Sensor
) -> PropertiesID #foreign #link="SDL_GetSensorProperties";

GetSensorName :: fn(
	sensor: ?*Sensor
) -> ?*u8 #foreign #link="SDL_GetSensorName";

GetSensorType :: fn(
	sensor: ?*Sensor
) -> SensorType #foreign #link="SDL_GetSensorType";

GetSensorNonPortableType :: fn(
	sensor: ?*Sensor
) -> i32 #foreign #link="SDL_GetSensorNonPortableType";

GetSensorID :: fn(
	sensor: ?*Sensor
) -> SensorID #foreign #link="SDL_GetSensorID";

GetSensorData :: fn(
	sensor: ?*Sensor,
	data: ?*f32,
	num_values: i32
) -> bool #foreign #link="SDL_GetSensorData";

CloseSensor :: fn(
	sensor: ?*Sensor
) #foreign #link="SDL_CloseSensor";

UpdateSensors :: fn() #foreign #link="SDL_UpdateSensors";

struct Joystick {
}

JoystickID :: Uint32;

enum JoystickType: u32 {
	JOYSTICK_TYPE_UNKNOWN = 0x0,
	JOYSTICK_TYPE_GAMEPAD = 0x1,
	JOYSTICK_TYPE_WHEEL = 0x2,
	JOYSTICK_TYPE_ARCADE_STICK = 0x3,
	JOYSTICK_TYPE_FLIGHT_STICK = 0x4,
	JOYSTICK_TYPE_DANCE_PAD = 0x5,
	JOYSTICK_TYPE_GUITAR = 0x6,
	JOYSTICK_TYPE_DRUM_KIT = 0x7,
	JOYSTICK_TYPE_ARCADE_PAD = 0x8,
	JOYSTICK_TYPE_THROTTLE = 0x9,
	JOYSTICK_TYPE_COUNT = 0xa,
}

enum JoystickConnectionState: u32 {
	JOYSTICK_CONNECTION_INVALID = 0xffffffffffffffff,
	JOYSTICK_CONNECTION_UNKNOWN = 0x0,
	JOYSTICK_CONNECTION_WIRED = 0x1,
	JOYSTICK_CONNECTION_WIRELESS = 0x2,
}

LockJoysticks :: fn() #foreign #link="SDL_LockJoysticks";

UnlockJoysticks :: fn() #foreign #link="SDL_UnlockJoysticks";

HasJoystick :: fn() -> bool #foreign #link="SDL_HasJoystick";

GetJoysticks :: fn(
	count: ?*i32
) -> ?*JoystickID #foreign #link="SDL_GetJoysticks";

GetJoystickNameForID :: fn(
	instance_id: JoystickID
) -> ?*u8 #foreign #link="SDL_GetJoystickNameForID";

GetJoystickPathForID :: fn(
	instance_id: JoystickID
) -> ?*u8 #foreign #link="SDL_GetJoystickPathForID";

GetJoystickPlayerIndexForID :: fn(
	instance_id: JoystickID
) -> i32 #foreign #link="SDL_GetJoystickPlayerIndexForID";

GetJoystickGUIDForID :: fn(
	instance_id: JoystickID
) -> GUID #foreign #link="SDL_GetJoystickGUIDForID";

GetJoystickVendorForID :: fn(
	instance_id: JoystickID
) -> Uint16 #foreign #link="SDL_GetJoystickVendorForID";

GetJoystickProductForID :: fn(
	instance_id: JoystickID
) -> Uint16 #foreign #link="SDL_GetJoystickProductForID";

GetJoystickProductVersionForID :: fn(
	instance_id: JoystickID
) -> Uint16 #foreign #link="SDL_GetJoystickProductVersionForID";

GetJoystickTypeForID :: fn(
	instance_id: JoystickID
) -> JoystickType #foreign #link="SDL_GetJoystickTypeForID";

OpenJoystick :: fn(
	instance_id: JoystickID
) -> ?*Joystick #foreign #link="SDL_OpenJoystick";

GetJoystickFromID :: fn(
	instance_id: JoystickID
) -> ?*Joystick #foreign #link="SDL_GetJoystickFromID";

GetJoystickFromPlayerIndex :: fn(
	player_index: i32
) -> ?*Joystick #foreign #link="SDL_GetJoystickFromPlayerIndex";

struct VirtualJoystickTouchpadDesc {
	nfingers: Uint16,
	padding: [3]Uint16,
}

struct VirtualJoystickSensorDesc {
	type: SensorType,
	rate: f32,
}

struct VirtualJoystickDesc {
	version: Uint32,
	type: Uint16,
	padding: Uint16,
	vendor_id: Uint16,
	product_id: Uint16,
	naxes: Uint16,
	nbuttons: Uint16,
	nballs: Uint16,
	nhats: Uint16,
	ntouchpads: Uint16,
	nsensors: Uint16,
	padding2: [2]Uint16,
	button_mask: Uint32,
	axis_mask: Uint32,
	name: ?*u8,
	touchpads: ?*VirtualJoystickTouchpadDesc,
	sensors: ?*VirtualJoystickSensorDesc,
	userdata: ?*,
	Update: ?*fn(a: ?*) #foreign,
	SetPlayerIndex: ?*fn(a: ?*, b: i32) #foreign,
	Rumble: ?*fn(a: ?*, b: Uint16, c: Uint16) -> bool #foreign,
	RumbleTriggers: ?*fn(a: ?*, b: Uint16, c: Uint16) -> bool #foreign,
	SetLED: ?*fn(a: ?*, b: Uint8, c: Uint8, d: Uint8) -> bool #foreign,
	SendEffect: ?*fn(a: ?*, b: ?*, c: i32) -> bool #foreign,
	SetSensorsEnabled: ?*fn(a: ?*, b: bool) -> bool #foreign,
	Cleanup: ?*fn(a: ?*) #foreign,
}

AttachVirtualJoystick :: fn(
	desc: ?*VirtualJoystickDesc
) -> JoystickID #foreign #link="SDL_AttachVirtualJoystick";

DetachVirtualJoystick :: fn(
	instance_id: JoystickID
) -> bool #foreign #link="SDL_DetachVirtualJoystick";

IsJoystickVirtual :: fn(
	instance_id: JoystickID
) -> bool #foreign #link="SDL_IsJoystickVirtual";

SetJoystickVirtualAxis :: fn(
	joystick: ?*Joystick,
	axis: i32,
	value: Sint16
) -> bool #foreign #link="SDL_SetJoystickVirtualAxis";

SetJoystickVirtualBall :: fn(
	joystick: ?*Joystick,
	ball: i32,
	xrel: Sint16,
	yrel: Sint16
) -> bool #foreign #link="SDL_SetJoystickVirtualBall";

SetJoystickVirtualButton :: fn(
	joystick: ?*Joystick,
	button: i32,
	down: bool
) -> bool #foreign #link="SDL_SetJoystickVirtualButton";

SetJoystickVirtualHat :: fn(
	joystick: ?*Joystick,
	hat: i32,
	value: Uint8
) -> bool #foreign #link="SDL_SetJoystickVirtualHat";

SetJoystickVirtualTouchpad :: fn(
	joystick: ?*Joystick,
	touchpad: i32,
	finger: i32,
	down: bool,
	x: f32,
	y: f32,
	pressure: f32
) -> bool #foreign #link="SDL_SetJoystickVirtualTouchpad";

SendJoystickVirtualSensorData :: fn(
	joystick: ?*Joystick,
	type: SensorType,
	sensor_timestamp: Uint64,
	data: ?*f32,
	num_values: i32
) -> bool #foreign #link="SDL_SendJoystickVirtualSensorData";

GetJoystickProperties :: fn(
	joystick: ?*Joystick
) -> PropertiesID #foreign #link="SDL_GetJoystickProperties";

GetJoystickName :: fn(
	joystick: ?*Joystick
) -> ?*u8 #foreign #link="SDL_GetJoystickName";

GetJoystickPath :: fn(
	joystick: ?*Joystick
) -> ?*u8 #foreign #link="SDL_GetJoystickPath";

GetJoystickPlayerIndex :: fn(
	joystick: ?*Joystick
) -> i32 #foreign #link="SDL_GetJoystickPlayerIndex";

SetJoystickPlayerIndex :: fn(
	joystick: ?*Joystick,
	player_index: i32
) -> bool #foreign #link="SDL_SetJoystickPlayerIndex";

GetJoystickGUID :: fn(
	joystick: ?*Joystick
) -> GUID #foreign #link="SDL_GetJoystickGUID";

GetJoystickVendor :: fn(
	joystick: ?*Joystick
) -> Uint16 #foreign #link="SDL_GetJoystickVendor";

GetJoystickProduct :: fn(
	joystick: ?*Joystick
) -> Uint16 #foreign #link="SDL_GetJoystickProduct";

GetJoystickProductVersion :: fn(
	joystick: ?*Joystick
) -> Uint16 #foreign #link="SDL_GetJoystickProductVersion";

GetJoystickFirmwareVersion :: fn(
	joystick: ?*Joystick
) -> Uint16 #foreign #link="SDL_GetJoystickFirmwareVersion";

GetJoystickSerial :: fn(
	joystick: ?*Joystick
) -> ?*u8 #foreign #link="SDL_GetJoystickSerial";

GetJoystickType :: fn(
	joystick: ?*Joystick
) -> JoystickType #foreign #link="SDL_GetJoystickType";

GetJoystickGUIDInfo :: fn(
	guid: GUID,
	vendor: ?*Uint16,
	product: ?*Uint16,
	version: ?*Uint16,
	crc16: ?*Uint16
) #foreign #link="SDL_GetJoystickGUIDInfo";

JoystickConnected :: fn(
	joystick: ?*Joystick
) -> bool #foreign #link="SDL_JoystickConnected";

GetJoystickID :: fn(
	joystick: ?*Joystick
) -> JoystickID #foreign #link="SDL_GetJoystickID";

GetNumJoystickAxes :: fn(
	joystick: ?*Joystick
) -> i32 #foreign #link="SDL_GetNumJoystickAxes";

GetNumJoystickBalls :: fn(
	joystick: ?*Joystick
) -> i32 #foreign #link="SDL_GetNumJoystickBalls";

GetNumJoystickHats :: fn(
	joystick: ?*Joystick
) -> i32 #foreign #link="SDL_GetNumJoystickHats";

GetNumJoystickButtons :: fn(
	joystick: ?*Joystick
) -> i32 #foreign #link="SDL_GetNumJoystickButtons";

SetJoystickEventsEnabled :: fn(
	enabled: bool
) #foreign #link="SDL_SetJoystickEventsEnabled";

JoystickEventsEnabled :: fn() -> bool #foreign #link="SDL_JoystickEventsEnabled";

UpdateJoysticks :: fn() #foreign #link="SDL_UpdateJoysticks";

GetJoystickAxis :: fn(
	joystick: ?*Joystick,
	axis: i32
) -> Sint16 #foreign #link="SDL_GetJoystickAxis";

GetJoystickAxisInitialState :: fn(
	joystick: ?*Joystick,
	axis: i32,
	state: ?*Sint16
) -> bool #foreign #link="SDL_GetJoystickAxisInitialState";

GetJoystickBall :: fn(
	joystick: ?*Joystick,
	ball: i32,
	dx: ?*i32,
	dy: ?*i32
) -> bool #foreign #link="SDL_GetJoystickBall";

GetJoystickHat :: fn(
	joystick: ?*Joystick,
	hat: i32
) -> Uint8 #foreign #link="SDL_GetJoystickHat";

GetJoystickButton :: fn(
	joystick: ?*Joystick,
	button: i32
) -> bool #foreign #link="SDL_GetJoystickButton";

RumbleJoystick :: fn(
	joystick: ?*Joystick,
	low_frequency_rumble: Uint16,
	high_frequency_rumble: Uint16,
	duration_ms: Uint32
) -> bool #foreign #link="SDL_RumbleJoystick";

RumbleJoystickTriggers :: fn(
	joystick: ?*Joystick,
	left_rumble: Uint16,
	right_rumble: Uint16,
	duration_ms: Uint32
) -> bool #foreign #link="SDL_RumbleJoystickTriggers";

SetJoystickLED :: fn(
	joystick: ?*Joystick,
	red: Uint8,
	green: Uint8,
	blue: Uint8
) -> bool #foreign #link="SDL_SetJoystickLED";

SendJoystickEffect :: fn(
	joystick: ?*Joystick,
	data: ?*,
	size: i32
) -> bool #foreign #link="SDL_SendJoystickEffect";

CloseJoystick :: fn(
	joystick: ?*Joystick
) #foreign #link="SDL_CloseJoystick";

GetJoystickConnectionState :: fn(
	joystick: ?*Joystick
) -> JoystickConnectionState #foreign #link="SDL_GetJoystickConnectionState";

GetJoystickPowerInfo :: fn(
	joystick: ?*Joystick,
	percent: ?*i32
) -> PowerState #foreign #link="SDL_GetJoystickPowerInfo";

struct Gamepad {
}

enum GamepadType: u32 {
	GAMEPAD_TYPE_UNKNOWN = 0x0,
	GAMEPAD_TYPE_STANDARD = 0x1,
	GAMEPAD_TYPE_XBOX360 = 0x2,
	GAMEPAD_TYPE_XBOXONE = 0x3,
	GAMEPAD_TYPE_PS3 = 0x4,
	GAMEPAD_TYPE_PS4 = 0x5,
	GAMEPAD_TYPE_PS5 = 0x6,
	GAMEPAD_TYPE_NINTENDO_SWITCH_PRO = 0x7,
	GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_LEFT = 0x8,
	GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT = 0x9,
	GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_PAIR = 0xa,
	GAMEPAD_TYPE_COUNT = 0xb,
}

enum GamepadButton: u64 {
	GAMEPAD_BUTTON_INVALID = 0xffffffffffffffff,
	GAMEPAD_BUTTON_SOUTH = 0x0,
	GAMEPAD_BUTTON_EAST = 0x1,
	GAMEPAD_BUTTON_WEST = 0x2,
	GAMEPAD_BUTTON_NORTH = 0x3,
	GAMEPAD_BUTTON_BACK = 0x4,
	GAMEPAD_BUTTON_GUIDE = 0x5,
	GAMEPAD_BUTTON_START = 0x6,
	GAMEPAD_BUTTON_LEFT_STICK = 0x7,
	GAMEPAD_BUTTON_RIGHT_STICK = 0x8,
	GAMEPAD_BUTTON_LEFT_SHOULDER = 0x9,
	GAMEPAD_BUTTON_RIGHT_SHOULDER = 0xa,
	GAMEPAD_BUTTON_DPAD_UP = 0xb,
	GAMEPAD_BUTTON_DPAD_DOWN = 0xc,
	GAMEPAD_BUTTON_DPAD_LEFT = 0xd,
	GAMEPAD_BUTTON_DPAD_RIGHT = 0xe,
	GAMEPAD_BUTTON_MISC1 = 0xf,
	GAMEPAD_BUTTON_RIGHT_PADDLE1 = 0x10,
	GAMEPAD_BUTTON_LEFT_PADDLE1 = 0x11,
	GAMEPAD_BUTTON_RIGHT_PADDLE2 = 0x12,
	GAMEPAD_BUTTON_LEFT_PADDLE2 = 0x13,
	GAMEPAD_BUTTON_TOUCHPAD = 0x14,
	GAMEPAD_BUTTON_MISC2 = 0x15,
	GAMEPAD_BUTTON_MISC3 = 0x16,
	GAMEPAD_BUTTON_MISC4 = 0x17,
	GAMEPAD_BUTTON_MISC5 = 0x18,
	GAMEPAD_BUTTON_MISC6 = 0x19,
	GAMEPAD_BUTTON_COUNT = 0x1a,
}

enum GamepadButtonLabel: u32 {
	GAMEPAD_BUTTON_LABEL_UNKNOWN = 0x0,
	GAMEPAD_BUTTON_LABEL_A = 0x1,
	GAMEPAD_BUTTON_LABEL_B = 0x2,
	GAMEPAD_BUTTON_LABEL_X = 0x3,
	GAMEPAD_BUTTON_LABEL_Y = 0x4,
	GAMEPAD_BUTTON_LABEL_CROSS = 0x5,
	GAMEPAD_BUTTON_LABEL_CIRCLE = 0x6,
	GAMEPAD_BUTTON_LABEL_SQUARE = 0x7,
	GAMEPAD_BUTTON_LABEL_TRIANGLE = 0x8,
}

enum GamepadAxis: u64 {
	GAMEPAD_AXIS_INVALID = 0xffffffffffffffff,
	GAMEPAD_AXIS_LEFTX = 0x0,
	GAMEPAD_AXIS_LEFTY = 0x1,
	GAMEPAD_AXIS_RIGHTX = 0x2,
	GAMEPAD_AXIS_RIGHTY = 0x3,
	GAMEPAD_AXIS_LEFT_TRIGGER = 0x4,
	GAMEPAD_AXIS_RIGHT_TRIGGER = 0x5,
	GAMEPAD_AXIS_COUNT = 0x6,
}

enum GamepadBindingType: u32 {
	GAMEPAD_BINDTYPE_NONE = 0x0,
	GAMEPAD_BINDTYPE_BUTTON = 0x1,
	GAMEPAD_BINDTYPE_AXIS = 0x2,
	GAMEPAD_BINDTYPE_HAT = 0x3,
}

struct GamepadBinding {
	input_type: GamepadBindingType,
	input: union {
		button: i32,
		axis: struct {
			axis: i32,
			axis_min: i32,
			axis_max: i32,
		},
		hat: struct {
			hat: i32,
			hat_mask: i32,
		},
	},
	output_type: GamepadBindingType,
	output: union {
		button: GamepadButton,
		axis: struct {
			axis: GamepadAxis,
			axis_min: i32,
			axis_max: i32,
		},
	},
}

AddGamepadMapping :: fn(
	mapping: ?*u8
) -> i32 #foreign #link="SDL_AddGamepadMapping";

AddGamepadMappingsFromIO :: fn(
	src: ?*IOStream,
	closeio: bool
) -> i32 #foreign #link="SDL_AddGamepadMappingsFromIO";

AddGamepadMappingsFromFile :: fn(
	file: ?*u8
) -> i32 #foreign #link="SDL_AddGamepadMappingsFromFile";

ReloadGamepadMappings :: fn() -> bool #foreign #link="SDL_ReloadGamepadMappings";

GetGamepadMappings :: fn(
	count: ?*i32
) -> ?*?*u8 #foreign #link="SDL_GetGamepadMappings";

GetGamepadMappingForGUID :: fn(
	guid: GUID
) -> ?*u8 #foreign #link="SDL_GetGamepadMappingForGUID";

GetGamepadMapping :: fn(
	gamepad: ?*Gamepad
) -> ?*u8 #foreign #link="SDL_GetGamepadMapping";

SetGamepadMapping :: fn(
	instance_id: JoystickID,
	mapping: ?*u8
) -> bool #foreign #link="SDL_SetGamepadMapping";

HasGamepad :: fn() -> bool #foreign #link="SDL_HasGamepad";

GetGamepads :: fn(
	count: ?*i32
) -> ?*JoystickID #foreign #link="SDL_GetGamepads";

IsGamepad :: fn(
	instance_id: JoystickID
) -> bool #foreign #link="SDL_IsGamepad";

GetGamepadNameForID :: fn(
	instance_id: JoystickID
) -> ?*u8 #foreign #link="SDL_GetGamepadNameForID";

GetGamepadPathForID :: fn(
	instance_id: JoystickID
) -> ?*u8 #foreign #link="SDL_GetGamepadPathForID";

GetGamepadPlayerIndexForID :: fn(
	instance_id: JoystickID
) -> i32 #foreign #link="SDL_GetGamepadPlayerIndexForID";

GetGamepadGUIDForID :: fn(
	instance_id: JoystickID
) -> GUID #foreign #link="SDL_GetGamepadGUIDForID";

GetGamepadVendorForID :: fn(
	instance_id: JoystickID
) -> Uint16 #foreign #link="SDL_GetGamepadVendorForID";

GetGamepadProductForID :: fn(
	instance_id: JoystickID
) -> Uint16 #foreign #link="SDL_GetGamepadProductForID";

GetGamepadProductVersionForID :: fn(
	instance_id: JoystickID
) -> Uint16 #foreign #link="SDL_GetGamepadProductVersionForID";

GetGamepadTypeForID :: fn(
	instance_id: JoystickID
) -> GamepadType #foreign #link="SDL_GetGamepadTypeForID";

GetRealGamepadTypeForID :: fn(
	instance_id: JoystickID
) -> GamepadType #foreign #link="SDL_GetRealGamepadTypeForID";

GetGamepadMappingForID :: fn(
	instance_id: JoystickID
) -> ?*u8 #foreign #link="SDL_GetGamepadMappingForID";

OpenGamepad :: fn(
	instance_id: JoystickID
) -> ?*Gamepad #foreign #link="SDL_OpenGamepad";

GetGamepadFromID :: fn(
	instance_id: JoystickID
) -> ?*Gamepad #foreign #link="SDL_GetGamepadFromID";

GetGamepadFromPlayerIndex :: fn(
	player_index: i32
) -> ?*Gamepad #foreign #link="SDL_GetGamepadFromPlayerIndex";

GetGamepadProperties :: fn(
	gamepad: ?*Gamepad
) -> PropertiesID #foreign #link="SDL_GetGamepadProperties";

GetGamepadID :: fn(
	gamepad: ?*Gamepad
) -> JoystickID #foreign #link="SDL_GetGamepadID";

GetGamepadName :: fn(
	gamepad: ?*Gamepad
) -> ?*u8 #foreign #link="SDL_GetGamepadName";

GetGamepadPath :: fn(
	gamepad: ?*Gamepad
) -> ?*u8 #foreign #link="SDL_GetGamepadPath";

GetGamepadType :: fn(
	gamepad: ?*Gamepad
) -> GamepadType #foreign #link="SDL_GetGamepadType";

GetRealGamepadType :: fn(
	gamepad: ?*Gamepad
) -> GamepadType #foreign #link="SDL_GetRealGamepadType";

GetGamepadPlayerIndex :: fn(
	gamepad: ?*Gamepad
) -> i32 #foreign #link="SDL_GetGamepadPlayerIndex";

SetGamepadPlayerIndex :: fn(
	gamepad: ?*Gamepad,
	player_index: i32
) -> bool #foreign #link="SDL_SetGamepadPlayerIndex";

GetGamepadVendor :: fn(
	gamepad: ?*Gamepad
) -> Uint16 #foreign #link="SDL_GetGamepadVendor";

GetGamepadProduct :: fn(
	gamepad: ?*Gamepad
) -> Uint16 #foreign #link="SDL_GetGamepadProduct";

GetGamepadProductVersion :: fn(
	gamepad: ?*Gamepad
) -> Uint16 #foreign #link="SDL_GetGamepadProductVersion";

GetGamepadFirmwareVersion :: fn(
	gamepad: ?*Gamepad
) -> Uint16 #foreign #link="SDL_GetGamepadFirmwareVersion";

GetGamepadSerial :: fn(
	gamepad: ?*Gamepad
) -> ?*u8 #foreign #link="SDL_GetGamepadSerial";

GetGamepadSteamHandle :: fn(
	gamepad: ?*Gamepad
) -> Uint64 #foreign #link="SDL_GetGamepadSteamHandle";

GetGamepadConnectionState :: fn(
	gamepad: ?*Gamepad
) -> JoystickConnectionState #foreign #link="SDL_GetGamepadConnectionState";

GetGamepadPowerInfo :: fn(
	gamepad: ?*Gamepad,
	percent: ?*i32
) -> PowerState #foreign #link="SDL_GetGamepadPowerInfo";

GamepadConnected :: fn(
	gamepad: ?*Gamepad
) -> bool #foreign #link="SDL_GamepadConnected";

GetGamepadJoystick :: fn(
	gamepad: ?*Gamepad
) -> ?*Joystick #foreign #link="SDL_GetGamepadJoystick";

SetGamepadEventsEnabled :: fn(
	enabled: bool
) #foreign #link="SDL_SetGamepadEventsEnabled";

GamepadEventsEnabled :: fn() -> bool #foreign #link="SDL_GamepadEventsEnabled";

GetGamepadBindings :: fn(
	gamepad: ?*Gamepad,
	count: ?*i32
) -> ?*?*GamepadBinding #foreign #link="SDL_GetGamepadBindings";

UpdateGamepads :: fn() #foreign #link="SDL_UpdateGamepads";

GetGamepadTypeFromString :: fn(
	str: ?*u8
) -> GamepadType #foreign #link="SDL_GetGamepadTypeFromString";

GetGamepadStringForType :: fn(
	type: GamepadType
) -> ?*u8 #foreign #link="SDL_GetGamepadStringForType";

GetGamepadAxisFromString :: fn(
	str: ?*u8
) -> GamepadAxis #foreign #link="SDL_GetGamepadAxisFromString";

GetGamepadStringForAxis :: fn(
	axis: GamepadAxis
) -> ?*u8 #foreign #link="SDL_GetGamepadStringForAxis";

GamepadHasAxis :: fn(
	gamepad: ?*Gamepad,
	axis: GamepadAxis
) -> bool #foreign #link="SDL_GamepadHasAxis";

GetGamepadAxis :: fn(
	gamepad: ?*Gamepad,
	axis: GamepadAxis
) -> Sint16 #foreign #link="SDL_GetGamepadAxis";

GetGamepadButtonFromString :: fn(
	str: ?*u8
) -> GamepadButton #foreign #link="SDL_GetGamepadButtonFromString";

GetGamepadStringForButton :: fn(
	button: GamepadButton
) -> ?*u8 #foreign #link="SDL_GetGamepadStringForButton";

GamepadHasButton :: fn(
	gamepad: ?*Gamepad,
	button: GamepadButton
) -> bool #foreign #link="SDL_GamepadHasButton";

GetGamepadButton :: fn(
	gamepad: ?*Gamepad,
	button: GamepadButton
) -> bool #foreign #link="SDL_GetGamepadButton";

GetGamepadButtonLabelForType :: fn(
	type: GamepadType,
	button: GamepadButton
) -> GamepadButtonLabel #foreign #link="SDL_GetGamepadButtonLabelForType";

GetGamepadButtonLabel :: fn(
	gamepad: ?*Gamepad,
	button: GamepadButton
) -> GamepadButtonLabel #foreign #link="SDL_GetGamepadButtonLabel";

GetNumGamepadTouchpads :: fn(
	gamepad: ?*Gamepad
) -> i32 #foreign #link="SDL_GetNumGamepadTouchpads";

GetNumGamepadTouchpadFingers :: fn(
	gamepad: ?*Gamepad,
	touchpad: i32
) -> i32 #foreign #link="SDL_GetNumGamepadTouchpadFingers";

GetGamepadTouchpadFinger :: fn(
	gamepad: ?*Gamepad,
	touchpad: i32,
	finger: i32,
	down: ?*bool,
	x: ?*f32,
	y: ?*f32,
	pressure: ?*f32
) -> bool #foreign #link="SDL_GetGamepadTouchpadFinger";

GamepadHasSensor :: fn(
	gamepad: ?*Gamepad,
	type: SensorType
) -> bool #foreign #link="SDL_GamepadHasSensor";

SetGamepadSensorEnabled :: fn(
	gamepad: ?*Gamepad,
	type: SensorType,
	enabled: bool
) -> bool #foreign #link="SDL_SetGamepadSensorEnabled";

GamepadSensorEnabled :: fn(
	gamepad: ?*Gamepad,
	type: SensorType
) -> bool #foreign #link="SDL_GamepadSensorEnabled";

GetGamepadSensorDataRate :: fn(
	gamepad: ?*Gamepad,
	type: SensorType
) -> f32 #foreign #link="SDL_GetGamepadSensorDataRate";

GetGamepadSensorData :: fn(
	gamepad: ?*Gamepad,
	type: SensorType,
	data: ?*f32,
	num_values: i32
) -> bool #foreign #link="SDL_GetGamepadSensorData";

RumbleGamepad :: fn(
	gamepad: ?*Gamepad,
	low_frequency_rumble: Uint16,
	high_frequency_rumble: Uint16,
	duration_ms: Uint32
) -> bool #foreign #link="SDL_RumbleGamepad";

RumbleGamepadTriggers :: fn(
	gamepad: ?*Gamepad,
	left_rumble: Uint16,
	right_rumble: Uint16,
	duration_ms: Uint32
) -> bool #foreign #link="SDL_RumbleGamepadTriggers";

SetGamepadLED :: fn(
	gamepad: ?*Gamepad,
	red: Uint8,
	green: Uint8,
	blue: Uint8
) -> bool #foreign #link="SDL_SetGamepadLED";

SendGamepadEffect :: fn(
	gamepad: ?*Gamepad,
	data: ?*,
	size: i32
) -> bool #foreign #link="SDL_SendGamepadEffect";

CloseGamepad :: fn(
	gamepad: ?*Gamepad
) #foreign #link="SDL_CloseGamepad";

GetGamepadAppleSFSymbolsNameForButton :: fn(
	gamepad: ?*Gamepad,
	button: GamepadButton
) -> ?*u8 #foreign #link="SDL_GetGamepadAppleSFSymbolsNameForButton";

GetGamepadAppleSFSymbolsNameForAxis :: fn(
	gamepad: ?*Gamepad,
	axis: GamepadAxis
) -> ?*u8 #foreign #link="SDL_GetGamepadAppleSFSymbolsNameForAxis";

enum Scancode: u32 {
	UNKNOWN = 0x0,
	A = 0x4,
	B = 0x5,
	C = 0x6,
	D = 0x7,
	E = 0x8,
	F = 0x9,
	G = 0xa,
	H = 0xb,
	I = 0xc,
	J = 0xd,
	K = 0xe,
	L = 0xf,
	M = 0x10,
	N = 0x11,
	O = 0x12,
	P = 0x13,
	Q = 0x14,
	R = 0x15,
	S = 0x16,
	T = 0x17,
	U = 0x18,
	V = 0x19,
	W = 0x1a,
	X = 0x1b,
	Y = 0x1c,
	Z = 0x1d,
	_1 = 0x1e,
	_2 = 0x1f,
	_3 = 0x20,
	_4 = 0x21,
	_5 = 0x22,
	_6 = 0x23,
	_7 = 0x24,
	_8 = 0x25,
	_9 = 0x26,
	_0 = 0x27,
	RETURN = 0x28,
	ESCAPE = 0x29,
	BACKSPACE = 0x2a,
	TAB = 0x2b,
	SPACE = 0x2c,
	MINUS = 0x2d,
	EQUALS = 0x2e,
	LEFTBRACKET = 0x2f,
	RIGHTBRACKET = 0x30,
	BACKSLASH = 0x31,
	NONUSHASH = 0x32,
	SEMICOLON = 0x33,
	APOSTROPHE = 0x34,
	GRAVE = 0x35,
	COMMA = 0x36,
	PERIOD = 0x37,
	SLASH = 0x38,
	CAPSLOCK = 0x39,
	F1 = 0x3a,
	F2 = 0x3b,
	F3 = 0x3c,
	F4 = 0x3d,
	F5 = 0x3e,
	F6 = 0x3f,
	F7 = 0x40,
	F8 = 0x41,
	F9 = 0x42,
	F10 = 0x43,
	F11 = 0x44,
	F12 = 0x45,
	PRINTSCREEN = 0x46,
	SCROLLLOCK = 0x47,
	PAUSE = 0x48,
	INSERT = 0x49,
	HOME = 0x4a,
	PAGEUP = 0x4b,
	DELETE = 0x4c,
	END = 0x4d,
	PAGEDOWN = 0x4e,
	RIGHT = 0x4f,
	LEFT = 0x50,
	DOWN = 0x51,
	UP = 0x52,
	NUMLOCKCLEAR = 0x53,
	KP_DIVIDE = 0x54,
	KP_MULTIPLY = 0x55,
	KP_MINUS = 0x56,
	KP_PLUS = 0x57,
	KP_ENTER = 0x58,
	KP_1 = 0x59,
	KP_2 = 0x5a,
	KP_3 = 0x5b,
	KP_4 = 0x5c,
	KP_5 = 0x5d,
	KP_6 = 0x5e,
	KP_7 = 0x5f,
	KP_8 = 0x60,
	KP_9 = 0x61,
	KP_0 = 0x62,
	KP_PERIOD = 0x63,
	NONUSBACKSLASH = 0x64,
	APPLICATION = 0x65,
	POWER = 0x66,
	KP_EQUALS = 0x67,
	F13 = 0x68,
	F14 = 0x69,
	F15 = 0x6a,
	F16 = 0x6b,
	F17 = 0x6c,
	F18 = 0x6d,
	F19 = 0x6e,
	F20 = 0x6f,
	F21 = 0x70,
	F22 = 0x71,
	F23 = 0x72,
	F24 = 0x73,
	EXECUTE = 0x74,
	HELP = 0x75,
	MENU = 0x76,
	SELECT = 0x77,
	STOP = 0x78,
	AGAIN = 0x79,
	UNDO = 0x7a,
	CUT = 0x7b,
	COPY = 0x7c,
	PASTE = 0x7d,
	FIND = 0x7e,
	MUTE = 0x7f,
	VOLUMEUP = 0x80,
	VOLUMEDOWN = 0x81,
	KP_COMMA = 0x85,
	KP_EQUALSAS400 = 0x86,
	INTERNATIONAL1 = 0x87,
	INTERNATIONAL2 = 0x88,
	INTERNATIONAL3 = 0x89,
	INTERNATIONAL4 = 0x8a,
	INTERNATIONAL5 = 0x8b,
	INTERNATIONAL6 = 0x8c,
	INTERNATIONAL7 = 0x8d,
	INTERNATIONAL8 = 0x8e,
	INTERNATIONAL9 = 0x8f,
	LANG1 = 0x90,
	LANG2 = 0x91,
	LANG3 = 0x92,
	LANG4 = 0x93,
	LANG5 = 0x94,
	LANG6 = 0x95,
	LANG7 = 0x96,
	LANG8 = 0x97,
	LANG9 = 0x98,
	ALTERASE = 0x99,
	SYSREQ = 0x9a,
	CANCEL = 0x9b,
	CLEAR = 0x9c,
	PRIOR = 0x9d,
	RETURN2 = 0x9e,
	SEPARATOR = 0x9f,
	OUT = 0xa0,
	OPER = 0xa1,
	CLEARAGAIN = 0xa2,
	CRSEL = 0xa3,
	EXSEL = 0xa4,
	KP_00 = 0xb0,
	KP_000 = 0xb1,
	THOUSANDSSEPARATOR = 0xb2,
	DECIMALSEPARATOR = 0xb3,
	CURRENCYUNIT = 0xb4,
	CURRENCYSUBUNIT = 0xb5,
	KP_LEFTPAREN = 0xb6,
	KP_RIGHTPAREN = 0xb7,
	KP_LEFTBRACE = 0xb8,
	KP_RIGHTBRACE = 0xb9,
	KP_TAB = 0xba,
	KP_BACKSPACE = 0xbb,
	KP_A = 0xbc,
	KP_B = 0xbd,
	KP_C = 0xbe,
	KP_D = 0xbf,
	KP_E = 0xc0,
	KP_F = 0xc1,
	KP_XOR = 0xc2,
	KP_POWER = 0xc3,
	KP_PERCENT = 0xc4,
	KP_LESS = 0xc5,
	KP_GREATER = 0xc6,
	KP_AMPERSAND = 0xc7,
	KP_DBLAMPERSAND = 0xc8,
	KP_VERTICALBAR = 0xc9,
	KP_DBLVERTICALBAR = 0xca,
	KP_COLON = 0xcb,
	KP_HASH = 0xcc,
	KP_SPACE = 0xcd,
	KP_AT = 0xce,
	KP_EXCLAM = 0xcf,
	KP_MEMSTORE = 0xd0,
	KP_MEMRECALL = 0xd1,
	KP_MEMCLEAR = 0xd2,
	KP_MEMADD = 0xd3,
	KP_MEMSUBTRACT = 0xd4,
	KP_MEMMULTIPLY = 0xd5,
	KP_MEMDIVIDE = 0xd6,
	KP_PLUSMINUS = 0xd7,
	KP_CLEAR = 0xd8,
	KP_CLEARENTRY = 0xd9,
	KP_BINARY = 0xda,
	KP_OCTAL = 0xdb,
	KP_DECIMAL = 0xdc,
	KP_HEXADECIMAL = 0xdd,
	LCTRL = 0xe0,
	LSHIFT = 0xe1,
	LALT = 0xe2,
	LGUI = 0xe3,
	RCTRL = 0xe4,
	RSHIFT = 0xe5,
	RALT = 0xe6,
	RGUI = 0xe7,
	MODE = 0x101,
	SLEEP = 0x102,
	WAKE = 0x103,
	CHANNEL_INCREMENT = 0x104,
	CHANNEL_DECREMENT = 0x105,
	MEDIA_PLAY = 0x106,
	MEDIA_PAUSE = 0x107,
	MEDIA_RECORD = 0x108,
	MEDIA_FAST_FORWARD = 0x109,
	MEDIA_REWIND = 0x10a,
	MEDIA_NEXT_TRACK = 0x10b,
	MEDIA_PREVIOUS_TRACK = 0x10c,
	MEDIA_STOP = 0x10d,
	MEDIA_EJECT = 0x10e,
	MEDIA_PLAY_PAUSE = 0x10f,
	MEDIA_SELECT = 0x110,
	AC_NEW = 0x111,
	AC_OPEN = 0x112,
	AC_CLOSE = 0x113,
	AC_EXIT = 0x114,
	AC_SAVE = 0x115,
	AC_PRINT = 0x116,
	AC_PROPERTIES = 0x117,
	AC_SEARCH = 0x118,
	AC_HOME = 0x119,
	AC_BACK = 0x11a,
	AC_FORWARD = 0x11b,
	AC_STOP = 0x11c,
	AC_REFRESH = 0x11d,
	AC_BOOKMARKS = 0x11e,
	SOFTLEFT = 0x11f,
	SOFTRIGHT = 0x120,
	CALL = 0x121,
	ENDCALL = 0x122,
	RESERVED = 0x190,
	COUNT = 0x200,
}

Keycode :: Uint32;

Keymod :: Uint16;

KeyboardID :: Uint32;

HasKeyboard :: fn() -> bool #foreign #link="SDL_HasKeyboard";

GetKeyboards :: fn(
	count: ?*i32
) -> ?*KeyboardID #foreign #link="SDL_GetKeyboards";

GetKeyboardNameForID :: fn(
	instance_id: KeyboardID
) -> ?*u8 #foreign #link="SDL_GetKeyboardNameForID";

GetKeyboardFocus :: fn() -> ?*Window #foreign #link="SDL_GetKeyboardFocus";

GetKeyboardState :: fn(
	numkeys: ?*i32
) -> ?*bool #foreign #link="SDL_GetKeyboardState";

ResetKeyboard :: fn() #foreign #link="SDL_ResetKeyboard";

GetModState :: fn() -> Keymod #foreign #link="SDL_GetModState";

SetModState :: fn(
	modstate: Keymod
) #foreign #link="SDL_SetModState";

GetKeyFromScancode :: fn(
	scancode: Scancode,
	modstate: Keymod,
	key_event: bool
) -> Keycode #foreign #link="SDL_GetKeyFromScancode";

GetScancodeFromKey :: fn(
	key: Keycode,
	modstate: ?*Keymod
) -> Scancode #foreign #link="SDL_GetScancodeFromKey";

SetScancodeName :: fn(
	scancode: Scancode,
	name: ?*u8
) -> bool #foreign #link="SDL_SetScancodeName";

GetScancodeName :: fn(
	scancode: Scancode
) -> ?*u8 #foreign #link="SDL_GetScancodeName";

GetScancodeFromName :: fn(
	name: ?*u8
) -> Scancode #foreign #link="SDL_GetScancodeFromName";

GetKeyName :: fn(
	key: Keycode
) -> ?*u8 #foreign #link="SDL_GetKeyName";

GetKeyFromName :: fn(
	name: ?*u8
) -> Keycode #foreign #link="SDL_GetKeyFromName";

StartTextInput :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_StartTextInput";

enum TextInputType: u32 {
	TEXTINPUT_TYPE_TEXT = 0x0,
	TEXTINPUT_TYPE_TEXT_NAME = 0x1,
	TEXTINPUT_TYPE_TEXT_EMAIL = 0x2,
	TEXTINPUT_TYPE_TEXT_USERNAME = 0x3,
	TEXTINPUT_TYPE_TEXT_PASSWORD_HIDDEN = 0x4,
	TEXTINPUT_TYPE_TEXT_PASSWORD_VISIBLE = 0x5,
	TEXTINPUT_TYPE_NUMBER = 0x6,
	TEXTINPUT_TYPE_NUMBER_PASSWORD_HIDDEN = 0x7,
	TEXTINPUT_TYPE_NUMBER_PASSWORD_VISIBLE = 0x8,
}

enum Capitalization: u32 {
	CAPITALIZE_NONE = 0x0,
	CAPITALIZE_SENTENCES = 0x1,
	CAPITALIZE_WORDS = 0x2,
	CAPITALIZE_LETTERS = 0x3,
}

StartTextInputWithProperties :: fn(
	window: ?*Window,
	props: PropertiesID
) -> bool #foreign #link="SDL_StartTextInputWithProperties";

TextInputActive :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_TextInputActive";

StopTextInput :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_StopTextInput";

ClearComposition :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_ClearComposition";

SetTextInputArea :: fn(
	window: ?*Window,
	rect: ?*Rect,
	cursor: i32
) -> bool #foreign #link="SDL_SetTextInputArea";

GetTextInputArea :: fn(
	window: ?*Window,
	rect: ?*Rect,
	cursor: ?*i32
) -> bool #foreign #link="SDL_GetTextInputArea";

HasScreenKeyboardSupport :: fn() -> bool #foreign #link="SDL_HasScreenKeyboardSupport";

ScreenKeyboardShown :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_ScreenKeyboardShown";

MouseID :: Uint32;

struct Cursor {
}

enum SystemCursor: u32 {
	SYSTEM_CURSOR_DEFAULT = 0x0,
	SYSTEM_CURSOR_TEXT = 0x1,
	SYSTEM_CURSOR_WAIT = 0x2,
	SYSTEM_CURSOR_CROSSHAIR = 0x3,
	SYSTEM_CURSOR_PROGRESS = 0x4,
	SYSTEM_CURSOR_NWSE_RESIZE = 0x5,
	SYSTEM_CURSOR_NESW_RESIZE = 0x6,
	SYSTEM_CURSOR_EW_RESIZE = 0x7,
	SYSTEM_CURSOR_NS_RESIZE = 0x8,
	SYSTEM_CURSOR_MOVE = 0x9,
	SYSTEM_CURSOR_NOT_ALLOWED = 0xa,
	SYSTEM_CURSOR_POINTER = 0xb,
	SYSTEM_CURSOR_NW_RESIZE = 0xc,
	SYSTEM_CURSOR_N_RESIZE = 0xd,
	SYSTEM_CURSOR_NE_RESIZE = 0xe,
	SYSTEM_CURSOR_E_RESIZE = 0xf,
	SYSTEM_CURSOR_SE_RESIZE = 0x10,
	SYSTEM_CURSOR_S_RESIZE = 0x11,
	SYSTEM_CURSOR_SW_RESIZE = 0x12,
	SYSTEM_CURSOR_W_RESIZE = 0x13,
	SYSTEM_CURSOR_COUNT = 0x14,
}

enum MouseWheelDirection: u32 {
	MOUSEWHEEL_NORMAL = 0x0,
	MOUSEWHEEL_FLIPPED = 0x1,
}

MouseButtonFlags :: Uint32;

HasMouse :: fn() -> bool #foreign #link="SDL_HasMouse";

GetMice :: fn(
	count: ?*i32
) -> ?*MouseID #foreign #link="SDL_GetMice";

GetMouseNameForID :: fn(
	instance_id: MouseID
) -> ?*u8 #foreign #link="SDL_GetMouseNameForID";

GetMouseFocus :: fn() -> ?*Window #foreign #link="SDL_GetMouseFocus";

GetMouseState :: fn(
	x: ?*f32,
	y: ?*f32
) -> MouseButtonFlags #foreign #link="SDL_GetMouseState";

GetGlobalMouseState :: fn(
	x: ?*f32,
	y: ?*f32
) -> MouseButtonFlags #foreign #link="SDL_GetGlobalMouseState";

GetRelativeMouseState :: fn(
	x: ?*f32,
	y: ?*f32
) -> MouseButtonFlags #foreign #link="SDL_GetRelativeMouseState";

WarpMouseInWindow :: fn(
	window: ?*Window,
	x: f32,
	y: f32
) #foreign #link="SDL_WarpMouseInWindow";

WarpMouseGlobal :: fn(
	x: f32,
	y: f32
) -> bool #foreign #link="SDL_WarpMouseGlobal";

SetWindowRelativeMouseMode :: fn(
	window: ?*Window,
	enabled: bool
) -> bool #foreign #link="SDL_SetWindowRelativeMouseMode";

GetWindowRelativeMouseMode :: fn(
	window: ?*Window
) -> bool #foreign #link="SDL_GetWindowRelativeMouseMode";

CaptureMouse :: fn(
	enabled: bool
) -> bool #foreign #link="SDL_CaptureMouse";

CreateCursor :: fn(
	data: ?*Uint8,
	mask: ?*Uint8,
	w: i32,
	h: i32,
	hot_x: i32,
	hot_y: i32
) -> ?*Cursor #foreign #link="SDL_CreateCursor";

CreateColorCursor :: fn(
	surface: ?*Surface,
	hot_x: i32,
	hot_y: i32
) -> ?*Cursor #foreign #link="SDL_CreateColorCursor";

CreateSystemCursor :: fn(
	id: SystemCursor
) -> ?*Cursor #foreign #link="SDL_CreateSystemCursor";

SetCursor :: fn(
	cursor: ?*Cursor
) -> bool #foreign #link="SDL_SetCursor";

GetCursor :: fn() -> ?*Cursor #foreign #link="SDL_GetCursor";

GetDefaultCursor :: fn() -> ?*Cursor #foreign #link="SDL_GetDefaultCursor";

DestroyCursor :: fn(
	cursor: ?*Cursor
) #foreign #link="SDL_DestroyCursor";

ShowCursor :: fn() -> bool #foreign #link="SDL_ShowCursor";

HideCursor :: fn() -> bool #foreign #link="SDL_HideCursor";

CursorVisible :: fn() -> bool #foreign #link="SDL_CursorVisible";

TouchID :: Uint64;

FingerID :: Uint64;

enum TouchDeviceType: u64 {
	TOUCH_DEVICE_INVALID = 0xffffffffffffffff,
	TOUCH_DEVICE_DIRECT = 0x0,
	TOUCH_DEVICE_INDIRECT_ABSOLUTE = 0x1,
	TOUCH_DEVICE_INDIRECT_RELATIVE = 0x2,
}

struct Finger {
	id: FingerID,
	x: f32,
	y: f32,
	pressure: f32,
}

GetTouchDevices :: fn(
	count: ?*i32
) -> ?*TouchID #foreign #link="SDL_GetTouchDevices";

GetTouchDeviceName :: fn(
	touchID: TouchID
) -> ?*u8 #foreign #link="SDL_GetTouchDeviceName";

GetTouchDeviceType :: fn(
	touchID: TouchID
) -> TouchDeviceType #foreign #link="SDL_GetTouchDeviceType";

GetTouchFingers :: fn(
	touchID: TouchID,
	count: ?*i32
) -> ?*?*Finger #foreign #link="SDL_GetTouchFingers";

PenID :: Uint32;

PenInputFlags :: Uint32;

enum PenAxis: u32 {
	PEN_AXIS_PRESSURE = 0x0,
	PEN_AXIS_XTILT = 0x1,
	PEN_AXIS_YTILT = 0x2,
	PEN_AXIS_DISTANCE = 0x3,
	PEN_AXIS_ROTATION = 0x4,
	PEN_AXIS_SLIDER = 0x5,
	PEN_AXIS_TANGENTIAL_PRESSURE = 0x6,
	PEN_AXIS_COUNT = 0x7,
}

enum EventType: u32 {
	FIRST = 0x0,
	QUIT = 0x100,
	TERMINATING = 0x101,
	LOW_MEMORY = 0x102,
	WILL_ENTER_BACKGROUND = 0x103,
	DID_ENTER_BACKGROUND = 0x104,
	WILL_ENTER_FOREGROUND = 0x105,
	DID_ENTER_FOREGROUND = 0x106,
	LOCALE_CHANGED = 0x107,
	SYSTEM_THEME_CHANGED = 0x108,
	DISPLAY_ORIENTATION = 0x151,
	DISPLAY_ADDED = 0x152,
	DISPLAY_REMOVED = 0x153,
	DISPLAY_MOVED = 0x154,
	DISPLAY_DESKTOP_MODE_CHANGED = 0x155,
	DISPLAY_CURRENT_MODE_CHANGED = 0x156,
	DISPLAY_CONTENT_SCALE_CHANGED = 0x157,
	DISPLAY_FIRST = 0x151,
	DISPLAY_LAST = 0x157,
	WINDOW_SHOWN = 0x202,
	WINDOW_HIDDEN = 0x203,
	WINDOW_EXPOSED = 0x204,
	WINDOW_MOVED = 0x205,
	WINDOW_RESIZED = 0x206,
	WINDOW_PIXEL_SIZE_CHANGED = 0x207,
	WINDOW_METAL_VIEW_RESIZED = 0x208,
	WINDOW_MINIMIZED = 0x209,
	WINDOW_MAXIMIZED = 0x20a,
	WINDOW_RESTORED = 0x20b,
	WINDOW_MOUSE_ENTER = 0x20c,
	WINDOW_MOUSE_LEAVE = 0x20d,
	WINDOW_FOCUS_GAINED = 0x20e,
	WINDOW_FOCUS_LOST = 0x20f,
	WINDOW_CLOSE_REQUESTED = 0x210,
	WINDOW_HIT_TEST = 0x211,
	WINDOW_ICCPROF_CHANGED = 0x212,
	WINDOW_DISPLAY_CHANGED = 0x213,
	WINDOW_DISPLAY_SCALE_CHANGED = 0x214,
	WINDOW_SAFE_AREA_CHANGED = 0x215,
	WINDOW_OCCLUDED = 0x216,
	WINDOW_ENTER_FULLSCREEN = 0x217,
	WINDOW_LEAVE_FULLSCREEN = 0x218,
	WINDOW_DESTROYED = 0x219,
	WINDOW_HDR_STATE_CHANGED = 0x21a,
	WINDOW_FIRST = 0x202,
	WINDOW_LAST = 0x21a,
	KEY_DOWN = 0x300,
	KEY_UP = 0x301,
	TEXT_EDITING = 0x302,
	TEXT_INPUT = 0x303,
	KEYMAP_CHANGED = 0x304,
	KEYBOARD_ADDED = 0x305,
	KEYBOARD_REMOVED = 0x306,
	TEXT_EDITING_CANDIDATES = 0x307,
	MOUSE_MOTION = 0x400,
	MOUSE_BUTTON_DOWN = 0x401,
	MOUSE_BUTTON_UP = 0x402,
	MOUSE_WHEEL = 0x403,
	MOUSE_ADDED = 0x404,
	MOUSE_REMOVED = 0x405,
	JOYSTICK_AXIS_MOTION = 0x600,
	JOYSTICK_BALL_MOTION = 0x601,
	JOYSTICK_HAT_MOTION = 0x602,
	JOYSTICK_BUTTON_DOWN = 0x603,
	JOYSTICK_BUTTON_UP = 0x604,
	JOYSTICK_ADDED = 0x605,
	JOYSTICK_REMOVED = 0x606,
	JOYSTICK_BATTERY_UPDATED = 0x607,
	JOYSTICK_UPDATE_COMPLETE = 0x608,
	GAMEPAD_AXIS_MOTION = 0x650,
	GAMEPAD_BUTTON_DOWN = 0x651,
	GAMEPAD_BUTTON_UP = 0x652,
	GAMEPAD_ADDED = 0x653,
	GAMEPAD_REMOVED = 0x654,
	GAMEPAD_REMAPPED = 0x655,
	GAMEPAD_TOUCHPAD_DOWN = 0x656,
	GAMEPAD_TOUCHPAD_MOTION = 0x657,
	GAMEPAD_TOUCHPAD_UP = 0x658,
	GAMEPAD_SENSOR_UPDATE = 0x659,
	GAMEPAD_UPDATE_COMPLETE = 0x65a,
	GAMEPAD_STEAM_HANDLE_UPDATED = 0x65b,
	FINGER_DOWN = 0x700,
	FINGER_UP = 0x701,
	FINGER_MOTION = 0x702,
	FINGER_CANCELED = 0x703,
	CLIPBOARD_UPDATE = 0x900,
	DROP_FILE = 0x1000,
	DROP_TEXT = 0x1001,
	DROP_BEGIN = 0x1002,
	DROP_COMPLETE = 0x1003,
	DROP_POSITION = 0x1004,
	AUDIO_DEVICE_ADDED = 0x1100,
	AUDIO_DEVICE_REMOVED = 0x1101,
	AUDIO_DEVICE_FORMAT_CHANGED = 0x1102,
	SENSOR_UPDATE = 0x1200,
	PEN_PROXIMITY_IN = 0x1300,
	PEN_PROXIMITY_OUT = 0x1301,
	PEN_DOWN = 0x1302,
	PEN_UP = 0x1303,
	PEN_BUTTON_DOWN = 0x1304,
	PEN_BUTTON_UP = 0x1305,
	PEN_MOTION = 0x1306,
	PEN_AXIS = 0x1307,
	CAMERA_DEVICE_ADDED = 0x1400,
	CAMERA_DEVICE_REMOVED = 0x1401,
	CAMERA_DEVICE_APPROVED = 0x1402,
	CAMERA_DEVICE_DENIED = 0x1403,
	RENDER_TARGETS_RESET = 0x2000,
	RENDER_DEVICE_RESET = 0x2001,
	RENDER_DEVICE_LOST = 0x2002,
	PRIVATE0 = 0x4000,
	PRIVATE1 = 0x4001,
	PRIVATE2 = 0x4002,
	PRIVATE3 = 0x4003,
	POLL_SENTINEL = 0x7f00,
	USER = 0x8000,
	LAST = 0xffff,
	ENUM_PADDING = 0x7fffffff,
}

struct CommonEvent {
	type: Uint32,
	reserved: Uint32,
	timestamp: Uint64,
}

struct DisplayEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	displayID: DisplayID,
	data1: Sint32,
	data2: Sint32,
}

struct WindowEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	data1: Sint32,
	data2: Sint32,
}

struct KeyboardDeviceEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: KeyboardID,
}

struct KeyboardEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: KeyboardID,
	scancode: Scancode,
	key: Keycode,
	mod: Keymod,
	raw: Uint16,
	down: bool,
	repeat: bool,
}

struct TextEditingEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	text: ?*u8,
	start: Sint32,
	length: Sint32,
}

struct TextEditingCandidatesEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	candidates: ?*?*u8,
	num_candidates: Sint32,
	selected_candidate: Sint32,
	horizontal: bool,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
}

struct TextInputEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	text: ?*u8,
}

struct MouseDeviceEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: MouseID,
}

struct MouseMotionEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: MouseID,
	state: MouseButtonFlags,
	x: f32,
	y: f32,
	xrel: f32,
	yrel: f32,
}

struct MouseButtonEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: MouseID,
	button: Uint8,
	down: bool,
	clicks: Uint8,
	padding: Uint8,
	x: f32,
	y: f32,
}

struct MouseWheelEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: MouseID,
	x: f32,
	y: f32,
	direction: MouseWheelDirection,
	mouse_x: f32,
	mouse_y: f32,
	integer_x: Sint32,
	integer_y: Sint32,
}

struct JoyAxisEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	axis: Uint8,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
	value: Sint16,
	padding4: Uint16,
}

struct JoyBallEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	ball: Uint8,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
	xrel: Sint16,
	yrel: Sint16,
}

struct JoyHatEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	hat: Uint8,
	value: Uint8,
	padding1: Uint8,
	padding2: Uint8,
}

struct JoyButtonEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	button: Uint8,
	down: bool,
	padding1: Uint8,
	padding2: Uint8,
}

struct JoyDeviceEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
}

struct JoyBatteryEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	state: PowerState,
	percent: i32,
}

struct GamepadAxisEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	axis: Uint8,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
	value: Sint16,
	padding4: Uint16,
}

struct GamepadButtonEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	button: Uint8,
	down: bool,
	padding1: Uint8,
	padding2: Uint8,
}

struct GamepadDeviceEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
}

struct GamepadTouchpadEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	touchpad: Sint32,
	finger: Sint32,
	x: f32,
	y: f32,
	pressure: f32,
}

struct GamepadSensorEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: JoystickID,
	sensor: Sint32,
	data: [3]f32,
	sensor_timestamp: Uint64,
}

struct AudioDeviceEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: AudioDeviceID,
	recording: bool,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
}

struct CameraDeviceEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: CameraID,
}

struct RenderEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
}

struct TouchFingerEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	touchID: TouchID,
	fingerID: FingerID,
	x: f32,
	y: f32,
	dx: f32,
	dy: f32,
	pressure: f32,
	windowID: WindowID,
}

struct PenProximityEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: PenID,
}

struct PenMotionEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: PenID,
	pen_state: PenInputFlags,
	x: f32,
	y: f32,
}

struct PenTouchEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: PenID,
	pen_state: PenInputFlags,
	x: f32,
	y: f32,
	eraser: bool,
	down: bool,
}

struct PenButtonEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: PenID,
	pen_state: PenInputFlags,
	x: f32,
	y: f32,
	button: Uint8,
	down: bool,
}

struct PenAxisEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	which: PenID,
	pen_state: PenInputFlags,
	x: f32,
	y: f32,
	axis: PenAxis,
	value: f32,
}

struct DropEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	x: f32,
	y: f32,
	source: ?*u8,
	data: ?*u8,
}

struct ClipboardEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	owner: bool,
	num_mime_types: Sint32,
	mime_types: ?*?*u8,
}

struct SensorEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
	which: SensorID,
	data: [6]f32,
	sensor_timestamp: Uint64,
}

struct QuitEvent {
	type: EventType,
	reserved: Uint32,
	timestamp: Uint64,
}

struct UserEvent {
	type: Uint32,
	reserved: Uint32,
	timestamp: Uint64,
	windowID: WindowID,
	code: Sint32,
	data1: ?*,
	data2: ?*,
}

union Event {
	type: Uint32,
	common: CommonEvent,
	display: DisplayEvent,
	window: WindowEvent,
	kdevice: KeyboardDeviceEvent,
	key: KeyboardEvent,
	edit: TextEditingEvent,
	edit_candidates: TextEditingCandidatesEvent,
	text: TextInputEvent,
	mdevice: MouseDeviceEvent,
	motion: MouseMotionEvent,
	button: MouseButtonEvent,
	wheel: MouseWheelEvent,
	jdevice: JoyDeviceEvent,
	jaxis: JoyAxisEvent,
	jball: JoyBallEvent,
	jhat: JoyHatEvent,
	jbutton: JoyButtonEvent,
	jbattery: JoyBatteryEvent,
	gdevice: GamepadDeviceEvent,
	gaxis: GamepadAxisEvent,
	gbutton: GamepadButtonEvent,
	gtouchpad: GamepadTouchpadEvent,
	gsensor: GamepadSensorEvent,
	adevice: AudioDeviceEvent,
	cdevice: CameraDeviceEvent,
	sensor: SensorEvent,
	quit: QuitEvent,
	user: UserEvent,
	tfinger: TouchFingerEvent,
	pproximity: PenProximityEvent,
	ptouch: PenTouchEvent,
	pmotion: PenMotionEvent,
	pbutton: PenButtonEvent,
	paxis: PenAxisEvent,
	render: RenderEvent,
	drop: DropEvent,
	clipboard: ClipboardEvent,
	padding: [128]Uint8,
}

PumpEvents :: fn() #foreign #link="SDL_PumpEvents";

enum EventAction: u32 {
	ADDEVENT = 0x0,
	PEEKEVENT = 0x1,
	GETEVENT = 0x2,
}

PeepEvents :: fn(
	events: ?*Event,
	numevents: i32,
	action: EventAction,
	minType: Uint32,
	maxType: Uint32
) -> i32 #foreign #link="SDL_PeepEvents";

HasEvent :: fn(
	type: Uint32
) -> bool #foreign #link="SDL_HasEvent";

HasEvents :: fn(
	minType: Uint32,
	maxType: Uint32
) -> bool #foreign #link="SDL_HasEvents";

FlushEvent :: fn(
	type: Uint32
) #foreign #link="SDL_FlushEvent";

FlushEvents :: fn(
	minType: Uint32,
	maxType: Uint32
) #foreign #link="SDL_FlushEvents";

PollEvent :: fn(
	event: ?*Event
) -> bool #foreign #link="SDL_PollEvent";

WaitEvent :: fn(
	event: ?*Event
) -> bool #foreign #link="SDL_WaitEvent";

WaitEventTimeout :: fn(
	event: ?*Event,
	timeoutMS: Sint32
) -> bool #foreign #link="SDL_WaitEventTimeout";

PushEvent :: fn(
	event: ?*Event
) -> bool #foreign #link="SDL_PushEvent";

EventFilter :: ?*fn(a: ?*, b: ?*Event) -> bool #foreign;

SetEventFilter :: fn(
	filter: EventFilter,
	userdata: ?*
) #foreign #link="SDL_SetEventFilter";

GetEventFilter :: fn(
	filter: ?*EventFilter,
	userdata: ?*?*
) -> bool #foreign #link="SDL_GetEventFilter";

AddEventWatch :: fn(
	filter: EventFilter,
	userdata: ?*
) -> bool #foreign #link="SDL_AddEventWatch";

RemoveEventWatch :: fn(
	filter: EventFilter,
	userdata: ?*
) #foreign #link="SDL_RemoveEventWatch";

FilterEvents :: fn(
	filter: EventFilter,
	userdata: ?*
) #foreign #link="SDL_FilterEvents";

SetEventEnabled :: fn(
	type: Uint32,
	enabled: bool
) #foreign #link="SDL_SetEventEnabled";

EventEnabled :: fn(
	type: Uint32
) -> bool #foreign #link="SDL_EventEnabled";

RegisterEvents :: fn(
	numevents: i32
) -> Uint32 #foreign #link="SDL_RegisterEvents";

GetWindowFromEvent :: fn(
	event: ?*Event
) -> ?*Window #foreign #link="SDL_GetWindowFromEvent";

GetBasePath :: fn() -> ?*u8 #foreign #link="SDL_GetBasePath";

GetPrefPath :: fn(
	org: ?*u8,
	app: ?*u8
) -> ?*u8 #foreign #link="SDL_GetPrefPath";

enum Folder: u32 {
	HOME = 0x0,
	DESKTOP = 0x1,
	DOCUMENTS = 0x2,
	DOWNLOADS = 0x3,
	MUSIC = 0x4,
	PICTURES = 0x5,
	PUBLICSHARE = 0x6,
	SAVEDGAMES = 0x7,
	SCREENSHOTS = 0x8,
	TEMPLATES = 0x9,
	VIDEOS = 0xa,
	COUNT = 0xb,
}

GetUserFolder :: fn(
	folder: Folder
) -> ?*u8 #foreign #link="SDL_GetUserFolder";

enum PathType: u32 {
	NONE = 0x0,
	FILE = 0x1,
	DIRECTORY = 0x2,
	OTHER = 0x3,
}

struct PathInfo {
	type: PathType,
	size: Uint64,
	create_time: Time,
	modify_time: Time,
	access_time: Time,
}

GlobFlags :: Uint32;

CreateDirectory :: fn(
	path: ?*u8
) -> bool #foreign #link="SDL_CreateDirectory";

enum EnumerationResult: u32 {
	ENUM_CONTINUE = 0x0,
	ENUM_SUCCESS = 0x1,
	ENUM_FAILURE = 0x2,
}

EnumerateDirectoryCallback :: ?*fn(a: ?*, b: ?*u8, c: ?*u8) -> EnumerationResult #foreign;

EnumerateDirectory :: fn(
	path: ?*u8,
	callback: EnumerateDirectoryCallback,
	userdata: ?*
) -> bool #foreign #link="SDL_EnumerateDirectory";

RemovePath :: fn(
	path: ?*u8
) -> bool #foreign #link="SDL_RemovePath";

RenamePath :: fn(
	oldpath: ?*u8,
	newpath: ?*u8
) -> bool #foreign #link="SDL_RenamePath";

CopyFile :: fn(
	oldpath: ?*u8,
	newpath: ?*u8
) -> bool #foreign #link="SDL_CopyFile";

GetPathInfo :: fn(
	path: ?*u8,
	info: ?*PathInfo
) -> bool #foreign #link="SDL_GetPathInfo";

GlobDirectory :: fn(
	path: ?*u8,
	pattern: ?*u8,
	flags: GlobFlags,
	count: ?*i32
) -> ?*?*u8 #foreign #link="SDL_GlobDirectory";

GetCurrentDirectory :: fn() -> ?*u8 #foreign #link="SDL_GetCurrentDirectory";

struct GPUDevice {
}

struct GPUBuffer {
}

struct GPUTransferBuffer {
}

struct GPUTexture {
}

struct GPUSampler {
}

struct GPUShader {
}

struct GPUComputePipeline {
}

struct GPUGraphicsPipeline {
}

struct GPUCommandBuffer {
}

struct GPURenderPass {
}

struct GPUComputePass {
}

struct GPUCopyPass {
}

struct GPUFence {
}

enum GPUPrimitiveType: u32 {
	GPU_PRIMITIVETYPE_TRIANGLELIST = 0x0,
	GPU_PRIMITIVETYPE_TRIANGLESTRIP = 0x1,
	GPU_PRIMITIVETYPE_LINELIST = 0x2,
	GPU_PRIMITIVETYPE_LINESTRIP = 0x3,
	GPU_PRIMITIVETYPE_POINTLIST = 0x4,
}

enum GPULoadOp: u32 {
	LOAD = 0x0,
	CLEAR = 0x1,
	DONT_CARE = 0x2,
}

enum GPUStoreOp: u32 {
	STORE = 0x0,
	DONT_CARE = 0x1,
	RESOLVE = 0x2,
	RESOLVE_AND_STORE = 0x3,
}

enum GPUIndexElementSize: u32 {
	_16BIT = 0x0,
	_32BIT = 0x1,
}

enum GPUTextureFormat: u32 {
	INVALID = 0x0,
	A8_UNORM = 0x1,
	R8_UNORM = 0x2,
	R8G8_UNORM = 0x3,
	R8G8B8A8_UNORM = 0x4,
	R16_UNORM = 0x5,
	R16G16_UNORM = 0x6,
	R16G16B16A16_UNORM = 0x7,
	R10G10B10A2_UNORM = 0x8,
	B5G6R5_UNORM = 0x9,
	B5G5R5A1_UNORM = 0xa,
	B4G4R4A4_UNORM = 0xb,
	B8G8R8A8_UNORM = 0xc,
	BC1_RGBA_UNORM = 0xd,
	BC2_RGBA_UNORM = 0xe,
	BC3_RGBA_UNORM = 0xf,
	BC4_R_UNORM = 0x10,
	BC5_RG_UNORM = 0x11,
	BC7_RGBA_UNORM = 0x12,
	BC6H_RGB_FLOAT = 0x13,
	BC6H_RGB_UFLOAT = 0x14,
	R8_SNORM = 0x15,
	R8G8_SNORM = 0x16,
	R8G8B8A8_SNORM = 0x17,
	R16_SNORM = 0x18,
	R16G16_SNORM = 0x19,
	R16G16B16A16_SNORM = 0x1a,
	R16_FLOAT = 0x1b,
	R16G16_FLOAT = 0x1c,
	R16G16B16A16_FLOAT = 0x1d,
	R32_FLOAT = 0x1e,
	R32G32_FLOAT = 0x1f,
	R32G32B32A32_FLOAT = 0x20,
	R11G11B10_UFLOAT = 0x21,
	R8_UINT = 0x22,
	R8G8_UINT = 0x23,
	R8G8B8A8_UINT = 0x24,
	R16_UINT = 0x25,
	R16G16_UINT = 0x26,
	R16G16B16A16_UINT = 0x27,
	R32_UINT = 0x28,
	R32G32_UINT = 0x29,
	R32G32B32A32_UINT = 0x2a,
	R8_INT = 0x2b,
	R8G8_INT = 0x2c,
	R8G8B8A8_INT = 0x2d,
	R16_INT = 0x2e,
	R16G16_INT = 0x2f,
	R16G16B16A16_INT = 0x30,
	R32_INT = 0x31,
	R32G32_INT = 0x32,
	R32G32B32A32_INT = 0x33,
	R8G8B8A8_UNORM_SRGB = 0x34,
	B8G8R8A8_UNORM_SRGB = 0x35,
	BC1_RGBA_UNORM_SRGB = 0x36,
	BC2_RGBA_UNORM_SRGB = 0x37,
	BC3_RGBA_UNORM_SRGB = 0x38,
	BC7_RGBA_UNORM_SRGB = 0x39,
	D16_UNORM = 0x3a,
	D24_UNORM = 0x3b,
	D32_FLOAT = 0x3c,
	D24_UNORM_S8_UINT = 0x3d,
	D32_FLOAT_S8_UINT = 0x3e,
	ASTC_4x4_UNORM = 0x3f,
	ASTC_5x4_UNORM = 0x40,
	ASTC_5x5_UNORM = 0x41,
	ASTC_6x5_UNORM = 0x42,
	ASTC_6x6_UNORM = 0x43,
	ASTC_8x5_UNORM = 0x44,
	ASTC_8x6_UNORM = 0x45,
	ASTC_8x8_UNORM = 0x46,
	ASTC_10x5_UNORM = 0x47,
	ASTC_10x6_UNORM = 0x48,
	ASTC_10x8_UNORM = 0x49,
	ASTC_10x10_UNORM = 0x4a,
	ASTC_12x10_UNORM = 0x4b,
	ASTC_12x12_UNORM = 0x4c,
	ASTC_4x4_UNORM_SRGB = 0x4d,
	ASTC_5x4_UNORM_SRGB = 0x4e,
	ASTC_5x5_UNORM_SRGB = 0x4f,
	ASTC_6x5_UNORM_SRGB = 0x50,
	ASTC_6x6_UNORM_SRGB = 0x51,
	ASTC_8x5_UNORM_SRGB = 0x52,
	ASTC_8x6_UNORM_SRGB = 0x53,
	ASTC_8x8_UNORM_SRGB = 0x54,
	ASTC_10x5_UNORM_SRGB = 0x55,
	ASTC_10x6_UNORM_SRGB = 0x56,
	ASTC_10x8_UNORM_SRGB = 0x57,
	ASTC_10x10_UNORM_SRGB = 0x58,
	ASTC_12x10_UNORM_SRGB = 0x59,
	ASTC_12x12_UNORM_SRGB = 0x5a,
	ASTC_4x4_FLOAT = 0x5b,
	ASTC_5x4_FLOAT = 0x5c,
	ASTC_5x5_FLOAT = 0x5d,
	ASTC_6x5_FLOAT = 0x5e,
	ASTC_6x6_FLOAT = 0x5f,
	ASTC_8x5_FLOAT = 0x60,
	ASTC_8x6_FLOAT = 0x61,
	ASTC_8x8_FLOAT = 0x62,
	ASTC_10x5_FLOAT = 0x63,
	ASTC_10x6_FLOAT = 0x64,
	ASTC_10x8_FLOAT = 0x65,
	ASTC_10x10_FLOAT = 0x66,
	ASTC_12x10_FLOAT = 0x67,
	ASTC_12x12_FLOAT = 0x68,
}

GPUTextureUsageFlags :: Uint32;

enum GPUTextureType: u32 {
	GPU_TEXTURETYPE_2D = 0x0,
	GPU_TEXTURETYPE_2D_ARRAY = 0x1,
	GPU_TEXTURETYPE_3D = 0x2,
	GPU_TEXTURETYPE_CUBE = 0x3,
	GPU_TEXTURETYPE_CUBE_ARRAY = 0x4,
}

enum GPUSampleCount: u32 {
	GPU_SAMPLECOUNT_1 = 0x0,
	GPU_SAMPLECOUNT_2 = 0x1,
	GPU_SAMPLECOUNT_4 = 0x2,
	GPU_SAMPLECOUNT_8 = 0x3,
}

enum GPUCubeMapFace: u32 {
	GPU_CUBEMAPFACE_POSITIVEX = 0x0,
	GPU_CUBEMAPFACE_NEGATIVEX = 0x1,
	GPU_CUBEMAPFACE_POSITIVEY = 0x2,
	GPU_CUBEMAPFACE_NEGATIVEY = 0x3,
	GPU_CUBEMAPFACE_POSITIVEZ = 0x4,
	GPU_CUBEMAPFACE_NEGATIVEZ = 0x5,
}

GPUBufferUsageFlags :: Uint32;

enum GPUTransferBufferUsage: u32 {
	GPU_TRANSFERBUFFERUSAGE_UPLOAD = 0x0,
	GPU_TRANSFERBUFFERUSAGE_DOWNLOAD = 0x1,
}

enum GPUShaderStage: u32 {
	GPU_SHADERSTAGE_VERTEX = 0x0,
	GPU_SHADERSTAGE_FRAGMENT = 0x1,
}

GPUShaderFormat :: Uint32;

enum GPUVertexElementFormat: u32 {
	GPU_VERTEXELEMENTFORMAT_INVALID = 0x0,
	GPU_VERTEXELEMENTFORMAT_INT = 0x1,
	GPU_VERTEXELEMENTFORMAT_INT2 = 0x2,
	GPU_VERTEXELEMENTFORMAT_INT3 = 0x3,
	GPU_VERTEXELEMENTFORMAT_INT4 = 0x4,
	GPU_VERTEXELEMENTFORMAT_UINT = 0x5,
	GPU_VERTEXELEMENTFORMAT_UINT2 = 0x6,
	GPU_VERTEXELEMENTFORMAT_UINT3 = 0x7,
	GPU_VERTEXELEMENTFORMAT_UINT4 = 0x8,
	GPU_VERTEXELEMENTFORMAT_FLOAT = 0x9,
	GPU_VERTEXELEMENTFORMAT_FLOAT2 = 0xa,
	GPU_VERTEXELEMENTFORMAT_FLOAT3 = 0xb,
	GPU_VERTEXELEMENTFORMAT_FLOAT4 = 0xc,
	GPU_VERTEXELEMENTFORMAT_BYTE2 = 0xd,
	GPU_VERTEXELEMENTFORMAT_BYTE4 = 0xe,
	GPU_VERTEXELEMENTFORMAT_UBYTE2 = 0xf,
	GPU_VERTEXELEMENTFORMAT_UBYTE4 = 0x10,
	GPU_VERTEXELEMENTFORMAT_BYTE2_NORM = 0x11,
	GPU_VERTEXELEMENTFORMAT_BYTE4_NORM = 0x12,
	GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM = 0x13,
	GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM = 0x14,
	GPU_VERTEXELEMENTFORMAT_SHORT2 = 0x15,
	GPU_VERTEXELEMENTFORMAT_SHORT4 = 0x16,
	GPU_VERTEXELEMENTFORMAT_USHORT2 = 0x17,
	GPU_VERTEXELEMENTFORMAT_USHORT4 = 0x18,
	GPU_VERTEXELEMENTFORMAT_SHORT2_NORM = 0x19,
	GPU_VERTEXELEMENTFORMAT_SHORT4_NORM = 0x1a,
	GPU_VERTEXELEMENTFORMAT_USHORT2_NORM = 0x1b,
	GPU_VERTEXELEMENTFORMAT_USHORT4_NORM = 0x1c,
	GPU_VERTEXELEMENTFORMAT_HALF2 = 0x1d,
	GPU_VERTEXELEMENTFORMAT_HALF4 = 0x1e,
}

enum GPUVertexInputRate: u32 {
	GPU_VERTEXINPUTRATE_VERTEX = 0x0,
	GPU_VERTEXINPUTRATE_INSTANCE = 0x1,
}

enum GPUFillMode: u32 {
	GPU_FILLMODE_FILL = 0x0,
	GPU_FILLMODE_LINE = 0x1,
}

enum GPUCullMode: u32 {
	GPU_CULLMODE_NONE = 0x0,
	GPU_CULLMODE_FRONT = 0x1,
	GPU_CULLMODE_BACK = 0x2,
}

enum GPUFrontFace: u32 {
	GPU_FRONTFACE_COUNTER_CLOCKWISE = 0x0,
	GPU_FRONTFACE_CLOCKWISE = 0x1,
}

enum GPUCompareOp: u32 {
	GPU_COMPAREOP_INVALID = 0x0,
	GPU_COMPAREOP_NEVER = 0x1,
	GPU_COMPAREOP_LESS = 0x2,
	GPU_COMPAREOP_EQUAL = 0x3,
	GPU_COMPAREOP_LESS_OR_EQUAL = 0x4,
	GPU_COMPAREOP_GREATER = 0x5,
	GPU_COMPAREOP_NOT_EQUAL = 0x6,
	GPU_COMPAREOP_GREATER_OR_EQUAL = 0x7,
	GPU_COMPAREOP_ALWAYS = 0x8,
}

enum GPUStencilOp: u32 {
	GPU_STENCILOP_INVALID = 0x0,
	GPU_STENCILOP_KEEP = 0x1,
	GPU_STENCILOP_ZERO = 0x2,
	GPU_STENCILOP_REPLACE = 0x3,
	GPU_STENCILOP_INCREMENT_AND_CLAMP = 0x4,
	GPU_STENCILOP_DECREMENT_AND_CLAMP = 0x5,
	GPU_STENCILOP_INVERT = 0x6,
	GPU_STENCILOP_INCREMENT_AND_WRAP = 0x7,
	GPU_STENCILOP_DECREMENT_AND_WRAP = 0x8,
}

enum GPUBlendOp: u32 {
	GPU_BLENDOP_INVALID = 0x0,
	GPU_BLENDOP_ADD = 0x1,
	GPU_BLENDOP_SUBTRACT = 0x2,
	GPU_BLENDOP_REVERSE_SUBTRACT = 0x3,
	GPU_BLENDOP_MIN = 0x4,
	GPU_BLENDOP_MAX = 0x5,
}

enum GPUBlendFactor: u32 {
	GPU_BLENDFACTOR_INVALID = 0x0,
	GPU_BLENDFACTOR_ZERO = 0x1,
	GPU_BLENDFACTOR_ONE = 0x2,
	GPU_BLENDFACTOR_SRC_COLOR = 0x3,
	GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 0x4,
	GPU_BLENDFACTOR_DST_COLOR = 0x5,
	GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR = 0x6,
	GPU_BLENDFACTOR_SRC_ALPHA = 0x7,
	GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 0x8,
	GPU_BLENDFACTOR_DST_ALPHA = 0x9,
	GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 0xa,
	GPU_BLENDFACTOR_CONSTANT_COLOR = 0xb,
	GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR = 0xc,
	GPU_BLENDFACTOR_SRC_ALPHA_SATURATE = 0xd,
}

GPUColorComponentFlags :: Uint8;

enum GPUFilter: u32 {
	GPU_FILTER_NEAREST = 0x0,
	GPU_FILTER_LINEAR = 0x1,
}

enum GPUSamplerMipmapMode: u32 {
	GPU_SAMPLERMIPMAPMODE_NEAREST = 0x0,
	GPU_SAMPLERMIPMAPMODE_LINEAR = 0x1,
}

enum GPUSamplerAddressMode: u32 {
	GPU_SAMPLERADDRESSMODE_REPEAT = 0x0,
	GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT = 0x1,
	GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE = 0x2,
}

enum GPUPresentMode: u32 {
	GPU_PRESENTMODE_VSYNC = 0x0,
	GPU_PRESENTMODE_IMMEDIATE = 0x1,
	GPU_PRESENTMODE_MAILBOX = 0x2,
}

enum GPUSwapchainComposition: u32 {
	GPU_SWAPCHAINCOMPOSITION_SDR = 0x0,
	GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR = 0x1,
	GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR = 0x2,
	GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084 = 0x3,
}

struct GPUViewport {
	x: f32,
	y: f32,
	w: f32,
	h: f32,
	min_depth: f32,
	max_depth: f32,
}

struct GPUTextureTransferInfo {
	transfer_buffer: ?*GPUTransferBuffer,
	offset: Uint32,
	pixels_per_row: Uint32,
	rows_per_layer: Uint32,
}

struct GPUTransferBufferLocation {
	transfer_buffer: ?*GPUTransferBuffer,
	offset: Uint32,
}

struct GPUTextureLocation {
	texture: ?*GPUTexture,
	mip_level: Uint32,
	layer: Uint32,
	x: Uint32,
	y: Uint32,
	z: Uint32,
}

struct GPUTextureRegion {
	texture: ?*GPUTexture,
	mip_level: Uint32,
	layer: Uint32,
	x: Uint32,
	y: Uint32,
	z: Uint32,
	w: Uint32,
	h: Uint32,
	d: Uint32,
}

struct GPUBlitRegion {
	texture: ?*GPUTexture,
	mip_level: Uint32,
	layer_or_depth_plane: Uint32,
	x: Uint32,
	y: Uint32,
	w: Uint32,
	h: Uint32,
}

struct GPUBufferLocation {
	buffer: ?*GPUBuffer,
	offset: Uint32,
}

struct GPUBufferRegion {
	buffer: ?*GPUBuffer,
	offset: Uint32,
	size: Uint32,
}

struct GPUIndirectDrawCommand {
	num_vertices: Uint32,
	num_instances: Uint32,
	first_vertex: Uint32,
	first_instance: Uint32,
}

struct GPUIndexedIndirectDrawCommand {
	num_indices: Uint32,
	num_instances: Uint32,
	first_index: Uint32,
	vertex_offset: Sint32,
	first_instance: Uint32,
}

struct GPUIndirectDispatchCommand {
	groupcount_x: Uint32,
	groupcount_y: Uint32,
	groupcount_z: Uint32,
}

struct GPUSamplerCreateInfo {
	min_filter: GPUFilter,
	mag_filter: GPUFilter,
	mipmap_mode: GPUSamplerMipmapMode,
	address_mode_u: GPUSamplerAddressMode,
	address_mode_v: GPUSamplerAddressMode,
	address_mode_w: GPUSamplerAddressMode,
	mip_lod_bias: f32,
	max_anisotropy: f32,
	compare_op: GPUCompareOp,
	min_lod: f32,
	max_lod: f32,
	enable_anisotropy: bool,
	enable_compare: bool,
	padding1: Uint8,
	padding2: Uint8,
	props: PropertiesID,
}

struct GPUVertexBufferDescription {
	slot: Uint32,
	pitch: Uint32,
	input_rate: GPUVertexInputRate,
	instance_step_rate: Uint32,
}

struct GPUVertexAttribute {
	location: Uint32,
	buffer_slot: Uint32,
	format: GPUVertexElementFormat,
	offset: Uint32,
}

struct GPUVertexInputState {
	vertex_buffer_descriptions: ?*GPUVertexBufferDescription,
	num_vertex_buffers: Uint32,
	vertex_attributes: ?*GPUVertexAttribute,
	num_vertex_attributes: Uint32,
}

struct GPUStencilOpState {
	fail_op: GPUStencilOp,
	pass_op: GPUStencilOp,
	depth_fail_op: GPUStencilOp,
	compare_op: GPUCompareOp,
}

struct GPUColorTargetBlendState {
	src_color_blendfactor: GPUBlendFactor,
	dst_color_blendfactor: GPUBlendFactor,
	color_blend_op: GPUBlendOp,
	src_alpha_blendfactor: GPUBlendFactor,
	dst_alpha_blendfactor: GPUBlendFactor,
	alpha_blend_op: GPUBlendOp,
	color_write_mask: GPUColorComponentFlags,
	enable_blend: bool,
	enable_color_write_mask: bool,
	padding1: Uint8,
	padding2: Uint8,
}

struct GPUShaderCreateInfo {
	code_size: uint,
	code: ?*Uint8,
	entrypoint: ?*u8,
	format: GPUShaderFormat,
	stage: GPUShaderStage,
	num_samplers: Uint32,
	num_storage_textures: Uint32,
	num_storage_buffers: Uint32,
	num_uniform_buffers: Uint32,
	props: PropertiesID,
}

struct GPUTextureCreateInfo {
	type: GPUTextureType,
	format: GPUTextureFormat,
	usage: GPUTextureUsageFlags,
	width: Uint32,
	height: Uint32,
	layer_count_or_depth: Uint32,
	num_levels: Uint32,
	sample_count: GPUSampleCount,
	props: PropertiesID,
}

struct GPUBufferCreateInfo {
	usage: GPUBufferUsageFlags,
	size: Uint32,
	props: PropertiesID,
}

struct GPUTransferBufferCreateInfo {
	usage: GPUTransferBufferUsage,
	size: Uint32,
	props: PropertiesID,
}

struct GPURasterizerState {
	fill_mode: GPUFillMode,
	cull_mode: GPUCullMode,
	front_face: GPUFrontFace,
	depth_bias_constant_factor: f32,
	depth_bias_clamp: f32,
	depth_bias_slope_factor: f32,
	enable_depth_bias: bool,
	enable_depth_clip: bool,
	padding1: Uint8,
	padding2: Uint8,
}

struct GPUMultisampleState {
	sample_count: GPUSampleCount,
	sample_mask: Uint32,
	enable_mask: bool,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
}

struct GPUDepthStencilState {
	compare_op: GPUCompareOp,
	back_stencil_state: GPUStencilOpState,
	front_stencil_state: GPUStencilOpState,
	compare_mask: Uint8,
	write_mask: Uint8,
	enable_depth_test: bool,
	enable_depth_write: bool,
	enable_stencil_test: bool,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
}

struct GPUColorTargetDescription {
	format: GPUTextureFormat,
	blend_state: GPUColorTargetBlendState,
}

struct GPUGraphicsPipelineTargetInfo {
	color_target_descriptions: ?*GPUColorTargetDescription,
	num_color_targets: Uint32,
	depth_stencil_format: GPUTextureFormat,
	has_depth_stencil_target: bool,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
}

struct GPUGraphicsPipelineCreateInfo {
	vertex_shader: ?*GPUShader,
	fragment_shader: ?*GPUShader,
	vertex_input_state: GPUVertexInputState,
	primitive_type: GPUPrimitiveType,
	rasterizer_state: GPURasterizerState,
	multisample_state: GPUMultisampleState,
	depth_stencil_state: GPUDepthStencilState,
	target_info: GPUGraphicsPipelineTargetInfo,
	props: PropertiesID,
}

struct GPUComputePipelineCreateInfo {
	code_size: uint,
	code: ?*Uint8,
	entrypoint: ?*u8,
	format: GPUShaderFormat,
	num_samplers: Uint32,
	num_readonly_storage_textures: Uint32,
	num_readonly_storage_buffers: Uint32,
	num_readwrite_storage_textures: Uint32,
	num_readwrite_storage_buffers: Uint32,
	num_uniform_buffers: Uint32,
	threadcount_x: Uint32,
	threadcount_y: Uint32,
	threadcount_z: Uint32,
	props: PropertiesID,
}

struct GPUColorTargetInfo {
	texture: ?*GPUTexture,
	mip_level: Uint32,
	layer_or_depth_plane: Uint32,
	clear_color: FColor,
	load_op: GPULoadOp,
	store_op: GPUStoreOp,
	resolve_texture: ?*GPUTexture,
	resolve_mip_level: Uint32,
	resolve_layer: Uint32,
	cycle: bool,
	cycle_resolve_texture: bool,
	padding1: Uint8,
	padding2: Uint8,
}

struct GPUDepthStencilTargetInfo {
	texture: ?*GPUTexture,
	clear_depth: f32,
	load_op: GPULoadOp,
	store_op: GPUStoreOp,
	stencil_load_op: GPULoadOp,
	stencil_store_op: GPUStoreOp,
	cycle: bool,
	clear_stencil: Uint8,
	padding1: Uint8,
	padding2: Uint8,
}

struct GPUBlitInfo {
	source: GPUBlitRegion,
	destination: GPUBlitRegion,
	load_op: GPULoadOp,
	clear_color: FColor,
	flip_mode: FlipMode,
	filter: GPUFilter,
	cycle: bool,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
}

struct GPUBufferBinding {
	buffer: ?*GPUBuffer,
	offset: Uint32,
}

struct GPUTextureSamplerBinding {
	texture: ?*GPUTexture,
	sampler: ?*GPUSampler,
}

struct GPUStorageBufferReadWriteBinding {
	buffer: ?*GPUBuffer,
	cycle: bool,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
}

struct GPUStorageTextureReadWriteBinding {
	texture: ?*GPUTexture,
	mip_level: Uint32,
	layer: Uint32,
	cycle: bool,
	padding1: Uint8,
	padding2: Uint8,
	padding3: Uint8,
}

GPUSupportsShaderFormats :: fn(
	format_flags: GPUShaderFormat,
	name: ?*u8
) -> bool #foreign #link="SDL_GPUSupportsShaderFormats";

GPUSupportsProperties :: fn(
	props: PropertiesID
) -> bool #foreign #link="SDL_GPUSupportsProperties";

CreateGPUDevice :: fn(
	format_flags: GPUShaderFormat,
	debug_mode: bool,
	name: ?*u8
) -> ?*GPUDevice #foreign #link="SDL_CreateGPUDevice";

CreateGPUDeviceWithProperties :: fn(
	props: PropertiesID
) -> ?*GPUDevice #foreign #link="SDL_CreateGPUDeviceWithProperties";

DestroyGPUDevice :: fn(
	device: ?*GPUDevice
) #foreign #link="SDL_DestroyGPUDevice";

GetNumGPUDrivers :: fn() -> i32 #foreign #link="SDL_GetNumGPUDrivers";

GetGPUDriver :: fn(
	index: i32
) -> ?*u8 #foreign #link="SDL_GetGPUDriver";

GetGPUDeviceDriver :: fn(
	device: ?*GPUDevice
) -> ?*u8 #foreign #link="SDL_GetGPUDeviceDriver";

GetGPUShaderFormats :: fn(
	device: ?*GPUDevice
) -> GPUShaderFormat #foreign #link="SDL_GetGPUShaderFormats";

CreateGPUComputePipeline :: fn(
	device: ?*GPUDevice,
	createinfo: ?*GPUComputePipelineCreateInfo
) -> ?*GPUComputePipeline #foreign #link="SDL_CreateGPUComputePipeline";

CreateGPUGraphicsPipeline :: fn(
	device: ?*GPUDevice,
	createinfo: ?*GPUGraphicsPipelineCreateInfo
) -> ?*GPUGraphicsPipeline #foreign #link="SDL_CreateGPUGraphicsPipeline";

CreateGPUSampler :: fn(
	device: ?*GPUDevice,
	createinfo: ?*GPUSamplerCreateInfo
) -> ?*GPUSampler #foreign #link="SDL_CreateGPUSampler";

CreateGPUShader :: fn(
	device: ?*GPUDevice,
	createinfo: ?*GPUShaderCreateInfo
) -> ?*GPUShader #foreign #link="SDL_CreateGPUShader";

CreateGPUTexture :: fn(
	device: ?*GPUDevice,
	createinfo: ?*GPUTextureCreateInfo
) -> ?*GPUTexture #foreign #link="SDL_CreateGPUTexture";

CreateGPUBuffer :: fn(
	device: ?*GPUDevice,
	createinfo: ?*GPUBufferCreateInfo
) -> ?*GPUBuffer #foreign #link="SDL_CreateGPUBuffer";

CreateGPUTransferBuffer :: fn(
	device: ?*GPUDevice,
	createinfo: ?*GPUTransferBufferCreateInfo
) -> ?*GPUTransferBuffer #foreign #link="SDL_CreateGPUTransferBuffer";

SetGPUBufferName :: fn(
	device: ?*GPUDevice,
	buffer: ?*GPUBuffer,
	text: ?*u8
) #foreign #link="SDL_SetGPUBufferName";

SetGPUTextureName :: fn(
	device: ?*GPUDevice,
	texture: ?*GPUTexture,
	text: ?*u8
) #foreign #link="SDL_SetGPUTextureName";

InsertGPUDebugLabel :: fn(
	command_buffer: ?*GPUCommandBuffer,
	text: ?*u8
) #foreign #link="SDL_InsertGPUDebugLabel";

PushGPUDebugGroup :: fn(
	command_buffer: ?*GPUCommandBuffer,
	name: ?*u8
) #foreign #link="SDL_PushGPUDebugGroup";

PopGPUDebugGroup :: fn(
	command_buffer: ?*GPUCommandBuffer
) #foreign #link="SDL_PopGPUDebugGroup";

ReleaseGPUTexture :: fn(
	device: ?*GPUDevice,
	texture: ?*GPUTexture
) #foreign #link="SDL_ReleaseGPUTexture";

ReleaseGPUSampler :: fn(
	device: ?*GPUDevice,
	sampler: ?*GPUSampler
) #foreign #link="SDL_ReleaseGPUSampler";

ReleaseGPUBuffer :: fn(
	device: ?*GPUDevice,
	buffer: ?*GPUBuffer
) #foreign #link="SDL_ReleaseGPUBuffer";

ReleaseGPUTransferBuffer :: fn(
	device: ?*GPUDevice,
	transfer_buffer: ?*GPUTransferBuffer
) #foreign #link="SDL_ReleaseGPUTransferBuffer";

ReleaseGPUComputePipeline :: fn(
	device: ?*GPUDevice,
	compute_pipeline: ?*GPUComputePipeline
) #foreign #link="SDL_ReleaseGPUComputePipeline";

ReleaseGPUShader :: fn(
	device: ?*GPUDevice,
	shader: ?*GPUShader
) #foreign #link="SDL_ReleaseGPUShader";

ReleaseGPUGraphicsPipeline :: fn(
	device: ?*GPUDevice,
	graphics_pipeline: ?*GPUGraphicsPipeline
) #foreign #link="SDL_ReleaseGPUGraphicsPipeline";

AcquireGPUCommandBuffer :: fn(
	device: ?*GPUDevice
) -> ?*GPUCommandBuffer #foreign #link="SDL_AcquireGPUCommandBuffer";

PushGPUVertexUniformData :: fn(
	command_buffer: ?*GPUCommandBuffer,
	slot_index: Uint32,
	data: ?*,
	length: Uint32
) #foreign #link="SDL_PushGPUVertexUniformData";

PushGPUFragmentUniformData :: fn(
	command_buffer: ?*GPUCommandBuffer,
	slot_index: Uint32,
	data: ?*,
	length: Uint32
) #foreign #link="SDL_PushGPUFragmentUniformData";

PushGPUComputeUniformData :: fn(
	command_buffer: ?*GPUCommandBuffer,
	slot_index: Uint32,
	data: ?*,
	length: Uint32
) #foreign #link="SDL_PushGPUComputeUniformData";

BeginGPURenderPass :: fn(
	command_buffer: ?*GPUCommandBuffer,
	color_target_infos: ?*GPUColorTargetInfo,
	num_color_targets: Uint32,
	depth_stencil_target_info: ?*GPUDepthStencilTargetInfo
) -> ?*GPURenderPass #foreign #link="SDL_BeginGPURenderPass";

BindGPUGraphicsPipeline :: fn(
	render_pass: ?*GPURenderPass,
	graphics_pipeline: ?*GPUGraphicsPipeline
) #foreign #link="SDL_BindGPUGraphicsPipeline";

SetGPUViewport :: fn(
	render_pass: ?*GPURenderPass,
	viewport: ?*GPUViewport
) #foreign #link="SDL_SetGPUViewport";

SetGPUScissor :: fn(
	render_pass: ?*GPURenderPass,
	scissor: ?*Rect
) #foreign #link="SDL_SetGPUScissor";

SetGPUBlendConstants :: fn(
	render_pass: ?*GPURenderPass,
	blend_constants: FColor
) #foreign #link="SDL_SetGPUBlendConstants";

SetGPUStencilReference :: fn(
	render_pass: ?*GPURenderPass,
	reference: Uint8
) #foreign #link="SDL_SetGPUStencilReference";

BindGPUVertexBuffers :: fn(
	render_pass: ?*GPURenderPass,
	first_slot: Uint32,
	bindings: ?*GPUBufferBinding,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUVertexBuffers";

BindGPUIndexBuffer :: fn(
	render_pass: ?*GPURenderPass,
	binding: ?*GPUBufferBinding,
	index_element_size: GPUIndexElementSize
) #foreign #link="SDL_BindGPUIndexBuffer";

BindGPUVertexSamplers :: fn(
	render_pass: ?*GPURenderPass,
	first_slot: Uint32,
	texture_sampler_bindings: ?*GPUTextureSamplerBinding,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUVertexSamplers";

BindGPUVertexStorageTextures :: fn(
	render_pass: ?*GPURenderPass,
	first_slot: Uint32,
	storage_textures: ?*?*GPUTexture,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUVertexStorageTextures";

BindGPUVertexStorageBuffers :: fn(
	render_pass: ?*GPURenderPass,
	first_slot: Uint32,
	storage_buffers: ?*?*GPUBuffer,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUVertexStorageBuffers";

BindGPUFragmentSamplers :: fn(
	render_pass: ?*GPURenderPass,
	first_slot: Uint32,
	texture_sampler_bindings: ?*GPUTextureSamplerBinding,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUFragmentSamplers";

BindGPUFragmentStorageTextures :: fn(
	render_pass: ?*GPURenderPass,
	first_slot: Uint32,
	storage_textures: ?*?*GPUTexture,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUFragmentStorageTextures";

BindGPUFragmentStorageBuffers :: fn(
	render_pass: ?*GPURenderPass,
	first_slot: Uint32,
	storage_buffers: ?*?*GPUBuffer,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUFragmentStorageBuffers";

DrawGPUIndexedPrimitives :: fn(
	render_pass: ?*GPURenderPass,
	num_indices: Uint32,
	num_instances: Uint32,
	first_index: Uint32,
	vertex_offset: Sint32,
	first_instance: Uint32
) #foreign #link="SDL_DrawGPUIndexedPrimitives";

DrawGPUPrimitives :: fn(
	render_pass: ?*GPURenderPass,
	num_vertices: Uint32,
	num_instances: Uint32,
	first_vertex: Uint32,
	first_instance: Uint32
) #foreign #link="SDL_DrawGPUPrimitives";

DrawGPUPrimitivesIndirect :: fn(
	render_pass: ?*GPURenderPass,
	buffer: ?*GPUBuffer,
	offset: Uint32,
	draw_count: Uint32
) #foreign #link="SDL_DrawGPUPrimitivesIndirect";

DrawGPUIndexedPrimitivesIndirect :: fn(
	render_pass: ?*GPURenderPass,
	buffer: ?*GPUBuffer,
	offset: Uint32,
	draw_count: Uint32
) #foreign #link="SDL_DrawGPUIndexedPrimitivesIndirect";

EndGPURenderPass :: fn(
	render_pass: ?*GPURenderPass
) #foreign #link="SDL_EndGPURenderPass";

BeginGPUComputePass :: fn(
	command_buffer: ?*GPUCommandBuffer,
	storage_texture_bindings: ?*GPUStorageTextureReadWriteBinding,
	num_storage_texture_bindings: Uint32,
	storage_buffer_bindings: ?*GPUStorageBufferReadWriteBinding,
	num_storage_buffer_bindings: Uint32
) -> ?*GPUComputePass #foreign #link="SDL_BeginGPUComputePass";

BindGPUComputePipeline :: fn(
	compute_pass: ?*GPUComputePass,
	compute_pipeline: ?*GPUComputePipeline
) #foreign #link="SDL_BindGPUComputePipeline";

BindGPUComputeSamplers :: fn(
	compute_pass: ?*GPUComputePass,
	first_slot: Uint32,
	texture_sampler_bindings: ?*GPUTextureSamplerBinding,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUComputeSamplers";

BindGPUComputeStorageTextures :: fn(
	compute_pass: ?*GPUComputePass,
	first_slot: Uint32,
	storage_textures: ?*?*GPUTexture,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUComputeStorageTextures";

BindGPUComputeStorageBuffers :: fn(
	compute_pass: ?*GPUComputePass,
	first_slot: Uint32,
	storage_buffers: ?*?*GPUBuffer,
	num_bindings: Uint32
) #foreign #link="SDL_BindGPUComputeStorageBuffers";

DispatchGPUCompute :: fn(
	compute_pass: ?*GPUComputePass,
	groupcount_x: Uint32,
	groupcount_y: Uint32,
	groupcount_z: Uint32
) #foreign #link="SDL_DispatchGPUCompute";

DispatchGPUComputeIndirect :: fn(
	compute_pass: ?*GPUComputePass,
	buffer: ?*GPUBuffer,
	offset: Uint32
) #foreign #link="SDL_DispatchGPUComputeIndirect";

EndGPUComputePass :: fn(
	compute_pass: ?*GPUComputePass
) #foreign #link="SDL_EndGPUComputePass";

MapGPUTransferBuffer :: fn(
	device: ?*GPUDevice,
	transfer_buffer: ?*GPUTransferBuffer,
	cycle: bool
) -> ?* #foreign #link="SDL_MapGPUTransferBuffer";

UnmapGPUTransferBuffer :: fn(
	device: ?*GPUDevice,
	transfer_buffer: ?*GPUTransferBuffer
) #foreign #link="SDL_UnmapGPUTransferBuffer";

BeginGPUCopyPass :: fn(
	command_buffer: ?*GPUCommandBuffer
) -> ?*GPUCopyPass #foreign #link="SDL_BeginGPUCopyPass";

UploadToGPUTexture :: fn(
	copy_pass: ?*GPUCopyPass,
	source: ?*GPUTextureTransferInfo,
	destination: ?*GPUTextureRegion,
	cycle: bool
) #foreign #link="SDL_UploadToGPUTexture";

UploadToGPUBuffer :: fn(
	copy_pass: ?*GPUCopyPass,
	source: ?*GPUTransferBufferLocation,
	destination: ?*GPUBufferRegion,
	cycle: bool
) #foreign #link="SDL_UploadToGPUBuffer";

CopyGPUTextureToTexture :: fn(
	copy_pass: ?*GPUCopyPass,
	source: ?*GPUTextureLocation,
	destination: ?*GPUTextureLocation,
	w: Uint32,
	h: Uint32,
	d: Uint32,
	cycle: bool
) #foreign #link="SDL_CopyGPUTextureToTexture";

CopyGPUBufferToBuffer :: fn(
	copy_pass: ?*GPUCopyPass,
	source: ?*GPUBufferLocation,
	destination: ?*GPUBufferLocation,
	size: Uint32,
	cycle: bool
) #foreign #link="SDL_CopyGPUBufferToBuffer";

DownloadFromGPUTexture :: fn(
	copy_pass: ?*GPUCopyPass,
	source: ?*GPUTextureRegion,
	destination: ?*GPUTextureTransferInfo
) #foreign #link="SDL_DownloadFromGPUTexture";

DownloadFromGPUBuffer :: fn(
	copy_pass: ?*GPUCopyPass,
	source: ?*GPUBufferRegion,
	destination: ?*GPUTransferBufferLocation
) #foreign #link="SDL_DownloadFromGPUBuffer";

EndGPUCopyPass :: fn(
	copy_pass: ?*GPUCopyPass
) #foreign #link="SDL_EndGPUCopyPass";

GenerateMipmapsForGPUTexture :: fn(
	command_buffer: ?*GPUCommandBuffer,
	texture: ?*GPUTexture
) #foreign #link="SDL_GenerateMipmapsForGPUTexture";

BlitGPUTexture :: fn(
	command_buffer: ?*GPUCommandBuffer,
	info: ?*GPUBlitInfo
) #foreign #link="SDL_BlitGPUTexture";

WindowSupportsGPUSwapchainComposition :: fn(
	device: ?*GPUDevice,
	window: ?*Window,
	swapchain_composition: GPUSwapchainComposition
) -> bool #foreign #link="SDL_WindowSupportsGPUSwapchainComposition";

WindowSupportsGPUPresentMode :: fn(
	device: ?*GPUDevice,
	window: ?*Window,
	present_mode: GPUPresentMode
) -> bool #foreign #link="SDL_WindowSupportsGPUPresentMode";

ClaimWindowForGPUDevice :: fn(
	device: ?*GPUDevice,
	window: ?*Window
) -> bool #foreign #link="SDL_ClaimWindowForGPUDevice";

ReleaseWindowFromGPUDevice :: fn(
	device: ?*GPUDevice,
	window: ?*Window
) #foreign #link="SDL_ReleaseWindowFromGPUDevice";

SetGPUSwapchainParameters :: fn(
	device: ?*GPUDevice,
	window: ?*Window,
	swapchain_composition: GPUSwapchainComposition,
	present_mode: GPUPresentMode
) -> bool #foreign #link="SDL_SetGPUSwapchainParameters";

SetGPUAllowedFramesInFlight :: fn(
	device: ?*GPUDevice,
	allowed_frames_in_flight: Uint32
) -> bool #foreign #link="SDL_SetGPUAllowedFramesInFlight";

GetGPUSwapchainTextureFormat :: fn(
	device: ?*GPUDevice,
	window: ?*Window
) -> GPUTextureFormat #foreign #link="SDL_GetGPUSwapchainTextureFormat";

AcquireGPUSwapchainTexture :: fn(
	command_buffer: ?*GPUCommandBuffer,
	window: ?*Window,
	swapchain_texture: ?*?*GPUTexture,
	swapchain_texture_width: ?*Uint32,
	swapchain_texture_height: ?*Uint32
) -> bool #foreign #link="SDL_AcquireGPUSwapchainTexture";

WaitForGPUSwapchain :: fn(
	device: ?*GPUDevice,
	window: ?*Window
) -> bool #foreign #link="SDL_WaitForGPUSwapchain";

WaitAndAcquireGPUSwapchainTexture :: fn(
	command_buffer: ?*GPUCommandBuffer,
	window: ?*Window,
	swapchain_texture: ?*?*GPUTexture,
	swapchain_texture_width: ?*Uint32,
	swapchain_texture_height: ?*Uint32
) -> bool #foreign #link="SDL_WaitAndAcquireGPUSwapchainTexture";

SubmitGPUCommandBuffer :: fn(
	command_buffer: ?*GPUCommandBuffer
) -> bool #foreign #link="SDL_SubmitGPUCommandBuffer";

SubmitGPUCommandBufferAndAcquireFence :: fn(
	command_buffer: ?*GPUCommandBuffer
) -> ?*GPUFence #foreign #link="SDL_SubmitGPUCommandBufferAndAcquireFence";

CancelGPUCommandBuffer :: fn(
	command_buffer: ?*GPUCommandBuffer
) -> bool #foreign #link="SDL_CancelGPUCommandBuffer";

WaitForGPUIdle :: fn(
	device: ?*GPUDevice
) -> bool #foreign #link="SDL_WaitForGPUIdle";

WaitForGPUFences :: fn(
	device: ?*GPUDevice,
	wait_all: bool,
	fences: ?*?*GPUFence,
	num_fences: Uint32
) -> bool #foreign #link="SDL_WaitForGPUFences";

QueryGPUFence :: fn(
	device: ?*GPUDevice,
	fence: ?*GPUFence
) -> bool #foreign #link="SDL_QueryGPUFence";

ReleaseGPUFence :: fn(
	device: ?*GPUDevice,
	fence: ?*GPUFence
) #foreign #link="SDL_ReleaseGPUFence";

GPUTextureFormatTexelBlockSize :: fn(
	format: GPUTextureFormat
) -> Uint32 #foreign #link="SDL_GPUTextureFormatTexelBlockSize";

GPUTextureSupportsFormat :: fn(
	device: ?*GPUDevice,
	format: GPUTextureFormat,
	type: GPUTextureType,
	usage: GPUTextureUsageFlags
) -> bool #foreign #link="SDL_GPUTextureSupportsFormat";

GPUTextureSupportsSampleCount :: fn(
	device: ?*GPUDevice,
	format: GPUTextureFormat,
	sample_count: GPUSampleCount
) -> bool #foreign #link="SDL_GPUTextureSupportsSampleCount";

CalculateGPUTextureFormatSize :: fn(
	format: GPUTextureFormat,
	width: Uint32,
	height: Uint32,
	depth_or_layer_count: Uint32
) -> Uint32 #foreign #link="SDL_CalculateGPUTextureFormatSize";

struct Haptic {
}

struct HapticDirection {
	type: Uint8,
	dir: [3]Sint32,
}

struct HapticConstant {
	type: Uint16,
	direction: HapticDirection,
	length: Uint32,
	delay: Uint16,
	button: Uint16,
	interval: Uint16,
	level: Sint16,
	attack_length: Uint16,
	attack_level: Uint16,
	fade_length: Uint16,
	fade_level: Uint16,
}

struct HapticPeriodic {
	type: Uint16,
	direction: HapticDirection,
	length: Uint32,
	delay: Uint16,
	button: Uint16,
	interval: Uint16,
	period: Uint16,
	magnitude: Sint16,
	offset: Sint16,
	phase: Uint16,
	attack_length: Uint16,
	attack_level: Uint16,
	fade_length: Uint16,
	fade_level: Uint16,
}

struct HapticCondition {
	type: Uint16,
	direction: HapticDirection,
	length: Uint32,
	delay: Uint16,
	button: Uint16,
	interval: Uint16,
	right_sat: [3]Uint16,
	left_sat: [3]Uint16,
	right_coeff: [3]Sint16,
	left_coeff: [3]Sint16,
	deadband: [3]Uint16,
	center: [3]Sint16,
}

struct HapticRamp {
	type: Uint16,
	direction: HapticDirection,
	length: Uint32,
	delay: Uint16,
	button: Uint16,
	interval: Uint16,
	start: Sint16,
	end: Sint16,
	attack_length: Uint16,
	attack_level: Uint16,
	fade_length: Uint16,
	fade_level: Uint16,
}

struct HapticLeftRight {
	type: Uint16,
	length: Uint32,
	large_magnitude: Uint16,
	small_magnitude: Uint16,
}

struct HapticCustom {
	type: Uint16,
	direction: HapticDirection,
	length: Uint32,
	delay: Uint16,
	button: Uint16,
	interval: Uint16,
	channels: Uint8,
	period: Uint16,
	samples: Uint16,
	data: ?*Uint16,
	attack_length: Uint16,
	attack_level: Uint16,
	fade_length: Uint16,
	fade_level: Uint16,
}

union HapticEffect {
	type: Uint16,
	constant: HapticConstant,
	periodic: HapticPeriodic,
	condition: HapticCondition,
	ramp: HapticRamp,
	leftright: HapticLeftRight,
	custom: HapticCustom,
}

HapticID :: Uint32;

GetHaptics :: fn(
	count: ?*i32
) -> ?*HapticID #foreign #link="SDL_GetHaptics";

GetHapticNameForID :: fn(
	instance_id: HapticID
) -> ?*u8 #foreign #link="SDL_GetHapticNameForID";

OpenHaptic :: fn(
	instance_id: HapticID
) -> ?*Haptic #foreign #link="SDL_OpenHaptic";

GetHapticFromID :: fn(
	instance_id: HapticID
) -> ?*Haptic #foreign #link="SDL_GetHapticFromID";

GetHapticID :: fn(
	haptic: ?*Haptic
) -> HapticID #foreign #link="SDL_GetHapticID";

GetHapticName :: fn(
	haptic: ?*Haptic
) -> ?*u8 #foreign #link="SDL_GetHapticName";

IsMouseHaptic :: fn() -> bool #foreign #link="SDL_IsMouseHaptic";

OpenHapticFromMouse :: fn() -> ?*Haptic #foreign #link="SDL_OpenHapticFromMouse";

IsJoystickHaptic :: fn(
	joystick: ?*Joystick
) -> bool #foreign #link="SDL_IsJoystickHaptic";

OpenHapticFromJoystick :: fn(
	joystick: ?*Joystick
) -> ?*Haptic #foreign #link="SDL_OpenHapticFromJoystick";

CloseHaptic :: fn(
	haptic: ?*Haptic
) #foreign #link="SDL_CloseHaptic";

GetMaxHapticEffects :: fn(
	haptic: ?*Haptic
) -> i32 #foreign #link="SDL_GetMaxHapticEffects";

GetMaxHapticEffectsPlaying :: fn(
	haptic: ?*Haptic
) -> i32 #foreign #link="SDL_GetMaxHapticEffectsPlaying";

GetHapticFeatures :: fn(
	haptic: ?*Haptic
) -> Uint32 #foreign #link="SDL_GetHapticFeatures";

GetNumHapticAxes :: fn(
	haptic: ?*Haptic
) -> i32 #foreign #link="SDL_GetNumHapticAxes";

HapticEffectSupported :: fn(
	haptic: ?*Haptic,
	effect: ?*HapticEffect
) -> bool #foreign #link="SDL_HapticEffectSupported";

CreateHapticEffect :: fn(
	haptic: ?*Haptic,
	effect: ?*HapticEffect
) -> i32 #foreign #link="SDL_CreateHapticEffect";

UpdateHapticEffect :: fn(
	haptic: ?*Haptic,
	effect: i32,
	data: ?*HapticEffect
) -> bool #foreign #link="SDL_UpdateHapticEffect";

RunHapticEffect :: fn(
	haptic: ?*Haptic,
	effect: i32,
	iterations: Uint32
) -> bool #foreign #link="SDL_RunHapticEffect";

StopHapticEffect :: fn(
	haptic: ?*Haptic,
	effect: i32
) -> bool #foreign #link="SDL_StopHapticEffect";

DestroyHapticEffect :: fn(
	haptic: ?*Haptic,
	effect: i32
) #foreign #link="SDL_DestroyHapticEffect";

GetHapticEffectStatus :: fn(
	haptic: ?*Haptic,
	effect: i32
) -> bool #foreign #link="SDL_GetHapticEffectStatus";

SetHapticGain :: fn(
	haptic: ?*Haptic,
	gain: i32
) -> bool #foreign #link="SDL_SetHapticGain";

SetHapticAutocenter :: fn(
	haptic: ?*Haptic,
	autocenter: i32
) -> bool #foreign #link="SDL_SetHapticAutocenter";

PauseHaptic :: fn(
	haptic: ?*Haptic
) -> bool #foreign #link="SDL_PauseHaptic";

ResumeHaptic :: fn(
	haptic: ?*Haptic
) -> bool #foreign #link="SDL_ResumeHaptic";

StopHapticEffects :: fn(
	haptic: ?*Haptic
) -> bool #foreign #link="SDL_StopHapticEffects";

HapticRumbleSupported :: fn(
	haptic: ?*Haptic
) -> bool #foreign #link="SDL_HapticRumbleSupported";

InitHapticRumble :: fn(
	haptic: ?*Haptic
) -> bool #foreign #link="SDL_InitHapticRumble";

PlayHapticRumble :: fn(
	haptic: ?*Haptic,
	strength: f32,
	length: Uint32
) -> bool #foreign #link="SDL_PlayHapticRumble";

StopHapticRumble :: fn(
	haptic: ?*Haptic
) -> bool #foreign #link="SDL_StopHapticRumble";

struct hid_device {
}

enum hid_bus_type: u32 {
	HID_API_BUS_UNKNOWN = 0x0,
	HID_API_BUS_USB = 0x1,
	HID_API_BUS_BLUETOOTH = 0x2,
	HID_API_BUS_I2C = 0x3,
	HID_API_BUS_SPI = 0x4,
}

struct hid_device_info {
	path: ?*u8,
	vendor_id: u16,
	product_id: u16,
	serial_number: ?*wchar_t,
	release_number: u16,
	manufacturer_string: ?*wchar_t,
	product_string: ?*wchar_t,
	usage_page: u16,
	usage: u16,
	interface_number: i32,
	interface_class: i32,
	interface_subclass: i32,
	interface_protocol: i32,
	bus_type: hid_bus_type,
	next: ?*hid_device_info,
}

hid_init :: fn() -> i32 #foreign #link="SDL_hid_init";

hid_exit :: fn() -> i32 #foreign #link="SDL_hid_exit";

hid_device_change_count :: fn() -> Uint32 #foreign #link="SDL_hid_device_change_count";

hid_enumerate :: fn(
	vendor_id: u16,
	product_id: u16
) -> ?*hid_device_info #foreign #link="SDL_hid_enumerate";

hid_free_enumeration :: fn(
	devs: ?*hid_device_info
) #foreign #link="SDL_hid_free_enumeration";

hid_open :: fn(
	vendor_id: u16,
	product_id: u16,
	serial_number: ?*wchar_t
) -> ?*hid_device #foreign #link="SDL_hid_open";

hid_open_path :: fn(
	path: ?*u8
) -> ?*hid_device #foreign #link="SDL_hid_open_path";

hid_write :: fn(
	dev: ?*hid_device,
	data: ?*u8,
	length: uint
) -> i32 #foreign #link="SDL_hid_write";

hid_read_timeout :: fn(
	dev: ?*hid_device,
	data: ?*u8,
	length: uint,
	milliseconds: i32
) -> i32 #foreign #link="SDL_hid_read_timeout";

hid_read :: fn(
	dev: ?*hid_device,
	data: ?*u8,
	length: uint
) -> i32 #foreign #link="SDL_hid_read";

hid_set_nonblocking :: fn(
	dev: ?*hid_device,
	nonblock: i32
) -> i32 #foreign #link="SDL_hid_set_nonblocking";

hid_send_feature_report :: fn(
	dev: ?*hid_device,
	data: ?*u8,
	length: uint
) -> i32 #foreign #link="SDL_hid_send_feature_report";

hid_get_feature_report :: fn(
	dev: ?*hid_device,
	data: ?*u8,
	length: uint
) -> i32 #foreign #link="SDL_hid_get_feature_report";

hid_get_input_report :: fn(
	dev: ?*hid_device,
	data: ?*u8,
	length: uint
) -> i32 #foreign #link="SDL_hid_get_input_report";

hid_close :: fn(
	dev: ?*hid_device
) -> i32 #foreign #link="SDL_hid_close";

hid_get_manufacturer_string :: fn(
	dev: ?*hid_device,
	string: ?*wchar_t,
	maxlen: uint
) -> i32 #foreign #link="SDL_hid_get_manufacturer_string";

hid_get_product_string :: fn(
	dev: ?*hid_device,
	string: ?*wchar_t,
	maxlen: uint
) -> i32 #foreign #link="SDL_hid_get_product_string";

hid_get_serial_number_string :: fn(
	dev: ?*hid_device,
	string: ?*wchar_t,
	maxlen: uint
) -> i32 #foreign #link="SDL_hid_get_serial_number_string";

hid_get_indexed_string :: fn(
	dev: ?*hid_device,
	string_index: i32,
	string: ?*wchar_t,
	maxlen: uint
) -> i32 #foreign #link="SDL_hid_get_indexed_string";

hid_get_device_info :: fn(
	dev: ?*hid_device
) -> ?*hid_device_info #foreign #link="SDL_hid_get_device_info";

hid_get_report_descriptor :: fn(
	dev: ?*hid_device,
	buf: ?*u8,
	buf_size: uint
) -> i32 #foreign #link="SDL_hid_get_report_descriptor";

hid_ble_scan :: fn(
	active: bool
) #foreign #link="SDL_hid_ble_scan";

enum HintPriority: u32 {
	HINT_DEFAULT = 0x0,
	HINT_NORMAL = 0x1,
	HINT_OVERRIDE = 0x2,
}

SetHintWithPriority :: fn(
	name: ?*u8,
	value: ?*u8,
	priority: HintPriority
) -> bool #foreign #link="SDL_SetHintWithPriority";

SetHint :: fn(
	name: ?*u8,
	value: ?*u8
) -> bool #foreign #link="SDL_SetHint";

ResetHint :: fn(
	name: ?*u8
) -> bool #foreign #link="SDL_ResetHint";

ResetHints :: fn() #foreign #link="SDL_ResetHints";

GetHint :: fn(
	name: ?*u8
) -> ?*u8 #foreign #link="SDL_GetHint";

GetHintBoolean :: fn(
	name: ?*u8,
	default_value: bool
) -> bool #foreign #link="SDL_GetHintBoolean";

HintCallback :: ?*fn(a: ?*, b: ?*u8, c: ?*u8, d: ?*u8) #foreign;

AddHintCallback :: fn(
	name: ?*u8,
	callback: HintCallback,
	userdata: ?*
) -> bool #foreign #link="SDL_AddHintCallback";

RemoveHintCallback :: fn(
	name: ?*u8,
	callback: HintCallback,
	userdata: ?*
) #foreign #link="SDL_RemoveHintCallback";

InitFlags :: Uint32;

enum AppResult: u32 {
	APP_CONTINUE = 0x0,
	APP_SUCCESS = 0x1,
	APP_FAILURE = 0x2,
}

AppInit_func :: ?*fn(a: ?*?*, b: i32, c: *?*u8) -> AppResult #foreign;

AppIterate_func :: ?*fn(a: ?*) -> AppResult #foreign;

AppEvent_func :: ?*fn(a: ?*, b: ?*Event) -> AppResult #foreign;

AppQuit_func :: ?*fn(a: ?*, b: AppResult) #foreign;

Init :: fn(
	flags: InitFlags
) -> bool #foreign #link="SDL_Init";

InitSubSystem :: fn(
	flags: InitFlags
) -> bool #foreign #link="SDL_InitSubSystem";

QuitSubSystem :: fn(
	flags: InitFlags
) #foreign #link="SDL_QuitSubSystem";

WasInit :: fn(
	flags: InitFlags
) -> InitFlags #foreign #link="SDL_WasInit";

Quit :: fn() #foreign #link="SDL_Quit";

IsMainThread :: fn() -> bool #foreign #link="SDL_IsMainThread";

MainThreadCallback :: ?*fn(a: ?*) #foreign;

RunOnMainThread :: fn(
	callback: MainThreadCallback,
	userdata: ?*,
	wait_complete: bool
) -> bool #foreign #link="SDL_RunOnMainThread";

SetAppMetadata :: fn(
	appname: ?*u8,
	appversion: ?*u8,
	appidentifier: ?*u8
) -> bool #foreign #link="SDL_SetAppMetadata";

SetAppMetadataProperty :: fn(
	name: ?*u8,
	value: ?*u8
) -> bool #foreign #link="SDL_SetAppMetadataProperty";

GetAppMetadataProperty :: fn(
	name: ?*u8
) -> ?*u8 #foreign #link="SDL_GetAppMetadataProperty";

struct SharedObject {
}

LoadObject :: fn(
	sofile: ?*u8
) -> ?*SharedObject #foreign #link="SDL_LoadObject";

LoadFunction :: fn(
	handle: ?*SharedObject,
	name: ?*u8
) -> FunctionPointer #foreign #link="SDL_LoadFunction";

UnloadObject :: fn(
	handle: ?*SharedObject
) #foreign #link="SDL_UnloadObject";

struct Locale {
	language: ?*u8,
	country: ?*u8,
}

GetPreferredLocales :: fn(
	count: ?*i32
) -> ?*?*Locale #foreign #link="SDL_GetPreferredLocales";

enum LogCategory: u32 {
	LOG_CATEGORY_APPLICATION = 0x0,
	LOG_CATEGORY_ERROR = 0x1,
	LOG_CATEGORY_ASSERT = 0x2,
	LOG_CATEGORY_SYSTEM = 0x3,
	LOG_CATEGORY_AUDIO = 0x4,
	LOG_CATEGORY_VIDEO = 0x5,
	LOG_CATEGORY_RENDER = 0x6,
	LOG_CATEGORY_INPUT = 0x7,
	LOG_CATEGORY_TEST = 0x8,
	LOG_CATEGORY_GPU = 0x9,
	LOG_CATEGORY_RESERVED2 = 0xa,
	LOG_CATEGORY_RESERVED3 = 0xb,
	LOG_CATEGORY_RESERVED4 = 0xc,
	LOG_CATEGORY_RESERVED5 = 0xd,
	LOG_CATEGORY_RESERVED6 = 0xe,
	LOG_CATEGORY_RESERVED7 = 0xf,
	LOG_CATEGORY_RESERVED8 = 0x10,
	LOG_CATEGORY_RESERVED9 = 0x11,
	LOG_CATEGORY_RESERVED10 = 0x12,
	LOG_CATEGORY_CUSTOM = 0x13,
}

enum LogPriority: u32 {
	LOG_PRIORITY_INVALID = 0x0,
	LOG_PRIORITY_TRACE = 0x1,
	LOG_PRIORITY_VERBOSE = 0x2,
	LOG_PRIORITY_DEBUG = 0x3,
	LOG_PRIORITY_INFO = 0x4,
	LOG_PRIORITY_WARN = 0x5,
	LOG_PRIORITY_ERROR = 0x6,
	LOG_PRIORITY_CRITICAL = 0x7,
	LOG_PRIORITY_COUNT = 0x8,
}

SetLogPriorities :: fn(
	priority: LogPriority
) #foreign #link="SDL_SetLogPriorities";

SetLogPriority :: fn(
	category: i32,
	priority: LogPriority
) #foreign #link="SDL_SetLogPriority";

GetLogPriority :: fn(
	category: i32
) -> LogPriority #foreign #link="SDL_GetLogPriority";

ResetLogPriorities :: fn() #foreign #link="SDL_ResetLogPriorities";

SetLogPriorityPrefix :: fn(
	priority: LogPriority,
	prefix: ?*u8
) -> bool #foreign #link="SDL_SetLogPriorityPrefix";

Log :: fn(
	fmt: ?*u8
) #foreign #link="SDL_Log";

LogTrace :: fn(
	category: i32,
	fmt: ?*u8
) #foreign #link="SDL_LogTrace";

LogVerbose :: fn(
	category: i32,
	fmt: ?*u8
) #foreign #link="SDL_LogVerbose";

LogDebug :: fn(
	category: i32,
	fmt: ?*u8
) #foreign #link="SDL_LogDebug";

LogInfo :: fn(
	category: i32,
	fmt: ?*u8
) #foreign #link="SDL_LogInfo";

LogWarn :: fn(
	category: i32,
	fmt: ?*u8
) #foreign #link="SDL_LogWarn";

LogError :: fn(
	category: i32,
	fmt: ?*u8
) #foreign #link="SDL_LogError";

LogCritical :: fn(
	category: i32,
	fmt: ?*u8
) #foreign #link="SDL_LogCritical";

LogMessage :: fn(
	category: i32,
	priority: LogPriority,
	fmt: ?*u8
) #foreign #link="SDL_LogMessage";

LogOutputFunction :: ?*fn(a: ?*, b: i32, c: LogPriority, d: ?*u8) #foreign;

GetDefaultLogOutputFunction :: fn() -> LogOutputFunction #foreign #link="SDL_GetDefaultLogOutputFunction";

GetLogOutputFunction :: fn(
	callback: ?*LogOutputFunction,
	userdata: ?*?*
) #foreign #link="SDL_GetLogOutputFunction";

SetLogOutputFunction :: fn(
	callback: LogOutputFunction,
	userdata: ?*
) #foreign #link="SDL_SetLogOutputFunction";

MessageBoxFlags :: Uint32;

MessageBoxButtonFlags :: Uint32;

struct MessageBoxButtonData {
	flags: MessageBoxButtonFlags,
	buttonID: i32,
	text: ?*u8,
}

struct MessageBoxColor {
	r: Uint8,
	g: Uint8,
	b: Uint8,
}

enum MessageBoxColorType: u32 {
	MESSAGEBOX_COLOR_BACKGROUND = 0x0,
	MESSAGEBOX_COLOR_TEXT = 0x1,
	MESSAGEBOX_COLOR_BUTTON_BORDER = 0x2,
	MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 0x3,
	MESSAGEBOX_COLOR_BUTTON_SELECTED = 0x4,
	MESSAGEBOX_COLOR_COUNT = 0x5,
}

struct MessageBoxColorScheme {
	colors: [5]MessageBoxColor,
}

struct MessageBoxData {
	flags: MessageBoxFlags,
	window: ?*Window,
	title: ?*u8,
	message: ?*u8,
	numbuttons: i32,
	buttons: ?*MessageBoxButtonData,
	colorScheme: ?*MessageBoxColorScheme,
}

ShowMessageBox :: fn(
	messageboxdata: ?*MessageBoxData,
	buttonid: ?*i32
) -> bool #foreign #link="SDL_ShowMessageBox";

ShowSimpleMessageBox :: fn(
	flags: MessageBoxFlags,
	title: ?*u8,
	message: ?*u8,
	window: ?*Window
) -> bool #foreign #link="SDL_ShowSimpleMessageBox";

MetalView :: ?*;

Metal_CreateView :: fn(
	window: ?*Window
) -> MetalView #foreign #link="SDL_Metal_CreateView";

Metal_DestroyView :: fn(
	view: MetalView
) #foreign #link="SDL_Metal_DestroyView";

Metal_GetLayer :: fn(
	view: MetalView
) -> ?* #foreign #link="SDL_Metal_GetLayer";

OpenURL :: fn(
	url: ?*u8
) -> bool #foreign #link="SDL_OpenURL";

GetPlatform :: fn() -> ?*u8 #foreign #link="SDL_GetPlatform";

struct Process {
}

CreateProcess :: fn(
	args: ?*?*u8,
	pipe_stdio: bool
) -> ?*Process #foreign #link="SDL_CreateProcess";

enum ProcessIO: u32 {
	PROCESS_STDIO_INHERITED = 0x0,
	PROCESS_STDIO_NULL = 0x1,
	PROCESS_STDIO_APP = 0x2,
	PROCESS_STDIO_REDIRECT = 0x3,
}

CreateProcessWithProperties :: fn(
	props: PropertiesID
) -> ?*Process #foreign #link="SDL_CreateProcessWithProperties";

GetProcessProperties :: fn(
	process: ?*Process
) -> PropertiesID #foreign #link="SDL_GetProcessProperties";

ReadProcess :: fn(
	process: ?*Process,
	datasize: ?*uint,
	exitcode: ?*i32
) -> ?* #foreign #link="SDL_ReadProcess";

GetProcessInput :: fn(
	process: ?*Process
) -> ?*IOStream #foreign #link="SDL_GetProcessInput";

GetProcessOutput :: fn(
	process: ?*Process
) -> ?*IOStream #foreign #link="SDL_GetProcessOutput";

KillProcess :: fn(
	process: ?*Process,
	force: bool
) -> bool #foreign #link="SDL_KillProcess";

WaitProcess :: fn(
	process: ?*Process,
	block: bool,
	exitcode: ?*i32
) -> bool #foreign #link="SDL_WaitProcess";

DestroyProcess :: fn(
	process: ?*Process
) #foreign #link="SDL_DestroyProcess";

struct Vertex {
	position: FPoint,
	color: FColor,
	tex_coord: FPoint,
}

enum TextureAccess: u32 {
	STATIC = 0x0,
	STREAMING = 0x1,
	TARGET = 0x2,
}

enum RendererLogicalPresentation: u32 {
	LOGICAL_PRESENTATION_DISABLED = 0x0,
	LOGICAL_PRESENTATION_STRETCH = 0x1,
	LOGICAL_PRESENTATION_LETTERBOX = 0x2,
	LOGICAL_PRESENTATION_OVERSCAN = 0x3,
	LOGICAL_PRESENTATION_INTEGER_SCALE = 0x4,
}

struct Renderer {
}

struct Texture {
	format: PixelFormat,
	w: i32,
	h: i32,
	refcount: i32,
}

GetNumRenderDrivers :: fn() -> i32 #foreign #link="SDL_GetNumRenderDrivers";

GetRenderDriver :: fn(
	index: i32
) -> ?*u8 #foreign #link="SDL_GetRenderDriver";

CreateWindowAndRenderer :: fn(
	title: ?*u8,
	width: i32,
	height: i32,
	window_flags: WindowFlags,
	window: ?*?*Window,
	renderer: ?*?*Renderer
) -> bool #foreign #link="SDL_CreateWindowAndRenderer";

CreateRenderer :: fn(
	window: ?*Window,
	name: ?*u8
) -> ?*Renderer #foreign #link="SDL_CreateRenderer";

CreateRendererWithProperties :: fn(
	props: PropertiesID
) -> ?*Renderer #foreign #link="SDL_CreateRendererWithProperties";

CreateSoftwareRenderer :: fn(
	surface: ?*Surface
) -> ?*Renderer #foreign #link="SDL_CreateSoftwareRenderer";

GetRenderer :: fn(
	window: ?*Window
) -> ?*Renderer #foreign #link="SDL_GetRenderer";

GetRenderWindow :: fn(
	renderer: ?*Renderer
) -> ?*Window #foreign #link="SDL_GetRenderWindow";

GetRendererName :: fn(
	renderer: ?*Renderer
) -> ?*u8 #foreign #link="SDL_GetRendererName";

GetRendererProperties :: fn(
	renderer: ?*Renderer
) -> PropertiesID #foreign #link="SDL_GetRendererProperties";

GetRenderOutputSize :: fn(
	renderer: ?*Renderer,
	w: ?*i32,
	h: ?*i32
) -> bool #foreign #link="SDL_GetRenderOutputSize";

GetCurrentRenderOutputSize :: fn(
	renderer: ?*Renderer,
	w: ?*i32,
	h: ?*i32
) -> bool #foreign #link="SDL_GetCurrentRenderOutputSize";

CreateTexture :: fn(
	renderer: ?*Renderer,
	format: PixelFormat,
	access: TextureAccess,
	w: i32,
	h: i32
) -> ?*Texture #foreign #link="SDL_CreateTexture";

CreateTextureFromSurface :: fn(
	renderer: ?*Renderer,
	surface: ?*Surface
) -> ?*Texture #foreign #link="SDL_CreateTextureFromSurface";

CreateTextureWithProperties :: fn(
	renderer: ?*Renderer,
	props: PropertiesID
) -> ?*Texture #foreign #link="SDL_CreateTextureWithProperties";

GetTextureProperties :: fn(
	texture: ?*Texture
) -> PropertiesID #foreign #link="SDL_GetTextureProperties";

GetRendererFromTexture :: fn(
	texture: ?*Texture
) -> ?*Renderer #foreign #link="SDL_GetRendererFromTexture";

GetTextureSize :: fn(
	texture: ?*Texture,
	w: ?*f32,
	h: ?*f32
) -> bool #foreign #link="SDL_GetTextureSize";

SetTextureColorMod :: fn(
	texture: ?*Texture,
	r: Uint8,
	g: Uint8,
	b: Uint8
) -> bool #foreign #link="SDL_SetTextureColorMod";

SetTextureColorModFloat :: fn(
	texture: ?*Texture,
	r: f32,
	g: f32,
	b: f32
) -> bool #foreign #link="SDL_SetTextureColorModFloat";

GetTextureColorMod :: fn(
	texture: ?*Texture,
	r: ?*Uint8,
	g: ?*Uint8,
	b: ?*Uint8
) -> bool #foreign #link="SDL_GetTextureColorMod";

GetTextureColorModFloat :: fn(
	texture: ?*Texture,
	r: ?*f32,
	g: ?*f32,
	b: ?*f32
) -> bool #foreign #link="SDL_GetTextureColorModFloat";

SetTextureAlphaMod :: fn(
	texture: ?*Texture,
	alpha: Uint8
) -> bool #foreign #link="SDL_SetTextureAlphaMod";

SetTextureAlphaModFloat :: fn(
	texture: ?*Texture,
	alpha: f32
) -> bool #foreign #link="SDL_SetTextureAlphaModFloat";

GetTextureAlphaMod :: fn(
	texture: ?*Texture,
	alpha: ?*Uint8
) -> bool #foreign #link="SDL_GetTextureAlphaMod";

GetTextureAlphaModFloat :: fn(
	texture: ?*Texture,
	alpha: ?*f32
) -> bool #foreign #link="SDL_GetTextureAlphaModFloat";

SetTextureBlendMode :: fn(
	texture: ?*Texture,
	blendMode: BlendMode
) -> bool #foreign #link="SDL_SetTextureBlendMode";

GetTextureBlendMode :: fn(
	texture: ?*Texture,
	blendMode: ?*BlendMode
) -> bool #foreign #link="SDL_GetTextureBlendMode";

SetTextureScaleMode :: fn(
	texture: ?*Texture,
	scaleMode: ScaleMode
) -> bool #foreign #link="SDL_SetTextureScaleMode";

GetTextureScaleMode :: fn(
	texture: ?*Texture,
	scaleMode: ?*ScaleMode
) -> bool #foreign #link="SDL_GetTextureScaleMode";

UpdateTexture :: fn(
	texture: ?*Texture,
	rect: ?*Rect,
	pixels: ?*,
	pitch: i32
) -> bool #foreign #link="SDL_UpdateTexture";

UpdateYUVTexture :: fn(
	texture: ?*Texture,
	rect: ?*Rect,
	Yplane: ?*Uint8,
	Ypitch: i32,
	Uplane: ?*Uint8,
	Upitch: i32,
	Vplane: ?*Uint8,
	Vpitch: i32
) -> bool #foreign #link="SDL_UpdateYUVTexture";

UpdateNVTexture :: fn(
	texture: ?*Texture,
	rect: ?*Rect,
	Yplane: ?*Uint8,
	Ypitch: i32,
	UVplane: ?*Uint8,
	UVpitch: i32
) -> bool #foreign #link="SDL_UpdateNVTexture";

LockTexture :: fn(
	texture: ?*Texture,
	rect: ?*Rect,
	pixels: ?*?*,
	pitch: ?*i32
) -> bool #foreign #link="SDL_LockTexture";

LockTextureToSurface :: fn(
	texture: ?*Texture,
	rect: ?*Rect,
	surface: ?*?*Surface
) -> bool #foreign #link="SDL_LockTextureToSurface";

UnlockTexture :: fn(
	texture: ?*Texture
) #foreign #link="SDL_UnlockTexture";

SetRenderTarget :: fn(
	renderer: ?*Renderer,
	texture: ?*Texture
) -> bool #foreign #link="SDL_SetRenderTarget";

GetRenderTarget :: fn(
	renderer: ?*Renderer
) -> ?*Texture #foreign #link="SDL_GetRenderTarget";

SetRenderLogicalPresentation :: fn(
	renderer: ?*Renderer,
	w: i32,
	h: i32,
	mode: RendererLogicalPresentation
) -> bool #foreign #link="SDL_SetRenderLogicalPresentation";

GetRenderLogicalPresentation :: fn(
	renderer: ?*Renderer,
	w: ?*i32,
	h: ?*i32,
	mode: ?*RendererLogicalPresentation
) -> bool #foreign #link="SDL_GetRenderLogicalPresentation";

GetRenderLogicalPresentationRect :: fn(
	renderer: ?*Renderer,
	rect: ?*FRect
) -> bool #foreign #link="SDL_GetRenderLogicalPresentationRect";

RenderCoordinatesFromWindow :: fn(
	renderer: ?*Renderer,
	window_x: f32,
	window_y: f32,
	x: ?*f32,
	y: ?*f32
) -> bool #foreign #link="SDL_RenderCoordinatesFromWindow";

RenderCoordinatesToWindow :: fn(
	renderer: ?*Renderer,
	x: f32,
	y: f32,
	window_x: ?*f32,
	window_y: ?*f32
) -> bool #foreign #link="SDL_RenderCoordinatesToWindow";

ConvertEventToRenderCoordinates :: fn(
	renderer: ?*Renderer,
	event: ?*Event
) -> bool #foreign #link="SDL_ConvertEventToRenderCoordinates";

SetRenderViewport :: fn(
	renderer: ?*Renderer,
	rect: ?*Rect
) -> bool #foreign #link="SDL_SetRenderViewport";

GetRenderViewport :: fn(
	renderer: ?*Renderer,
	rect: ?*Rect
) -> bool #foreign #link="SDL_GetRenderViewport";

RenderViewportSet :: fn(
	renderer: ?*Renderer
) -> bool #foreign #link="SDL_RenderViewportSet";

GetRenderSafeArea :: fn(
	renderer: ?*Renderer,
	rect: ?*Rect
) -> bool #foreign #link="SDL_GetRenderSafeArea";

SetRenderClipRect :: fn(
	renderer: ?*Renderer,
	rect: ?*Rect
) -> bool #foreign #link="SDL_SetRenderClipRect";

GetRenderClipRect :: fn(
	renderer: ?*Renderer,
	rect: ?*Rect
) -> bool #foreign #link="SDL_GetRenderClipRect";

RenderClipEnabled :: fn(
	renderer: ?*Renderer
) -> bool #foreign #link="SDL_RenderClipEnabled";

SetRenderScale :: fn(
	renderer: ?*Renderer,
	scaleX: f32,
	scaleY: f32
) -> bool #foreign #link="SDL_SetRenderScale";

GetRenderScale :: fn(
	renderer: ?*Renderer,
	scaleX: ?*f32,
	scaleY: ?*f32
) -> bool #foreign #link="SDL_GetRenderScale";

SetRenderDrawColor :: fn(
	renderer: ?*Renderer,
	r: Uint8,
	g: Uint8,
	b: Uint8,
	a: Uint8
) -> bool #foreign #link="SDL_SetRenderDrawColor";

SetRenderDrawColorFloat :: fn(
	renderer: ?*Renderer,
	r: f32,
	g: f32,
	b: f32,
	a: f32
) -> bool #foreign #link="SDL_SetRenderDrawColorFloat";

GetRenderDrawColor :: fn(
	renderer: ?*Renderer,
	r: ?*Uint8,
	g: ?*Uint8,
	b: ?*Uint8,
	a: ?*Uint8
) -> bool #foreign #link="SDL_GetRenderDrawColor";

GetRenderDrawColorFloat :: fn(
	renderer: ?*Renderer,
	r: ?*f32,
	g: ?*f32,
	b: ?*f32,
	a: ?*f32
) -> bool #foreign #link="SDL_GetRenderDrawColorFloat";

SetRenderColorScale :: fn(
	renderer: ?*Renderer,
	scale: f32
) -> bool #foreign #link="SDL_SetRenderColorScale";

GetRenderColorScale :: fn(
	renderer: ?*Renderer,
	scale: ?*f32
) -> bool #foreign #link="SDL_GetRenderColorScale";

SetRenderDrawBlendMode :: fn(
	renderer: ?*Renderer,
	blendMode: BlendMode
) -> bool #foreign #link="SDL_SetRenderDrawBlendMode";

GetRenderDrawBlendMode :: fn(
	renderer: ?*Renderer,
	blendMode: ?*BlendMode
) -> bool #foreign #link="SDL_GetRenderDrawBlendMode";

RenderClear :: fn(
	renderer: ?*Renderer
) -> bool #foreign #link="SDL_RenderClear";

RenderPoint :: fn(
	renderer: ?*Renderer,
	x: f32,
	y: f32
) -> bool #foreign #link="SDL_RenderPoint";

RenderPoints :: fn(
	renderer: ?*Renderer,
	points: ?*FPoint,
	count: i32
) -> bool #foreign #link="SDL_RenderPoints";

RenderLine :: fn(
	renderer: ?*Renderer,
	x1: f32,
	y1: f32,
	x2: f32,
	y2: f32
) -> bool #foreign #link="SDL_RenderLine";

RenderLines :: fn(
	renderer: ?*Renderer,
	points: ?*FPoint,
	count: i32
) -> bool #foreign #link="SDL_RenderLines";

RenderRect :: fn(
	renderer: ?*Renderer,
	rect: ?*FRect
) -> bool #foreign #link="SDL_RenderRect";

RenderRects :: fn(
	renderer: ?*Renderer,
	rects: ?*FRect,
	count: i32
) -> bool #foreign #link="SDL_RenderRects";

RenderFillRect :: fn(
	renderer: ?*Renderer,
	rect: ?*FRect
) -> bool #foreign #link="SDL_RenderFillRect";

RenderFillRects :: fn(
	renderer: ?*Renderer,
	rects: ?*FRect,
	count: i32
) -> bool #foreign #link="SDL_RenderFillRects";

RenderTexture :: fn(
	renderer: ?*Renderer,
	texture: ?*Texture,
	srcrect: ?*FRect,
	dstrect: ?*FRect
) -> bool #foreign #link="SDL_RenderTexture";

RenderTextureRotated :: fn(
	renderer: ?*Renderer,
	texture: ?*Texture,
	srcrect: ?*FRect,
	dstrect: ?*FRect,
	angle: f64,
	center: ?*FPoint,
	flip: FlipMode
) -> bool #foreign #link="SDL_RenderTextureRotated";

RenderTextureAffine :: fn(
	renderer: ?*Renderer,
	texture: ?*Texture,
	srcrect: ?*FRect,
	origin: ?*FPoint,
	right: ?*FPoint,
	down: ?*FPoint
) -> bool #foreign #link="SDL_RenderTextureAffine";

RenderTextureTiled :: fn(
	renderer: ?*Renderer,
	texture: ?*Texture,
	srcrect: ?*FRect,
	scale: f32,
	dstrect: ?*FRect
) -> bool #foreign #link="SDL_RenderTextureTiled";

RenderTexture9Grid :: fn(
	renderer: ?*Renderer,
	texture: ?*Texture,
	srcrect: ?*FRect,
	left_width: f32,
	right_width: f32,
	top_height: f32,
	bottom_height: f32,
	scale: f32,
	dstrect: ?*FRect
) -> bool #foreign #link="SDL_RenderTexture9Grid";

RenderGeometry :: fn(
	renderer: ?*Renderer,
	texture: ?*Texture,
	vertices: ?*Vertex,
	num_vertices: i32,
	indices: ?*i32,
	num_indices: i32
) -> bool #foreign #link="SDL_RenderGeometry";

RenderGeometryRaw :: fn(
	renderer: ?*Renderer,
	texture: ?*Texture,
	xy: ?*f32,
	xy_stride: i32,
	color: ?*FColor,
	color_stride: i32,
	uv: ?*f32,
	uv_stride: i32,
	num_vertices: i32,
	indices: ?*,
	num_indices: i32,
	size_indices: i32
) -> bool #foreign #link="SDL_RenderGeometryRaw";

RenderReadPixels :: fn(
	renderer: ?*Renderer,
	rect: ?*Rect
) -> ?*Surface #foreign #link="SDL_RenderReadPixels";

RenderPresent :: fn(
	renderer: ?*Renderer
) -> bool #foreign #link="SDL_RenderPresent";

DestroyTexture :: fn(
	texture: ?*Texture
) #foreign #link="SDL_DestroyTexture";

DestroyRenderer :: fn(
	renderer: ?*Renderer
) #foreign #link="SDL_DestroyRenderer";

FlushRenderer :: fn(
	renderer: ?*Renderer
) -> bool #foreign #link="SDL_FlushRenderer";

GetRenderMetalLayer :: fn(
	renderer: ?*Renderer
) -> ?* #foreign #link="SDL_GetRenderMetalLayer";

GetRenderMetalCommandEncoder :: fn(
	renderer: ?*Renderer
) -> ?* #foreign #link="SDL_GetRenderMetalCommandEncoder";

AddVulkanRenderSemaphores :: fn(
	renderer: ?*Renderer,
	wait_stage_mask: Uint32,
	wait_semaphore: Sint64,
	signal_semaphore: Sint64
) -> bool #foreign #link="SDL_AddVulkanRenderSemaphores";

SetRenderVSync :: fn(
	renderer: ?*Renderer,
	vsync: i32
) -> bool #foreign #link="SDL_SetRenderVSync";

GetRenderVSync :: fn(
	renderer: ?*Renderer,
	vsync: ?*i32
) -> bool #foreign #link="SDL_GetRenderVSync";

RenderDebugText :: fn(
	renderer: ?*Renderer,
	x: f32,
	y: f32,
	str: ?*u8
) -> bool #foreign #link="SDL_RenderDebugText";

RenderDebugTextFormat :: fn(
	renderer: ?*Renderer,
	x: f32,
	y: f32,
	fmt: ?*u8
) -> bool #foreign #link="SDL_RenderDebugTextFormat";

struct StorageInterface {
	version: Uint32,
	close: ?*fn(a: ?*) -> bool #foreign,
	ready: ?*fn(a: ?*) -> bool #foreign,
	enumerate: ?*fn(a: ?*, b: ?*u8, c: EnumerateDirectoryCallback, d: ?*) -> bool #foreign,
	info: ?*fn(a: ?*, b: ?*u8, c: ?*PathInfo) -> bool #foreign,
	read_file: ?*fn(a: ?*, b: ?*u8, c: ?*, d: Uint64) -> bool #foreign,
	write_file: ?*fn(a: ?*, b: ?*u8, c: ?*, d: Uint64) -> bool #foreign,
	mkdir: ?*fn(a: ?*, b: ?*u8) -> bool #foreign,
	remove: ?*fn(a: ?*, b: ?*u8) -> bool #foreign,
	rename: ?*fn(a: ?*, b: ?*u8, c: ?*u8) -> bool #foreign,
	copy: ?*fn(a: ?*, b: ?*u8, c: ?*u8) -> bool #foreign,
	space_remaining: ?*fn(a: ?*) -> Uint64 #foreign,
}

struct Storage {
}

OpenTitleStorage :: fn(
	override: ?*u8,
	props: PropertiesID
) -> ?*Storage #foreign #link="SDL_OpenTitleStorage";

OpenUserStorage :: fn(
	org: ?*u8,
	app: ?*u8,
	props: PropertiesID
) -> ?*Storage #foreign #link="SDL_OpenUserStorage";

OpenFileStorage :: fn(
	path: ?*u8
) -> ?*Storage #foreign #link="SDL_OpenFileStorage";

OpenStorage :: fn(
	iface: ?*StorageInterface,
	userdata: ?*
) -> ?*Storage #foreign #link="SDL_OpenStorage";

CloseStorage :: fn(
	storage: ?*Storage
) -> bool #foreign #link="SDL_CloseStorage";

StorageReady :: fn(
	storage: ?*Storage
) -> bool #foreign #link="SDL_StorageReady";

GetStorageFileSize :: fn(
	storage: ?*Storage,
	path: ?*u8,
	length: ?*Uint64
) -> bool #foreign #link="SDL_GetStorageFileSize";

ReadStorageFile :: fn(
	storage: ?*Storage,
	path: ?*u8,
	destination: ?*,
	length: Uint64
) -> bool #foreign #link="SDL_ReadStorageFile";

WriteStorageFile :: fn(
	storage: ?*Storage,
	path: ?*u8,
	source: ?*,
	length: Uint64
) -> bool #foreign #link="SDL_WriteStorageFile";

CreateStorageDirectory :: fn(
	storage: ?*Storage,
	path: ?*u8
) -> bool #foreign #link="SDL_CreateStorageDirectory";

EnumerateStorageDirectory :: fn(
	storage: ?*Storage,
	path: ?*u8,
	callback: EnumerateDirectoryCallback,
	userdata: ?*
) -> bool #foreign #link="SDL_EnumerateStorageDirectory";

RemoveStoragePath :: fn(
	storage: ?*Storage,
	path: ?*u8
) -> bool #foreign #link="SDL_RemoveStoragePath";

RenameStoragePath :: fn(
	storage: ?*Storage,
	oldpath: ?*u8,
	newpath: ?*u8
) -> bool #foreign #link="SDL_RenameStoragePath";

CopyStorageFile :: fn(
	storage: ?*Storage,
	oldpath: ?*u8,
	newpath: ?*u8
) -> bool #foreign #link="SDL_CopyStorageFile";

GetStoragePathInfo :: fn(
	storage: ?*Storage,
	path: ?*u8,
	info: ?*PathInfo
) -> bool #foreign #link="SDL_GetStoragePathInfo";

GetStorageSpaceRemaining :: fn(
	storage: ?*Storage
) -> Uint64 #foreign #link="SDL_GetStorageSpaceRemaining";

GlobStorageDirectory :: fn(
	storage: ?*Storage,
	path: ?*u8,
	pattern: ?*u8,
	flags: GlobFlags,
	count: ?*i32
) -> ?*?*u8 #foreign #link="SDL_GlobStorageDirectory";

struct tagMSG {
}

MSG :: tagMSG;

WindowsMessageHook :: ?*fn(a: ?*, b: ?*MSG) -> bool #foreign;

SetWindowsMessageHook :: fn(
	callback: WindowsMessageHook,
	userdata: ?*
) #foreign #link="SDL_SetWindowsMessageHook";

GetDirect3D9AdapterIndex :: fn(
	displayID: DisplayID
) -> i32 #foreign #link="SDL_GetDirect3D9AdapterIndex";

GetDXGIOutputInfo :: fn(
	displayID: DisplayID,
	adapterIndex: ?*i32,
	outputIndex: ?*i32
) -> bool #foreign #link="SDL_GetDXGIOutputInfo";

struct _XEvent {};
XEvent :: _XEvent;

X11EventHook :: ?*fn(a: ?*, b: ?*XEvent) -> bool #foreign;

SetX11EventHook :: fn(
	callback: X11EventHook,
	userdata: ?*
) #foreign #link="SDL_SetX11EventHook";

IsTablet :: fn() -> bool #foreign #link="SDL_IsTablet";

IsTV :: fn() -> bool #foreign #link="SDL_IsTV";

enum Sandbox: u32 {
	NONE = 0x0,
	UNKNOWN_CONTAINER = 0x1,
	FLATPAK = 0x2,
	SNAP = 0x3,
	MACOS = 0x4,
}

GetSandbox :: fn() -> Sandbox #foreign #link="SDL_GetSandbox";

OnApplicationWillTerminate :: fn() #foreign #link="SDL_OnApplicationWillTerminate";

OnApplicationDidReceiveMemoryWarning :: fn() #foreign #link="SDL_OnApplicationDidReceiveMemoryWarning";

OnApplicationWillEnterBackground :: fn() #foreign #link="SDL_OnApplicationWillEnterBackground";

OnApplicationDidEnterBackground :: fn() #foreign #link="SDL_OnApplicationDidEnterBackground";

OnApplicationWillEnterForeground :: fn() #foreign #link="SDL_OnApplicationWillEnterForeground";

OnApplicationDidEnterForeground :: fn() #foreign #link="SDL_OnApplicationDidEnterForeground";

struct DateTime {
	year: i32,
	month: i32,
	day: i32,
	hour: i32,
	minute: i32,
	second: i32,
	nanosecond: i32,
	day_of_week: i32,
	utc_offset: i32,
}

enum DateFormat: u32 {
	DATE_FORMAT_YYYYMMDD = 0x0,
	DATE_FORMAT_DDMMYYYY = 0x1,
	DATE_FORMAT_MMDDYYYY = 0x2,
}

enum TimeFormat: u32 {
	TIME_FORMAT_24HR = 0x0,
	TIME_FORMAT_12HR = 0x1,
}

GetDateTimeLocalePreferences :: fn(
	dateFormat: ?*DateFormat,
	timeFormat: ?*TimeFormat
) -> bool #foreign #link="SDL_GetDateTimeLocalePreferences";

GetCurrentTime :: fn(
	ticks: ?*Time
) -> bool #foreign #link="SDL_GetCurrentTime";

TimeToDateTime :: fn(
	ticks: Time,
	dt: ?*DateTime,
	localTime: bool
) -> bool #foreign #link="SDL_TimeToDateTime";

DateTimeToTime :: fn(
	dt: ?*DateTime,
	ticks: ?*Time
) -> bool #foreign #link="SDL_DateTimeToTime";

TimeToWindows :: fn(
	ticks: Time,
	dwLowDateTime: ?*Uint32,
	dwHighDateTime: ?*Uint32
) #foreign #link="SDL_TimeToWindows";

TimeFromWindows :: fn(
	dwLowDateTime: Uint32,
	dwHighDateTime: Uint32
) -> Time #foreign #link="SDL_TimeFromWindows";

GetDaysInMonth :: fn(
	year: i32,
	month: i32
) -> i32 #foreign #link="SDL_GetDaysInMonth";

GetDayOfYear :: fn(
	year: i32,
	month: i32,
	day: i32
) -> i32 #foreign #link="SDL_GetDayOfYear";

GetDayOfWeek :: fn(
	year: i32,
	month: i32,
	day: i32
) -> i32 #foreign #link="SDL_GetDayOfWeek";

GetTicks :: fn() -> Uint64 #foreign #link="SDL_GetTicks";

GetTicksNS :: fn() -> Uint64 #foreign #link="SDL_GetTicksNS";

GetPerformanceCounter :: fn() -> Uint64 #foreign #link="SDL_GetPerformanceCounter";

GetPerformanceFrequency :: fn() -> Uint64 #foreign #link="SDL_GetPerformanceFrequency";

Delay :: fn(
	ms: Uint32
) #foreign #link="SDL_Delay";

DelayNS :: fn(
	ns: Uint64
) #foreign #link="SDL_DelayNS";

DelayPrecise :: fn(
	ns: Uint64
) #foreign #link="SDL_DelayPrecise";

TimerID :: Uint32;

TimerCallback :: ?*fn(a: ?*, b: TimerID, c: Uint32) -> Uint32 #foreign;

AddTimer :: fn(
	interval: Uint32,
	callback: TimerCallback,
	userdata: ?*
) -> TimerID #foreign #link="SDL_AddTimer";

NSTimerCallback :: ?*fn(a: ?*, b: TimerID, c: Uint64) -> Uint64 #foreign;

AddTimerNS :: fn(
	interval: Uint64,
	callback: NSTimerCallback,
	userdata: ?*
) -> TimerID #foreign #link="SDL_AddTimerNS";

RemoveTimer :: fn(
	id: TimerID
) -> bool #foreign #link="SDL_RemoveTimer";

struct Tray {
}

struct TrayMenu {
}

struct TrayEntry {
}

TrayEntryFlags :: Uint32;

TrayCallback :: ?*fn(a: ?*, b: ?*TrayEntry) #foreign;

CreateTray :: fn(
	icon: ?*Surface,
	tooltip: ?*u8
) -> ?*Tray #foreign #link="SDL_CreateTray";

SetTrayIcon :: fn(
	tray: ?*Tray,
	icon: ?*Surface
) #foreign #link="SDL_SetTrayIcon";

SetTrayTooltip :: fn(
	tray: ?*Tray,
	tooltip: ?*u8
) #foreign #link="SDL_SetTrayTooltip";

CreateTrayMenu :: fn(
	tray: ?*Tray
) -> ?*TrayMenu #foreign #link="SDL_CreateTrayMenu";

CreateTraySubmenu :: fn(
	entry: ?*TrayEntry
) -> ?*TrayMenu #foreign #link="SDL_CreateTraySubmenu";

GetTrayMenu :: fn(
	tray: ?*Tray
) -> ?*TrayMenu #foreign #link="SDL_GetTrayMenu";

GetTraySubmenu :: fn(
	entry: ?*TrayEntry
) -> ?*TrayMenu #foreign #link="SDL_GetTraySubmenu";

GetTrayEntries :: fn(
	menu: ?*TrayMenu,
	count: ?*i32
) -> ?*?*TrayEntry #foreign #link="SDL_GetTrayEntries";

RemoveTrayEntry :: fn(
	entry: ?*TrayEntry
) #foreign #link="SDL_RemoveTrayEntry";

InsertTrayEntryAt :: fn(
	menu: ?*TrayMenu,
	pos: i32,
	label: ?*u8,
	flags: TrayEntryFlags
) -> ?*TrayEntry #foreign #link="SDL_InsertTrayEntryAt";

SetTrayEntryLabel :: fn(
	entry: ?*TrayEntry,
	label: ?*u8
) #foreign #link="SDL_SetTrayEntryLabel";

GetTrayEntryLabel :: fn(
	entry: ?*TrayEntry
) -> ?*u8 #foreign #link="SDL_GetTrayEntryLabel";

SetTrayEntryChecked :: fn(
	entry: ?*TrayEntry,
	checked: bool
) #foreign #link="SDL_SetTrayEntryChecked";

GetTrayEntryChecked :: fn(
	entry: ?*TrayEntry
) -> bool #foreign #link="SDL_GetTrayEntryChecked";

SetTrayEntryEnabled :: fn(
	entry: ?*TrayEntry,
	enabled: bool
) #foreign #link="SDL_SetTrayEntryEnabled";

GetTrayEntryEnabled :: fn(
	entry: ?*TrayEntry
) -> bool #foreign #link="SDL_GetTrayEntryEnabled";

SetTrayEntryCallback :: fn(
	entry: ?*TrayEntry,
	callback: TrayCallback,
	userdata: ?*
) #foreign #link="SDL_SetTrayEntryCallback";

ClickTrayEntry :: fn(
	entry: ?*TrayEntry
) #foreign #link="SDL_ClickTrayEntry";

DestroyTray :: fn(
	tray: ?*Tray
) #foreign #link="SDL_DestroyTray";

GetTrayEntryParent :: fn(
	entry: ?*TrayEntry
) -> ?*TrayMenu #foreign #link="SDL_GetTrayEntryParent";

GetTrayMenuParentEntry :: fn(
	menu: ?*TrayMenu
) -> ?*TrayEntry #foreign #link="SDL_GetTrayMenuParentEntry";

GetTrayMenuParentTray :: fn(
	menu: ?*TrayMenu
) -> ?*Tray #foreign #link="SDL_GetTrayMenuParentTray";

UpdateTrays :: fn() #foreign #link="SDL_UpdateTrays";

GetVersion :: fn() -> i32 #foreign #link="SDL_GetVersion";

GetRevision :: fn() -> ?*u8 #foreign #link="SDL_GetRevision";

