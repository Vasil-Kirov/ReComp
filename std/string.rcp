io

#import os
#import array
#import mem
#import init

push_string :: fn(b: *[]u8, str: string) {
    x := str;
    for n in str.count {
        array.add(b, str[n]);
    }
}

format_uint :: fn(b: *[]u8, num_in: uint) {
    temp := [256]u8{};
    num := num_in;
    if num == 0 {
        array.add(b, '0');
        return;
    }

    count := 0;
    for num > 0 {
        digit := num % 10;
        num /= 10;
        c := '0' + digit;
        temp[count] = @u8 c;
        count += 1;
    }

    for i in count {
        array.add(b, temp[count - i - 1]);
    }
}

format_int :: fn(b: *[]u8, num_in: int) {
    temp := [256]u8{};
    num := num_in;
    if num == 0 {
        array.add(b, '0');
        return;
    }

    is_neg := false;
    if num < 0 {
        num = 0 - num;
        is_neg = true;
    }

    count := 0;
    for num > 0 {
        digit := num % 10;
        num /= 10;
        c := '0' + @u8 digit;
        temp[count] = c;
        count += 1;
    }
    
    if is_neg array.add(b, '-');

    for i in count {
        array.add(b, temp[count - i - 1]);
    }
}

format_float :: fn(ft: type, b: *[]u8, num_in: ft, round_at: i32) {
    temp := [256]u8{};
    count := 0;
    num := num_in;

    if ft != f32 && ft != f64 {
        return;
    }

    if num == 0 {
        array.add(b, '0');
        return;
    }

    is_neg := false;
    if num < 0 {
        num = 0 - num;
        is_neg = true;
    }

    num += 0.005;
    int_val := @i32 num;
    dec := @i32 (num * round_at) % round_at;

    if dec == 0 {
        temp[count] = '0';
        count += 1;
    }
    else {
        for dec > 0 {
            temp[count] = '0' + @u8(dec % 10);
            count += 1;
            dec /= 10;
        }
    }

    temp[count] = '.';
    count += 1;

    if int_val == 0 {
        temp[count] = '0';
        count += 1;
    } else {
        for int_val > 0 {
            temp[count] = '0' + @u8(int_val % 10);
            count += 1;
            int_val /= 10;
        }
    }


    if is_neg {
        array.add(b, '-');
    }

    for i in count {
        array.add(b, temp[count - i - 1]);
    }
}

print_typetype :: fn(b: *[]u8, info: init.TypeInfo) {
    match info.kind {
        init.TypeKind.Invalid: {
            push_string(b, "invalid");
        },
        init.TypeKind.Basic: {
            push_string(b, info.t.basic.name);
        },
        init.TypeKind.Function: {
            push_string(b, "fn(");
            args := info.t.function.args_t;
            for arg in args {
                print_typetype(b, #info arg);
                if i + 1 != args.count {
                    push_string(b, ", ");
                }
            }
            push_string(b, ")");
            if info.t.function.return_ != init.INVALID_TYPE {
                push_string(b, " -> ");
                print_typetype(b, #info info.t.function.return_);
            }
        },
        init.TypeKind.Struct: {
            push_string(b, info.t.struct_.name);
        },
        init.TypeKind.Pointer: {
            push_string(b, "*");
            print_typetype(b, #info info.t.pointer.pointee);
        },
        init.TypeKind.Array: {
            push_string(b, "[x]");
            print_typetype(b, #info info.t.array.t);
        },
        init.TypeKind.Slice: {
            push_string(b, "[]");
            print_typetype(b, #info info.t.slice.t);
        },
        init.TypeKind.Vector: {
            push_string(b, "<>");
        },
        init.TypeKind.Enum: {
            push_string(b, info.t.enum_.name);
        },
        init.TypeKind.Generic: {
            push_string(b, info.t.generic.name);
        }
    };

}

print_type :: fn(b: *[]u8, arg: init.Arg) {
    t := #info arg.t;
    match t.kind {
        init.TypeKind.Invalid: {
        },
        init.TypeKind.Basic: {
            basic := t.t.basic;
            if basic.kind == init.BasicKind.Bool {
                if *@*bool arg.val {
                    str := "true";
                    for n in str.count {
                        array.add(b, str[n]);
                    }
                } else {
                    str := "false";
                    for n in str.count {
                        array.add(b, str[n]);
                    }
                }
            }
            else if basic.kind == init.BasicKind.String {
                str: string = *@*string arg.val;
                for i in str.count {
                    array.add(b, str[i]);
                }
            }
            else if basic.kind == init.BasicKind.Cstring {
                str: cstring = *@*cstring arg.val;
                for i := 0; str[i] != '\0'; i += 1 {
                    array.add(b, str[i]);
                }

            }
            else if basic.kind == init.BasicKind.U8  {
                num: uint = *@*u8 arg.val;
                format_uint(b, num);
            }
            else if basic.kind == init.BasicKind.U16 {
                num: uint = *@*u16 arg.val;
                format_uint(b, num);
            }
            else if basic.kind == init.BasicKind.U32 {
                num: uint = *@*u32 arg.val;
                format_uint(b, num);
            }
            else if basic.kind == init.BasicKind.U64 {
                num: uint = *@*u64 arg.val;
                format_uint(b, num);
            }
            else if basic.kind == init.BasicKind.I8  {
                num: int = *@*i8 arg.val;
                format_int(b, num);
            }
            else if basic.kind == init.BasicKind.I16 {
                num: int = *@*i16 arg.val;
                format_int(b, num);
            }
            else if basic.kind == init.BasicKind.I32 {
                num: int = *@*i32 arg.val;
                format_int(b, num);
            }
            else if basic.kind == init.BasicKind.I64 {
                num: int = *@*i64 arg.val;
                format_int(b, num);
            }
            else if basic.kind == init.BasicKind.Int {
                num: int = *@*int arg.val;
                format_int(b, num);
            }
            else if basic.kind == init.BasicKind.Uint {
                num: uint = *@*uint arg.val;
                format_uint(b, num);
            }
            else if basic.kind == init.BasicKind.F32 {
                num := *@*f32 arg.val;
                format_float(f32, b, num, 100);
            }
            else if basic.kind == init.BasicKind.F64 {
                num := *@*f64 arg.val;
                format_float(f64, b, num, 100);
            }
            else if basic.kind == init.BasicKind.Type {
                pt := *@*type arg.val;
                info := #info pt;
                print_typetype(b, info);
            }
            else {
                array.add(b, '%');
            }
        },
        init.TypeKind.Function: {
        },
        init.TypeKind.Struct: {
            st := t.t.struct_;
            push_string(b, st.name);
            push_string(b, " { ");
            for n in st.members.count {
                m := st.members[n];
                print("mem: %\n", m.name);
                push_string(b, m.name);
                push_string(b, " = ");
                ptr := @*u8 arg.val;
                offset := init.get_struct_member_offset(st, n);
                mem_arg := init.Arg {
                    t = m.t,
                    val = &ptr[offset],
                };
                mem_arg.t = m.t;

                print_type(b, mem_arg);
                if n + 1 != st.members.count {
                    push_string(b, ", ");
                }
            }
            push_string(b, " }");
        },
        init.TypeKind.Pointer: {
        },
        init.TypeKind.Array: {
        },
        init.TypeKind.Slice: {
        },
        init.TypeKind.Vector: {
        },
        init.TypeKind.Enum: {
        },
        init.TypeKind.Generic: {
        }
    };
}

print :: fn(str: string, args: ...) {
    alloc := mem.create_generic_allocator();
    builder := array.create(u8, &alloc);
    arg_count := 0;
    for i in str.count {
        if str[i] == '%' {
            arg := args[arg_count];
            arg_count += 1;
            print_type(&builder, arg);
        } else {
            array.add(&builder, str[i]);
        }
    }
    os.print(&builder[0], @u32 builder.count);
}

get_next :: fn(curr: *u8) -> u32 {
    scan := curr;
    codepoint := @u32 *scan;
    for {
        if (*scan & 0b1000_0000) != 0 {
            scan = scan + 1;
            codepoint = ((codepoint << 8) | @u32 *scan);
        } else {
            return codepoint;
        }
    }
    return codepoint;
}

