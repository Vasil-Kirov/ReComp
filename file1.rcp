main

#import mem as m
#import array

// struct foo {
//     F: type,
//     a: []F,
// }


//puts :: fn #foreign(str: cstring);
mem_alloc :: fn #link="malloc"(size: int) -> ?*;
free :: fn #foreign(ptr: *);

allocator_alloc :: fn(size: int, this: *m.Allocator) -> ?* {
    return mem_alloc(size);
}

allocator_free :: fn(ptr: *, this: *m.Allocator) {
    free(ptr);
}

get_other_num :: fn(m: $T) -> T {
    return m + 3;
}

main :: fn() -> i32 {
    get_other_num(10);
    get_other_num(10);
    alloc := m.Allocator {
        alloc = allocator_alloc,
        free = allocator_free,
    };
    arr := array.create(i32, &alloc);
    array.add(&arr, 1);
    array.add(&arr, 2);
    array.add(&arr, 3);
    array.add(&arr, 5);
    array.add(&arr, 6);
    array.add(&arr, 7);
    array.add(&arr, 8);
    array.add(&arr, 9);
    array.add(&arr, 10);
    array.add(&arr, 11);
    array.add(&arr, 12);
    array.add(&arr, 13);
    array.add(&arr, 14);
    array.add(&arr, 15);
    array.add(&arr, 16);
    array.add(&arr, 17);
    array.add(&arr, 18);
    array.add(&arr, 19);
    array.add(&arr, 20);

    sum: i32 = 0;
    for i in arr.count {
        sum += arr[i];
    }

	return @i32(sum - arr.count);
}

// do_foo :: fn(s: []$T) {
//     x := s;
//     x[5] = 5;
// }
// 
// main :: fn() -> i32 {
//     alloc := m.Allocator {
//         alloc = allocator_alloc,
//     };
//     // x := m.make_slice(&alloc, i32, 10);
//     // x[1] = 4;
// 
//     fo := Opaque {};
// 
//     x := foo { F = int, a = m.make_slice(&alloc, int, 10) };
//     x.a[5] = 10;
//     do_foo(x.a);
//     // do_foo(x.a);
//     // do_foo(x.a);
// 
//     // defer puts(c"1");
//     // defer puts(c"2");
//     // defer puts(c"3");
//     // {
//     //     defer puts(c"33");
//     //     defer puts(c"22");
//     //     defer puts(c"11");
//     // }
// 
// 
//     return @i32 x.a.count;
// }


// #import stuff as f2
// 
// struct BigStruct {
// 	bar: f2.x,
//     foo: [100]i32,
// }
// 
// struct SmallStruct {
//     num1: i16,
//     num2: i16,
// }
// 
// make_bs :: fn(num: i32) -> BigStruct {
//     res := BigStruct { foo = {}, bar = f2.x { y = 10 } };
//     for i := 0; i < 100;  i += 1 {
//         res.foo[i] = num;
//     }
// 
//     return res;
// }
// 
// make_ss :: fn(num: i32) -> SmallStruct {
//     res := SmallStruct { num1 = @i16 num, num2 = @i16 num };
//     return res;
// }
// 
// make_array :: fn(num: i32) -> [100]i32 {
//     arr:[100]i32 = {};
//     for i := 0; i < 50; i += 1 {
//         arr[i] = num;
//     }
//     for i := 50; i < 100; i += 1 {
//         arr[i] = num * 2;
//     }
//     return arr;
// }
// 
// get_fn :: fn() -> fn(foo1: BigStruct, foo2: SmallStruct, foo3: [100]i32) -> i32 {
// 	return fn(foo1: BigStruct, foo2: SmallStruct, foo3: [100]i32) -> i32 {
// 		return foo1.foo[50] - foo2.num2 - foo3[0] - foo3[50] + 1;
// 	};
// }
// 
// main :: fn() -> i32 {
//     foo1 := make_bs(100);
//     foo2 := make_ss(25);
//     foo3 := make_array(25);
// 	my_arr :: {1, 2, 3};
//     //     100 - 25 - 25 - 50
// 	return get_fn()(foo1, foo2, foo3);
// }


