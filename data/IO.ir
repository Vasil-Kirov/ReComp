[WARNING] [ MODULE io ]


fn __GlobalInitializerFunction.0() {

	block_0:
		RET

}

fn print_typetype(*[]u32 %0, *init.TypeInfo %1) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC *[]u32
		%148 = STORE *[]u32 %147
		%149 = ARG #1
		%150 = ALLOC *init.TypeInfo
		%150 = STORE *init.TypeInfo %149
		%151 = LOAD *init.TypeInfo %150
		%152 = %151[%0] init.TypeInfo
		%153 = LOAD init.TypeKind %152
		%154 = init.TypeKind.Invalid
		%155 = init.TypeKind.Basic
		%156 = init.TypeKind.Function
		%157 = init.TypeKind.Struct
		%158 = init.TypeKind.Pointer
		%159 = init.TypeKind.Array
		%160 = init.TypeKind.Slice
		%161 = init.TypeKind.Vector
		%162 = init.TypeKind.Enum
		%163 = init.TypeKind.Generic
		%328 = switch %153 [%154 block_2, %155 block_3, %156 block_4, %157 block_22, %158 block_23, %159 block_24, %160 block_25, %161 block_26, %162 block_27, %163 block_28]


	block_2:
		%164 = LOAD *[]u32 %148
		%165 = string "invalid"
		%166 = CALL %96(%164, %165)
		JMP block_1


	block_3:
		%168 = LOAD *[]u32 %148
		%169 = LOAD *init.TypeInfo %150
		%170 = %169[%1] init.TypeInfo
		%171 = %170[%0] init.TypeUnion
		%172 = %171[%3] init.BasicType
		%173 = CALL %96(%168, %172)
		JMP block_1


	block_4:
		%175 = LOAD *[]u32 %148
		%176 = string "fn("
		%177 = CALL %96(%175, %176)
		%178 = LOAD *init.TypeInfo %150
		%179 = %178[%1] init.TypeInfo
		%180 = %179[%2] init.TypeUnion
		%181 = %180[%1] init.FunctionType
		%182 = ALLOC []type
		%182 = STORE []type %181
		%183 = int 0
		%184 = %182[%0] []type
		%185 = LOAD int %184
		%186 = int 1
		%187 = ALLOC int
		%187 = STORE int %183
		JMP block_5


	block_5:
		%189 = LOAD int %187
		%190 = %189 < %185
		IF %190 goto block_6, else goto block_8


	block_6:
		%191 = LOAD int %187
		%192 = %182[%1] []type
		%193 = LOAD *type %192
		%194 = %193[%191] *type
		%195 = LOAD type %194
		%196 = ALLOC type
		%196 = STORE type %195
		%197 = LOAD *[]u32 %148
		%198 = LOAD type %196
		%199 = #info %198
		%200 = CALL %85(%197, %199)
		%201 = LOAD int %187
		%202 = int 1
		%203 = int %201 + %202
		%204 = %182[%0] []type
		%205 = LOAD int %204
		%206 = %203 != %205
		IF %206 goto block_9, else goto block_10


	block_9:
		%207 = LOAD *[]u32 %148
		%208 = string ", "
		%209 = CALL %96(%207, %208)
		JMP block_11


	block_10:
		JMP block_11


	block_11:
		JMP block_7


	block_7:
		%213 = LOAD int %187
		%214 = int %213 + %186
		%187 = STORE int %214
		JMP block_5


	block_8:
		%216 = LOAD *[]u32 %148
		%217 = string ")"
		%218 = CALL %96(%216, %217)
		%219 = LOAD *init.TypeInfo %150
		%220 = %219[%1] init.TypeInfo
		%221 = %220[%2] init.TypeUnion
		%222 = %221[%0] init.FunctionType
		%223 = %222[%0] []type
		%224 = LOAD int %223
		%225 = int 0
		%226 = %224 != %225
		IF %226 goto block_12, else goto block_13


	block_12:
		%227 = LOAD *[]u32 %148
		%228 = string " -> "
		%229 = CALL %96(%227, %228)
		%230 = int 0
		%231 = LOAD *init.TypeInfo %150
		%232 = %231[%1] init.TypeInfo
		%233 = %232[%2] init.TypeUnion
		%234 = %233[%0] init.FunctionType
		%235 = %234[%0] []type
		%236 = LOAD int %235
		%237 = int 1
		%238 = ALLOC int
		%238 = STORE int %230
		JMP block_15


	block_15:
		%240 = LOAD int %238
		%241 = %240 < %236
		IF %241 goto block_16, else goto block_18


	block_16:
		%242 = LOAD int %238
		%243 = %234[%1] []type
		%244 = LOAD *type %243
		%245 = %244[%242] *type
		%246 = LOAD type %245
		%247 = ALLOC type
		%247 = STORE type %246
		%248 = LOAD int %238
		%249 = int 0
		%250 = %248 != %249
		IF %250 goto block_19, else goto block_20


	block_19:
		%251 = LOAD *[]u32 %148
		%252 = string ", "
		%253 = CALL %96(%251, %252)
		JMP block_21


	block_20:
		JMP block_21


	block_21:
		%256 = LOAD *[]u32 %148
		%257 = LOAD type %247
		%258 = #info %257
		%259 = CALL %85(%256, %258)
		JMP block_17


	block_17:
		%261 = LOAD int %238
		%262 = int %261 + %237
		%238 = STORE int %262
		JMP block_15


	block_18:
		JMP block_14


	block_13:
		JMP block_14


	block_14:
		JMP block_1


	block_22:
		%267 = LOAD *[]u32 %148
		%268 = LOAD *init.TypeInfo %150
		%269 = %268[%1] init.TypeInfo
		%270 = %269[%1] init.TypeUnion
		%271 = %270[%1] init.StructType
		%272 = CALL %96(%267, %271)
		JMP block_1


	block_23:
		%274 = LOAD *[]u32 %148
		%275 = string "*"
		%276 = CALL %96(%274, %275)
		%277 = LOAD *[]u32 %148
		%278 = LOAD *init.TypeInfo %150
		%279 = %278[%1] init.TypeInfo
		%280 = %279[%3] init.TypeUnion
		%281 = %280[%0] init.PointerType
		%282 = LOAD type %281
		%283 = #info %282
		%284 = CALL %85(%277, %283)
		JMP block_1


	block_24:
		%286 = LOAD *[]u32 %148
		%287 = string "[x]"
		%288 = CALL %96(%286, %287)
		%289 = LOAD *[]u32 %148
		%290 = LOAD *init.TypeInfo %150
		%291 = %290[%1] init.TypeInfo
		%292 = %291[%4] init.TypeUnion
		%293 = %292[%0] init.ArrayType
		%294 = LOAD type %293
		%295 = #info %294
		%296 = CALL %85(%289, %295)
		JMP block_1


	block_25:
		%298 = LOAD *[]u32 %148
		%299 = string "[]"
		%300 = CALL %96(%298, %299)
		%301 = LOAD *[]u32 %148
		%302 = LOAD *init.TypeInfo %150
		%303 = %302[%1] init.TypeInfo
		%304 = %303[%5] init.TypeUnion
		%305 = %304[%0] init.SliceType
		%306 = LOAD type %305
		%307 = #info %306
		%308 = CALL %85(%301, %307)
		JMP block_1


	block_26:
		%310 = LOAD *[]u32 %148
		%311 = string "<>"
		%312 = CALL %96(%310, %311)
		JMP block_1


	block_27:
		%314 = LOAD *[]u32 %148
		%315 = LOAD *init.TypeInfo %150
		%316 = %315[%1] init.TypeInfo
		%317 = %316[%6] init.TypeUnion
		%318 = %317[%0] init.EnumType
		%319 = CALL %96(%314, %318)
		JMP block_1


	block_28:
		%321 = LOAD *[]u32 %148
		%322 = LOAD *init.TypeInfo %150
		%323 = %322[%1] init.TypeInfo
		%324 = %323[%8] init.TypeUnion
		%325 = %324[%0] init.GenericType
		%326 = CALL %96(%321, %325)
		JMP block_1


	block_1:
		RET

}

fn print_type(*[]u32 %0, init.Arg %1) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC *[]u32
		%148 = STORE *[]u32 %147
		%149 = ARG #1
		%150 = ALLOC init.Arg
		%150 = STORE init.Arg %149
		%151 = %150[%0] init.Arg
		%152 = LOAD type %151
		%153 = #info %152
		%154 = ALLOC *init.TypeInfo
		%154 = STORE *init.TypeInfo %153
		%155 = LOAD *init.TypeInfo %154
		%156 = %155[%0] init.TypeInfo
		%157 = LOAD init.TypeKind %156
		%158 = init.TypeKind.Invalid
		%159 = init.TypeKind.Basic
		%160 = init.TypeKind.Function
		%161 = init.TypeKind.Struct
		%162 = init.TypeKind.Pointer
		%163 = init.TypeKind.Array
		%164 = init.TypeKind.Slice
		%165 = init.TypeKind.Vector
		%166 = init.TypeKind.Enum
		%167 = init.TypeKind.Generic
		%538 = switch %157 [%158 block_2, %159 block_3, %160 block_52, %161 block_53, %162 block_61, %163 block_62, %164 block_63, %165 block_64, %166 block_65, %167 block_78]


	block_2:
		JMP block_1


	block_3:
		%169 = LOAD *init.TypeInfo %154
		%170 = %169[%1] init.TypeInfo
		%171 = %170[%0] init.TypeUnion
		%172 = ALLOC init.BasicType
		%172 = STORE init.BasicType %171
		%173 = %172[%0] init.BasicType
		%174 = LOAD init.BasicKind %173
		%175 = init.BasicKind.Bool
		%176 = %174 == %175
		IF %176 goto block_4, else goto block_5


	block_4:
		%177 = %150[%1] init.Arg
		%178 = LOAD * %177
		%179 = LOAD bool %178
		IF %179 goto block_7, else goto block_8


	block_7:
		%180 = LOAD *[]u32 %148
		%181 = string "true"
		%182 = CALL %96(%180, %181)
		JMP block_9


	block_8:
		%184 = LOAD *[]u32 %148
		%185 = string "false"
		%186 = CALL %96(%184, %185)
		JMP block_9


	block_9:
		JMP block_6


	block_5:
		%189 = %172[%0] init.BasicType
		%190 = LOAD init.BasicKind %189
		%191 = init.BasicKind.String
		%192 = %190 == %191
		IF %192 goto block_10, else goto block_11


	block_10:
		%193 = %150[%1] init.Arg
		%194 = LOAD * %193
		%195 = LOAD string %194
		%196 = ALLOC string
		%196 = STORE string %195
		%197 = LOAD *[]u32 %148
		%198 = CALL %96(%197, %196)
		JMP block_12


	block_11:
		%200 = %172[%0] init.BasicType
		%201 = LOAD init.BasicKind %200
		%202 = init.BasicKind.U8
		%203 = %201 == %202
		IF %203 goto block_13, else goto block_14


	block_13:
		%204 = %150[%1] init.Arg
		%205 = LOAD * %204
		%206 = LOAD u8 %205
		%207 = CAST u8 to uint %206
		%208 = ALLOC uint
		%208 = STORE uint %207
		%209 = LOAD *[]u32 %148
		%210 = LOAD uint %208
		%211 = CALL %97(%209, %210)
		JMP block_15


	block_14:
		%213 = %172[%0] init.BasicType
		%214 = LOAD init.BasicKind %213
		%215 = init.BasicKind.U16
		%216 = %214 == %215
		IF %216 goto block_16, else goto block_17


	block_16:
		%217 = %150[%1] init.Arg
		%218 = LOAD * %217
		%219 = LOAD u16 %218
		%220 = CAST u16 to uint %219
		%221 = ALLOC uint
		%221 = STORE uint %220
		%222 = LOAD *[]u32 %148
		%223 = LOAD uint %221
		%224 = CALL %97(%222, %223)
		JMP block_18


	block_17:
		%226 = %172[%0] init.BasicType
		%227 = LOAD init.BasicKind %226
		%228 = init.BasicKind.U32
		%229 = %227 == %228
		IF %229 goto block_19, else goto block_20


	block_19:
		%230 = %150[%1] init.Arg
		%231 = LOAD * %230
		%232 = LOAD u32 %231
		%233 = CAST u32 to uint %232
		%234 = ALLOC uint
		%234 = STORE uint %233
		%235 = LOAD *[]u32 %148
		%236 = LOAD uint %234
		%237 = CALL %97(%235, %236)
		JMP block_21


	block_20:
		%239 = %172[%0] init.BasicType
		%240 = LOAD init.BasicKind %239
		%241 = init.BasicKind.U64
		%242 = %240 == %241
		IF %242 goto block_22, else goto block_23


	block_22:
		%243 = %150[%1] init.Arg
		%244 = LOAD * %243
		%245 = LOAD u64 %244
		%246 = ALLOC uint
		%246 = STORE uint %245
		%247 = LOAD *[]u32 %148
		%248 = LOAD uint %246
		%249 = CALL %97(%247, %248)
		JMP block_24


	block_23:
		%251 = %172[%0] init.BasicType
		%252 = LOAD init.BasicKind %251
		%253 = init.BasicKind.I8
		%254 = %252 == %253
		IF %254 goto block_25, else goto block_26


	block_25:
		%255 = %150[%1] init.Arg
		%256 = LOAD * %255
		%257 = LOAD i8 %256
		%258 = CAST i8 to int %257
		%259 = ALLOC int
		%259 = STORE int %258
		%260 = LOAD *[]u32 %148
		%261 = LOAD int %259
		%262 = CALL %98(%260, %261)
		JMP block_27


	block_26:
		%264 = %172[%0] init.BasicType
		%265 = LOAD init.BasicKind %264
		%266 = init.BasicKind.I16
		%267 = %265 == %266
		IF %267 goto block_28, else goto block_29


	block_28:
		%268 = %150[%1] init.Arg
		%269 = LOAD * %268
		%270 = LOAD i16 %269
		%271 = CAST i16 to int %270
		%272 = ALLOC int
		%272 = STORE int %271
		%273 = LOAD *[]u32 %148
		%274 = LOAD int %272
		%275 = CALL %98(%273, %274)
		JMP block_30


	block_29:
		%277 = %172[%0] init.BasicType
		%278 = LOAD init.BasicKind %277
		%279 = init.BasicKind.I32
		%280 = %278 == %279
		IF %280 goto block_31, else goto block_32


	block_31:
		%281 = %150[%1] init.Arg
		%282 = LOAD * %281
		%283 = LOAD i32 %282
		%284 = CAST i32 to int %283
		%285 = ALLOC int
		%285 = STORE int %284
		%286 = LOAD *[]u32 %148
		%287 = LOAD int %285
		%288 = CALL %98(%286, %287)
		JMP block_33


	block_32:
		%290 = %172[%0] init.BasicType
		%291 = LOAD init.BasicKind %290
		%292 = init.BasicKind.I64
		%293 = %291 == %292
		IF %293 goto block_34, else goto block_35


	block_34:
		%294 = %150[%1] init.Arg
		%295 = LOAD * %294
		%296 = LOAD i64 %295
		%297 = ALLOC int
		%297 = STORE int %296
		%298 = LOAD *[]u32 %148
		%299 = LOAD int %297
		%300 = CALL %98(%298, %299)
		JMP block_36


	block_35:
		%302 = %172[%0] init.BasicType
		%303 = LOAD init.BasicKind %302
		%304 = init.BasicKind.Int
		%305 = %303 == %304
		IF %305 goto block_37, else goto block_38


	block_37:
		%306 = %150[%1] init.Arg
		%307 = LOAD * %306
		%308 = LOAD int %307
		%309 = ALLOC int
		%309 = STORE int %308
		%310 = LOAD *[]u32 %148
		%311 = LOAD int %309
		%312 = CALL %98(%310, %311)
		JMP block_39


	block_38:
		%314 = %172[%0] init.BasicType
		%315 = LOAD init.BasicKind %314
		%316 = init.BasicKind.Uint
		%317 = %315 == %316
		IF %317 goto block_40, else goto block_41


	block_40:
		%318 = %150[%1] init.Arg
		%319 = LOAD * %318
		%320 = LOAD uint %319
		%321 = ALLOC uint
		%321 = STORE uint %320
		%322 = LOAD *[]u32 %148
		%323 = LOAD uint %321
		%324 = CALL %97(%322, %323)
		JMP block_42


	block_41:
		%326 = %172[%0] init.BasicType
		%327 = LOAD init.BasicKind %326
		%328 = init.BasicKind.F32
		%329 = %327 == %328
		IF %329 goto block_43, else goto block_44


	block_43:
		%330 = %150[%1] init.Arg
		%331 = LOAD * %330
		%332 = LOAD f32 %331
		%333 = ALLOC f32
		%333 = STORE f32 %332
		%334 = uint 10
		%335 = LOAD *[]u32 %148
		%336 = LOAD f32 %333
		%337 = i32 100
		%338 = CALL %101(%334, %335, %336, %337)
		JMP block_45


	block_44:
		%340 = %172[%0] init.BasicType
		%341 = LOAD init.BasicKind %340
		%342 = init.BasicKind.F64
		%343 = %341 == %342
		IF %343 goto block_46, else goto block_47


	block_46:
		%344 = %150[%1] init.Arg
		%345 = LOAD * %344
		%346 = LOAD f64 %345
		%347 = ALLOC f64
		%347 = STORE f64 %346
		%348 = uint 11
		%349 = LOAD *[]u32 %148
		%350 = LOAD f64 %347
		%351 = i32 100
		%352 = CALL %102(%348, %349, %350, %351)
		JMP block_48


	block_47:
		%354 = %172[%0] init.BasicType
		%355 = LOAD init.BasicKind %354
		%356 = init.BasicKind.Type
		%357 = %355 == %356
		IF %357 goto block_49, else goto block_50


	block_49:
		%358 = %150[%1] init.Arg
		%359 = LOAD * %358
		%360 = LOAD type %359
		%361 = ALLOC type
		%361 = STORE type %360
		%362 = LOAD type %361
		%363 = #info %362
		%364 = ALLOC *init.TypeInfo
		%364 = STORE *init.TypeInfo %363
		%365 = LOAD *[]u32 %148
		%366 = LOAD *init.TypeInfo %364
		%367 = CALL %85(%365, %366)
		JMP block_51


	block_50:
		%369 = LOAD *[]u32 %148
		%370 = u32 37
		%371 = CALL %136(%369, %370)
		JMP block_51


	block_51:
		JMP block_48


	block_48:
		JMP block_45


	block_45:
		JMP block_42


	block_42:
		JMP block_39


	block_39:
		JMP block_36


	block_36:
		JMP block_33


	block_33:
		JMP block_30


	block_30:
		JMP block_27


	block_27:
		JMP block_24


	block_24:
		JMP block_21


	block_21:
		JMP block_18


	block_18:
		JMP block_15


	block_15:
		JMP block_12


	block_12:
		JMP block_6


	block_6:
		JMP block_1


	block_52:
		JMP block_1


	block_53:
		%389 = LOAD *init.TypeInfo %154
		%390 = %389[%1] init.TypeInfo
		%391 = %390[%1] init.TypeUnion
		%392 = ALLOC init.StructType
		%392 = STORE init.StructType %391
		%393 = LOAD *[]u32 %148
		%394 = %392[%1] init.StructType
		%395 = CALL %96(%393, %394)
		%396 = LOAD *[]u32 %148
		%397 = string " { "
		%398 = CALL %96(%396, %397)
		%399 = int 0
		%400 = %392[%0] init.StructType
		%401 = %400[%0] []init.StructMember
		%402 = LOAD int %401
		%403 = int 0
		%404 = int 1
		%405 = ALLOC int
		%405 = STORE int %403
		JMP block_54


	block_54:
		%407 = LOAD int %405
		%408 = %407 < %402
		IF %408 goto block_55, else goto block_57


	block_55:
		%409 = %392[%0] init.StructType
		%410 = LOAD int %405
		%411 = %409[%1] []init.StructMember
		%412 = LOAD *init.StructMember %411
		%413 = %412[%410] *init.StructMember
		%414 = ALLOC init.StructMember
		%414 = STORE init.StructMember %413
		%415 = LOAD *[]u32 %148
		%416 = %414[%0] init.StructMember
		%417 = CALL %96(%415, %416)
		%418 = LOAD *[]u32 %148
		%419 = string " = "
		%420 = CALL %96(%418, %419)
		%421 = %150[%1] init.Arg
		%422 = LOAD * %421
		%423 = ALLOC *u8
		%423 = STORE *u8 %422
		%424 = LOAD int %405
		%425 = CALL %6(%392, %424)
		%426 = ALLOC int
		%426 = STORE int %425
		%427 = ALLOC init.Arg
		MEMSET %427
		%428 = %414[%1] init.StructMember
		%429 = LOAD type %428
		%430 = %427[%0] init.Arg
		%430 = STORE type %429
		%431 = LOAD *u8 %423
		%432 = LOAD int %426
		%433 = %431[%432] *u8
		%434 = %427[%1] init.Arg
		%434 = STORE * %433
		%435 = ALLOC init.Arg
		%435 = STORE init.Arg %427
		%436 = %435[%0] init.Arg
		%437 = %414[%1] init.StructMember
		%438 = LOAD type %437
		%436 = STORE type %438
		%439 = LOAD *[]u32 %148
		%440 = CALL %86(%439, %435)
		%441 = LOAD int %405
		%442 = int 1
		%443 = int %441 + %442
		%444 = %392[%0] init.StructType
		%445 = %444[%0] []init.StructMember
		%446 = LOAD int %445
		%447 = %443 != %446
		IF %447 goto block_58, else goto block_59


	block_58:
		%448 = LOAD *[]u32 %148
		%449 = string ", "
		%450 = CALL %96(%448, %449)
		JMP block_60


	block_59:
		JMP block_60


	block_60:
		JMP block_56


	block_56:
		%454 = LOAD int %405
		%455 = int %454 + %404
		%405 = STORE int %455
		JMP block_54


	block_57:
		%457 = LOAD *[]u32 %148
		%458 = string " }"
		%459 = CALL %96(%457, %458)
		JMP block_1


	block_61:
		%461 = %150[%1] init.Arg
		%462 = LOAD * %461
		%463 = LOAD uint %462
		%464 = ALLOC uint
		%464 = STORE uint %463
		%465 = LOAD *[]u32 %148
		%466 = LOAD uint %464
		%467 = CALL %97(%465, %466)
		JMP block_1


	block_62:
		JMP block_1


	block_63:
		JMP block_1


	block_64:
		JMP block_1


	block_65:
		%472 = LOAD *init.TypeInfo %154
		%473 = %472[%1] init.TypeInfo
		%474 = %473[%6] init.TypeUnion
		%475 = ALLOC init.EnumType
		%475 = STORE init.EnumType %474
		%476 = %475[%2] init.EnumType
		%477 = LOAD type %476
		%478 = CALL %5(%477)
		%479 = ALLOC int
		%479 = STORE int %478
		%480 = ALLOC int
		%481 = LOAD int %479
		%482 = int 1
		%483 = int 2
		%484 = int 4
		%485 = int 8
		%506 = switch %481 [%482 block_67, %483 block_68, %484 block_69, %485 block_70]


	block_67:
		%486 = %150[%1] init.Arg
		%487 = LOAD * %486
		%488 = LOAD i8 %487
		%489 = CAST i8 to int %488
		%480 = STORE int %489
		JMP block_66


	block_68:
		%491 = %150[%1] init.Arg
		%492 = LOAD * %491
		%493 = LOAD i16 %492
		%494 = CAST i16 to int %493
		%480 = STORE int %494
		JMP block_66


	block_69:
		%496 = %150[%1] init.Arg
		%497 = LOAD * %496
		%498 = LOAD i32 %497
		%499 = CAST i32 to int %498
		%480 = STORE int %499
		JMP block_66


	block_70:
		%501 = %150[%1] init.Arg
		%502 = LOAD * %501
		%503 = LOAD i64 %502
		%504 = CAST i64 to int %503
		%480 = STORE int %504
		JMP block_66


	block_66:
		%507 = LOAD int %480
		%508 = ALLOC int
		%508 = STORE int %507
		%509 = int 0
		%510 = %475[%1] init.EnumType
		%511 = %510[%0] []init.EnumMember
		%512 = LOAD int %511
		%513 = int 1
		%514 = ALLOC int
		%514 = STORE int %509
		JMP block_71


	block_71:
		%516 = LOAD int %514
		%517 = %516 < %512
		IF %517 goto block_72, else goto block_74


	block_72:
		%518 = LOAD int %514
		%519 = %510[%1] []init.EnumMember
		%520 = LOAD *init.EnumMember %519
		%521 = %520[%518] *init.EnumMember
		%522 = ALLOC init.EnumMember
		%522 = STORE init.EnumMember %521
		%523 = %522[%1] init.EnumMember
		%524 = LOAD int %523
		%525 = LOAD int %508
		%526 = %524 == %525
		IF %526 goto block_75, else goto block_76


	block_75:
		%527 = LOAD *[]u32 %148
		%528 = %522[%0] init.EnumMember
		%529 = CALL %96(%527, %528)
		JMP block_74


	block_76:
		JMP block_77


	block_77:
		JMP block_73


	block_73:
		%533 = LOAD int %514
		%534 = int %533 + %513
		%514 = STORE int %534
		JMP block_71


	block_74:
		JMP block_1


	block_78:
		JMP block_1


	block_1:
		RET

}

fn print_type_with_formatter(*[]u32 %0, u32 %1, init.Arg %2) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC *[]u32
		%148 = STORE *[]u32 %147
		%149 = ARG #1
		%150 = ALLOC u32
		%150 = STORE u32 %149
		%151 = ARG #2
		%152 = ALLOC init.Arg
		%152 = STORE init.Arg %151
		%153 = %152[%0] init.Arg
		%154 = LOAD type %153
		%155 = #info %154
		%156 = ALLOC *init.TypeInfo
		%156 = STORE *init.TypeInfo %155
		%157 = ALLOC bool
		%158 = ALLOC bool
		%159 = LOAD u32 %150
		%160 = u32 115
		%161 = %159 == %160
		IF %161 goto block_7, else goto block_6


	block_7:
		%162 = LOAD *init.TypeInfo %156
		%163 = %162[%0] init.TypeInfo
		%164 = LOAD init.TypeKind %163
		%165 = init.TypeKind.Pointer
		%166 = %164 == %165
		IF %166 goto block_5, else goto block_6


	block_5:
		%167 = bool 1
		%158 = STORE bool %167
		JMP block_8


	block_6:
		%169 = bool 0
		%158 = STORE bool %169
		JMP block_8


	block_8:
		%171 = LOAD bool %158
		IF %171 goto block_3, else goto block_2


	block_3:
		%172 = LOAD *init.TypeInfo %156
		%173 = %172[%1] init.TypeInfo
		%174 = %173[%3] init.TypeUnion
		%175 = %174[%0] init.PointerType
		%176 = LOAD type %175
		%177 = uint 2
		%178 = %176 == %177
		IF %178 goto block_1, else goto block_2


	block_1:
		%179 = bool 1
		%157 = STORE bool %179
		JMP block_4


	block_2:
		%181 = bool 0
		%157 = STORE bool %181
		JMP block_4


	block_4:
		%183 = LOAD bool %157
		IF %183 goto block_9, else goto block_10


	block_9:
		%184 = %152[%1] init.Arg
		%185 = LOAD * %184
		%186 = LOAD *u8 %185
		%187 = ALLOC *u8
		%187 = STORE *u8 %186
		%188 = int 0
		%189 = ALLOC int
		%189 = STORE int %188
		JMP block_12


	block_12:
		%191 = LOAD *u8 %187
		%192 = LOAD int %189
		%193 = %191[%192] *u8
		%194 = LOAD u8 %193
		%195 = CAST u8 to u32 %194
		%196 = u32 0
		%197 = %195 != %196
		IF %197 goto block_13, else goto block_15


	block_13:
		%198 = LOAD *[]u32 %148
		%199 = LOAD *u8 %187
		%200 = LOAD int %189
		%201 = %199[%200] *u8
		%202 = LOAD u8 %201
		%203 = CAST u8 to u32 %202
		%204 = CALL %136(%198, %203)
		JMP block_14


	block_14:
		%206 = LOAD int %189
		%207 = int 1
		%208 = int %206 + %207
		%189 = STORE int %208
		%209 = LOAD int %189
		JMP block_12


	block_15:
		JMP block_11


	block_10:
		%212 = ALLOC bool
		%213 = ALLOC bool
		%214 = LOAD u32 %150
		%215 = u32 99
		%216 = %214 == %215
		IF %216 goto block_22, else goto block_21


	block_22:
		%217 = LOAD *init.TypeInfo %156
		%218 = %217[%0] init.TypeInfo
		%219 = LOAD init.TypeKind %218
		%220 = init.TypeKind.Basic
		%221 = %219 == %220
		IF %221 goto block_20, else goto block_21


	block_20:
		%222 = bool 1
		%213 = STORE bool %222
		JMP block_23


	block_21:
		%224 = bool 0
		%213 = STORE bool %224
		JMP block_23


	block_23:
		%226 = LOAD bool %213
		IF %226 goto block_18, else goto block_17


	block_18:
		%227 = ALLOC bool
		%228 = LOAD *init.TypeInfo %156
		%229 = %228[%1] init.TypeInfo
		%230 = %229[%0] init.TypeUnion
		%231 = %230[%0] init.BasicType
		%232 = LOAD init.BasicKind %231
		%233 = init.BasicKind.U8
		%234 = %232 == %233
		IF %234 goto block_24, else goto block_26


	block_26:
		%235 = LOAD *init.TypeInfo %156
		%236 = %235[%1] init.TypeInfo
		%237 = %236[%0] init.TypeUnion
		%238 = %237[%0] init.BasicType
		%239 = LOAD init.BasicKind %238
		%240 = init.BasicKind.U32
		%241 = %239 == %240
		IF %241 goto block_24, else goto block_25


	block_24:
		%242 = bool 1
		%227 = STORE bool %242
		JMP block_27


	block_25:
		%244 = bool 0
		%227 = STORE bool %244
		JMP block_27


	block_27:
		%246 = LOAD bool %227
		IF %246 goto block_16, else goto block_17


	block_16:
		%247 = bool 1
		%212 = STORE bool %247
		JMP block_19


	block_17:
		%249 = bool 0
		%212 = STORE bool %249
		JMP block_19


	block_19:
		%251 = LOAD bool %212
		IF %251 goto block_28, else goto block_29


	block_28:
		%252 = ALLOC u32
		ZEROUT %252 u32
		%253 = LOAD *init.TypeInfo %156
		%254 = %253[%1] init.TypeInfo
		%255 = %254[%0] init.TypeUnion
		%256 = %255[%0] init.BasicType
		%257 = LOAD init.BasicKind %256
		%258 = init.BasicKind.U8
		%259 = %257 == %258
		IF %259 goto block_31, else goto block_32


	block_31:
		%260 = %152[%1] init.Arg
		%261 = LOAD * %260
		%262 = LOAD u8 %261
		%263 = CAST u8 to u32 %262
		%252 = STORE u32 %263
		JMP block_33


	block_32:
		%265 = LOAD *init.TypeInfo %156
		%266 = %265[%1] init.TypeInfo
		%267 = %266[%0] init.TypeUnion
		%268 = %267[%0] init.BasicType
		%269 = LOAD init.BasicKind %268
		%270 = init.BasicKind.U32
		%271 = %269 == %270
		IF %271 goto block_34, else goto block_35


	block_34:
		%272 = %152[%1] init.Arg
		%273 = LOAD * %272
		%274 = LOAD u32 %273
		%252 = STORE u32 %274
		JMP block_36


	block_35:
		JMP block_36


	block_36:
		JMP block_33


	block_33:
		%278 = LOAD *[]u32 %148
		%279 = LOAD u32 %252
		%280 = CALL %136(%278, %279)
		JMP block_30


	block_29:
		%282 = LOAD *[]u32 %148
		%283 = CALL %86(%282, %152)
		%284 = LOAD u32 %150
		%285 = u32 0
		%286 = %284 != %285
		IF %286 goto block_37, else goto block_38


	block_37:
		%287 = LOAD *[]u32 %148
		%288 = LOAD u32 %150
		%289 = CALL %136(%287, %288)
		JMP block_39


	block_38:
		JMP block_39


	block_39:
		JMP block_30


	block_30:
		JMP block_11


	block_11:
		RET

}

fn vsprint(string %0, []init.Arg %1) -> string {

	block_0:
		%147 = ARG #0
		%148 = ALLOC string
		%148 = STORE string %147
		%149 = ARG #1
		%150 = ALLOC []init.Arg
		%150 = STORE []init.Arg %149
		%151 = ALLOC []u32
		%152 = CALL %95(%151, %148, %150)
		%153 = ALLOC []u32
		%153 = STORE []u32 %151
		%154 = ALLOC []u8
		%155 = CALL %100(%154, %153)
		%156 = ALLOC []u8
		%156 = STORE []u8 %154
		%157 = CALL %137(%153)
		%158 = ALLOC string
		MEMSET %158
		%159 = uint 0
		%160 = %156[%1] []u8
		%161 = LOAD *u8 %160
		%162 = %161[%159] *u8
		%163 = %158[%1] string
		%163 = STORE int %162
		%164 = %156[%0] []u8
		%165 = LOAD int %164
		%166 = %158[%0] string
		%166 = STORE *u8 %165
		RET string %158

}

fn sprint(string %0) -> string {

	block_0:
		%147 = ARG #0
		%148 = ALLOC string
		%148 = STORE string %147
		%149 = ARG #1
		%150 = ALLOC []init.Arg
		%150 = STORE []init.Arg %149
		%151 = ALLOC []u32
		%152 = CALL %95(%151, %148, %150)
		%153 = ALLOC []u32
		%153 = STORE []u32 %151
		%154 = ALLOC []u8
		%155 = CALL %100(%154, %153)
		%156 = ALLOC []u8
		%156 = STORE []u8 %154
		%157 = CALL %137(%153)
		%158 = ALLOC string
		MEMSET %158
		%159 = uint 0
		%160 = %156[%1] []u8
		%161 = LOAD *u8 %160
		%162 = %161[%159] *u8
		%163 = %158[%1] string
		%163 = STORE int %162
		%164 = %156[%0] []u8
		%165 = LOAD int %164
		%166 = %158[%0] string
		%166 = STORE *u8 %165
		RET string %158

}

fn print(string %0) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC string
		%148 = STORE string %147
		%149 = ARG #1
		%150 = ALLOC []init.Arg
		%150 = STORE []init.Arg %149
		%151 = ALLOC []u32
		%152 = CALL %95(%151, %148, %150)
		%153 = ALLOC []u32
		%153 = STORE []u32 %151
		%154 = ALLOC []u8
		%155 = CALL %100(%154, %153)
		%156 = ALLOC []u8
		%156 = STORE []u8 %154
		%157 = uint 0
		%158 = %156[%1] []u8
		%159 = LOAD *u8 %158
		%160 = %159[%157] *u8
		%161 = %156[%0] []u8
		%162 = LOAD int %161
		%163 = CAST int to u32 %162
		%164 = CALL %25(%160, %163)
		%165 = CALL %137(%153)
		%166 = CALL %138(%156)
		RET

}

fn println(string %0) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC string
		%148 = STORE string %147
		%149 = ARG #1
		%150 = ALLOC []init.Arg
		%150 = STORE []init.Arg %149
		%151 = ALLOC []u32
		%152 = CALL %95(%151, %148, %150)
		%153 = ALLOC []u32
		%153 = STORE []u32 %151
		%154 = u32 10
		%155 = CALL %136(%153, %154)
		%156 = ALLOC []u8
		%157 = CALL %100(%156, %153)
		%158 = ALLOC []u8
		%158 = STORE []u8 %156
		%159 = uint 0
		%160 = %158[%1] []u8
		%161 = LOAD *u8 %160
		%162 = %161[%159] *u8
		%163 = %158[%0] []u8
		%164 = LOAD int %163
		%165 = CAST int to u32 %164
		%166 = CALL %25(%162, %165)
		%167 = CALL %137(%153)
		%168 = CALL %138(%158)
		RET

}

fn read_entire_file(string %0, *mem.Allocator %1) -> { string, bool } {

	block_0:
		%147 = ARG #0
		%148 = ALLOC string
		%148 = STORE string %147
		%149 = ARG #1
		%150 = ALLOC *mem.Allocator
		%150 = STORE *mem.Allocator %149
		%151 = CALL %30(%148)
		%152 = ALLOC ?*
		%152 = STORE ?* %151
		%153 = LOAD ?* %152
		%154 = ?* 0
		%155 = %153 == %154
		IF %155 goto block_1, else goto block_2


	block_1:
		%156 = ALLOC return { string, bool }
		%157 = string ""
		%158 = bool 0
		%159 = %156[%0] return { string, bool }
		%159 = STORE string %157
		%160 = %156[%1] return { string, bool }
		%160 = STORE bool %158
		RET return { string, bool } %156


	block_2:
		JMP block_3


	block_3:
		%163 = LOAD ?* %152
		%164 = ALLOC *
		%164 = STORE * %163
		%165 = LOAD * %164
		%166 = CALL %34(%165)
		%167 = ALLOC int
		%167 = STORE int %166
		%168 = LOAD *mem.Allocator %150
		%169 = %168[%0] mem.Allocator
		%170 = LOAD *fn(int, *mem.Allocator) -> ?* %169
		%171 = LOAD int %167
		%172 = int 1
		%173 = int %171 + %172
		%174 = LOAD *mem.Allocator %150
		%175 = CALL %170(%173, %174)
		%176 = ALLOC ?*
		%176 = STORE ?* %175
		%177 = LOAD ?* %176
		%178 = ?* 0
		%179 = %177 == %178
		IF %179 goto block_4, else goto block_5


	block_4:
		%180 = LOAD * %164
		%181 = CALL %33(%180)
		%182 = ALLOC return { string, bool }
		%183 = string ""
		%184 = bool 0
		%185 = %182[%0] return { string, bool }
		%185 = STORE string %183
		%186 = %182[%1] return { string, bool }
		%186 = STORE bool %184
		RET return { string, bool } %182


	block_5:
		JMP block_6


	block_6:
		%189 = LOAD ?* %176
		%190 = ALLOC *u8
		%190 = STORE *u8 %189
		%191 = LOAD * %164
		%192 = LOAD *u8 %190
		%193 = LOAD int %167
		%194 = CALL %32(%191, %192, %193)
		%195 = ALLOC int
		%195 = STORE int %194
		%196 = LOAD *u8 %190
		%197 = LOAD int %195
		%198 = %196[%197] *u8
		%199 = u8 0
		%198 = STORE u8 %199
		%200 = LOAD * %164
		%201 = CALL %33(%200)
		%202 = ALLOC return { string, bool }
		%203 = ALLOC string
		MEMSET %203
		%204 = LOAD int %195
		%205 = %203[%0] string
		%205 = STORE *u8 %204
		%206 = LOAD *u8 %190
		%207 = %203[%1] string
		%207 = STORE int %206
		%208 = bool 1
		%209 = %202[%0] return { string, bool }
		%209 = STORE string %203
		%210 = %202[%1] return { string, bool }
		%210 = STORE bool %208
		RET return { string, bool } %202

}

fn readln(*mem.Allocator %0) -> string {

	block_0:
		%147 = ARG #0
		%148 = ALLOC *mem.Allocator
		%148 = STORE *mem.Allocator %147
		%149 = int 1024
		%150 = ALLOC int
		%150 = STORE int %149
		%151 = LOAD *mem.Allocator %148
		%152 = %151[%0] mem.Allocator
		%153 = LOAD *fn(int, *mem.Allocator) -> ?* %152
		%154 = LOAD int %150
		%155 = LOAD *mem.Allocator %148
		%156 = CALL %153(%154, %155)
		%157 = ALLOC ?*
		%157 = STORE ?* %156
		%158 = LOAD ?* %157
		%159 = ?* 0
		%160 = %158 == %159
		IF %160 goto block_1, else goto block_2


	block_1:
		%161 = ALLOC []init.Arg
		%162 = %161[%0] []init.Arg
		%163 = %161[%1] []init.Arg
		%164 = int 0
		%165 = ALLOC [0]init.Arg
		%162 = STORE int %164
		%163 = STORE *init.Arg %165
		%166 = string "Failed to allocate buffer for readln"
		%167 = CALL %91(%166, %161)
		%168 = string ""
		RET string %168


	block_2:
		JMP block_3


	block_3:
		%171 = LOAD ?* %157
		%172 = ALLOC *u8
		%172 = STORE *u8 %171
		%173 = LOAD *u8 %172
		%174 = LOAD int %150
		%175 = CAST int to u32 %174
		%176 = CALL %35(%173, %175)
		%177 = ALLOC u32
		%177 = STORE u32 %176
		%178 = LOAD u32 %177
		%179 = u32 0
		%180 = %178 == %179
		IF %180 goto block_4, else goto block_5


	block_4:
		%181 = string ""
		RET string %181


	block_5:
		JMP block_6


	block_6:
		%184 = ALLOC string
		ZEROUT %184 string
		%185 = %184[%1] string
		%186 = LOAD *u8 %172
		%185 = STORE *u8 %186
		%187 = %184[%0] string
		%188 = LOAD u32 %177
		%189 = CAST u32 to int %188
		%187 = STORE int %189
		RET string %184

}

fn read(int %0, *mem.Allocator %1) -> string {

	block_0:
		%147 = ARG #0
		%148 = ALLOC int
		%148 = STORE int %147
		%149 = ARG #1
		%150 = ALLOC *mem.Allocator
		%150 = STORE *mem.Allocator %149
		%151 = CALL %28()
		%152 = ALLOC *
		%152 = STORE * %151
		%153 = LOAD *mem.Allocator %150
		%154 = %153[%0] mem.Allocator
		%155 = LOAD *fn(int, *mem.Allocator) -> ?* %154
		%156 = LOAD int %148
		%157 = LOAD *mem.Allocator %150
		%158 = CALL %155(%156, %157)
		%159 = ALLOC *u8
		%159 = STORE *u8 %158
		%160 = LOAD * %152
		%161 = LOAD *u8 %159
		%162 = LOAD int %148
		%163 = CALL %32(%160, %161, %162)
		%164 = ALLOC int
		%164 = STORE int %163
		%165 = ALLOC bool
		%166 = LOAD int %164
		%167 = int 1
		%168 = int 0
		%169 = int %168 - %167
		%170 = %166 == %169
		IF %170 goto block_1, else goto block_3


	block_3:
		%171 = LOAD int %164
		%172 = int 0
		%173 = %171 == %172
		IF %173 goto block_1, else goto block_2


	block_1:
		%174 = bool 1
		%165 = STORE bool %174
		JMP block_4


	block_2:
		%176 = bool 0
		%165 = STORE bool %176
		JMP block_4


	block_4:
		%178 = LOAD bool %165
		IF %178 goto block_5, else goto block_6


	block_5:
		%179 = LOAD *mem.Allocator %150
		%180 = %179[%1] mem.Allocator
		%181 = LOAD *fn(*, *mem.Allocator) %180
		%182 = LOAD *u8 %159
		%183 = LOAD *mem.Allocator %150
		%184 = CALL %181(%182, %183)
		%185 = string ""
		RET string %185


	block_6:
		JMP block_7


	block_7:
		%188 = ALLOC string
		MEMSET %188
		%189 = LOAD int %164
		%190 = %188[%0] string
		%190 = STORE *u8 %189
		%191 = LOAD *u8 %159
		%192 = %188[%1] string
		%192 = STORE int %191
		RET string %188

}

fn internal_print(string %0, []init.Arg %1) -> []u32 {

	block_0:
		%147 = ARG #0
		%148 = ALLOC string
		%148 = STORE string %147
		%149 = ARG #1
		%150 = ALLOC []init.Arg
		%150 = STORE []init.Arg %149
		%151 = ALLOC mem.Allocator
		%152 = CALL %111(%151)
		%153 = ALLOC mem.Allocator
		%153 = STORE mem.Allocator %151
		%154 = ALLOC []u32
		%155 = uint 4
		%156 = CALL %139(%154, %155, %153)
		%157 = ALLOC []u32
		%157 = STORE []u32 %154
		%158 = int 0
		%159 = ALLOC int
		%159 = STORE int %158
		%160 = bool 0
		%161 = ALLOC bool
		%161 = STORE bool %160
		%162 = int 0
		%163 = %148[%0] string
		%164 = LOAD int %163
		%165 = ALLOC *u8
		%166 = %148[%1] string
		%167 = LOAD *u8 %166
		%165 = STORE *u8 %167
		%168 = int 1
		%169 = ALLOC int
		%169 = STORE int %162
		JMP block_1


	block_1:
		%171 = LOAD int %169
		%172 = %171 < %164
		IF %172 goto block_2, else goto block_4


	block_2:
		%173 = LOAD *u8 %165
		%174 = CALL %129(%173)
		%175 = ALLOC u32
		%175 = STORE u32 %174
		%176 = ALLOC bool
		%177 = LOAD u32 %175
		%178 = u32 37
		%179 = %177 == %178
		IF %179 goto block_7, else goto block_6


	block_7:
		%180 = %150[%0] []init.Arg
		%181 = LOAD int %180
		%182 = LOAD int %159
		%183 = %181 > %182
		IF %183 goto block_5, else goto block_6


	block_5:
		%184 = bool 1
		%176 = STORE bool %184
		JMP block_8


	block_6:
		%186 = bool 0
		%176 = STORE bool %186
		JMP block_8


	block_8:
		%188 = LOAD bool %176
		IF %188 goto block_9, else goto block_10


	block_9:
		%189 = bool 1
		%161 = STORE bool %189
		JMP block_11


	block_10:
		%191 = LOAD bool %161
		IF %191 goto block_12, else goto block_13


	block_12:
		%192 = LOAD int %159
		%193 = %150[%1] []init.Arg
		%194 = LOAD *init.Arg %193
		%195 = %194[%192] *init.Arg
		%196 = ALLOC init.Arg
		%196 = STORE init.Arg %195
		%197 = LOAD int %159
		%198 = int 1
		%199 = int %197 + %198
		%159 = STORE int %199
		%200 = LOAD u32 %175
		%201 = CALL %87(%157, %200, %196)
		%202 = bool 0
		%161 = STORE bool %202
		JMP block_14


	block_13:
		%204 = LOAD u32 %175
		%205 = CALL %136(%157, %204)
		JMP block_14


	block_14:
		JMP block_11


	block_11:
		JMP block_3


	block_3:
		%209 = LOAD int %169
		%210 = int %209 + %168
		%169 = STORE int %210
		%211 = LOAD *u8 %165
		%212 = CALL %128(%211)
		%165 = STORE *u8 %212
		JMP block_1


	block_4:
		%214 = LOAD bool %161
		IF %214 goto block_15, else goto block_16


	block_15:
		%215 = LOAD int %159
		%216 = %150[%1] []init.Arg
		%217 = LOAD *init.Arg %216
		%218 = %217[%215] *init.Arg
		%219 = ALLOC init.Arg
		%219 = STORE init.Arg %218
		%220 = LOAD int %159
		%221 = int 1
		%222 = int %220 + %221
		%159 = STORE int %222
		%223 = u32 0
		%224 = CALL %87(%157, %223, %219)
		%225 = bool 0
		%161 = STORE bool %225
		JMP block_17


	block_16:
		JMP block_17


	block_17:
		RET []u32 %157

}

fn push_string(*[]u32 %0, string %1) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC *[]u32
		%148 = STORE *[]u32 %147
		%149 = ARG #1
		%150 = ALLOC string
		%150 = STORE string %149
		%151 = int 0
		%152 = %150[%0] string
		%153 = LOAD int %152
		%154 = ALLOC *u8
		%155 = %150[%1] string
		%156 = LOAD *u8 %155
		%154 = STORE *u8 %156
		%157 = int 1
		%158 = ALLOC int
		%158 = STORE int %151
		JMP block_1


	block_1:
		%160 = LOAD int %158
		%161 = %160 < %153
		IF %161 goto block_2, else goto block_4


	block_2:
		%162 = LOAD *u8 %154
		%163 = CALL %129(%162)
		%164 = ALLOC u32
		%164 = STORE u32 %163
		%165 = LOAD *[]u32 %148
		%166 = LOAD u32 %164
		%167 = CALL %136(%165, %166)
		JMP block_3


	block_3:
		%169 = LOAD int %158
		%170 = int %169 + %157
		%158 = STORE int %170
		%171 = LOAD *u8 %154
		%172 = CALL %128(%171)
		%154 = STORE *u8 %172
		JMP block_1


	block_4:
		RET

}

fn format_uint(*[]u32 %0, uint %1) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC *[]u32
		%148 = STORE *[]u32 %147
		%149 = ARG #1
		%150 = ALLOC uint
		%150 = STORE uint %149
		%151 = ALLOC [256]u32
		MEMSET %151
		%152 = ALLOC [256]u32
		%152 = STORE [256]u32 %151
		%153 = LOAD uint %150
		%154 = ALLOC uint
		%154 = STORE uint %153
		%155 = LOAD uint %154
		%156 = uint 0
		%157 = %155 == %156
		IF %157 goto block_1, else goto block_2


	block_1:
		%158 = LOAD *[]u32 %148
		%159 = u32 48
		%160 = CALL %136(%158, %159)
		RET


	block_2:
		JMP block_3


	block_3:
		%163 = int 0
		%164 = ALLOC int
		%164 = STORE int %163
		JMP block_4


	block_4:
		%166 = LOAD uint %154
		%167 = uint 0
		%168 = %166 > %167
		IF %168 goto block_5, else goto block_6


	block_5:
		%169 = LOAD uint %154
		%170 = uint 10
		%171 = uint %169 % %170
		%172 = ALLOC uint
		%172 = STORE uint %171
		%173 = LOAD uint %154
		%174 = uint 10
		%175 = uint %173 / %174
		%154 = STORE uint %175
		%176 = u32 48
		%177 = CAST u32 to uint %176
		%178 = LOAD uint %172
		%179 = uint %177 + %178
		%180 = ALLOC uint
		%180 = STORE uint %179
		%181 = LOAD int %164
		%182 = %152[%181] [256]u32
		%183 = LOAD uint %180
		%184 = CAST uint to u32 %183
		%182 = STORE u32 %184
		%185 = LOAD int %164
		%186 = int 1
		%187 = int %185 + %186
		%164 = STORE int %187
		JMP block_4


	block_6:
		%189 = int 0
		%190 = LOAD int %164
		%191 = int 0
		%192 = int 1
		%193 = ALLOC int
		%193 = STORE int %191
		JMP block_7


	block_7:
		%195 = LOAD int %193
		%196 = %195 < %190
		IF %196 goto block_8, else goto block_10


	block_8:
		%197 = LOAD *[]u32 %148
		%198 = LOAD int %164
		%199 = LOAD int %193
		%200 = int %198 - %199
		%201 = int 1
		%202 = int %200 - %201
		%203 = %152[%202] [256]u32
		%204 = LOAD u32 %203
		%205 = CALL %136(%197, %204)
		JMP block_9


	block_9:
		%207 = LOAD int %193
		%208 = int %207 + %192
		%193 = STORE int %208
		JMP block_7


	block_10:
		RET

}

fn format_int(*[]u32 %0, int %1) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC *[]u32
		%148 = STORE *[]u32 %147
		%149 = ARG #1
		%150 = ALLOC int
		%150 = STORE int %149
		%151 = ALLOC [256]u32
		MEMSET %151
		%152 = ALLOC [256]u32
		%152 = STORE [256]u32 %151
		%153 = LOAD int %150
		%154 = ALLOC int
		%154 = STORE int %153
		%155 = LOAD int %154
		%156 = int 0
		%157 = %155 == %156
		IF %157 goto block_1, else goto block_2


	block_1:
		%158 = LOAD *[]u32 %148
		%159 = u32 48
		%160 = CALL %136(%158, %159)
		RET


	block_2:
		JMP block_3


	block_3:
		%163 = bool 0
		%164 = ALLOC bool
		%164 = STORE bool %163
		%165 = LOAD int %154
		%166 = int 0
		%167 = %165 < %166
		IF %167 goto block_4, else goto block_5


	block_4:
		%168 = int 0
		%169 = LOAD int %154
		%170 = int %168 - %169
		%154 = STORE int %170
		%171 = bool 1
		%164 = STORE bool %171
		JMP block_6


	block_5:
		JMP block_6


	block_6:
		%174 = int 0
		%175 = ALLOC int
		%175 = STORE int %174
		JMP block_7


	block_7:
		%177 = LOAD int %154
		%178 = int 0
		%179 = %177 > %178
		IF %179 goto block_8, else goto block_9


	block_8:
		%180 = LOAD int %154
		%181 = int 10
		%182 = int %180 % %181
		%183 = ALLOC int
		%183 = STORE int %182
		%184 = LOAD int %154
		%185 = int 10
		%186 = int %184 / %185
		%154 = STORE int %186
		%187 = u32 48
		%188 = LOAD int %183
		%189 = CAST int to u8 %188
		%190 = CAST u8 to u32 %189
		%191 = u32 %187 + %190
		%192 = ALLOC u32
		%192 = STORE u32 %191
		%193 = LOAD int %175
		%194 = %152[%193] [256]u32
		%195 = LOAD u32 %192
		%194 = STORE u32 %195
		%196 = LOAD int %175
		%197 = int 1
		%198 = int %196 + %197
		%175 = STORE int %198
		JMP block_7


	block_9:
		%200 = LOAD bool %164
		IF %200 goto block_10, else goto block_11


	block_10:
		%201 = LOAD *[]u32 %148
		%202 = u32 45
		%203 = CALL %136(%201, %202)
		JMP block_12


	block_11:
		JMP block_12


	block_12:
		%206 = int 0
		%207 = LOAD int %175
		%208 = int 0
		%209 = int 1
		%210 = ALLOC int
		%210 = STORE int %208
		JMP block_13


	block_13:
		%212 = LOAD int %210
		%213 = %212 < %207
		IF %213 goto block_14, else goto block_16


	block_14:
		%214 = LOAD *[]u32 %148
		%215 = LOAD int %175
		%216 = LOAD int %210
		%217 = int %215 - %216
		%218 = int 1
		%219 = int %217 - %218
		%220 = %152[%219] [256]u32
		%221 = LOAD u32 %220
		%222 = CALL %136(%214, %221)
		JMP block_15


	block_15:
		%224 = LOAD int %210
		%225 = int %224 + %209
		%210 = STORE int %225
		JMP block_13


	block_16:
		RET

}

fn builder_to_string(*[]u32 %0) -> []u8 {

	block_0:
		%147 = ARG #0
		%148 = ALLOC *[]u32
		%148 = STORE *[]u32 %147
		%149 = LOAD *[]u32 %148
		%150 = ALLOC *[]u32
		%150 = STORE *[]u32 %149
		%151 = ALLOC mem.Allocator
		%152 = CALL %111(%151)
		%153 = ALLOC mem.Allocator
		%153 = STORE mem.Allocator %151
		%154 = ALLOC []u8
		%155 = uint 2
		%156 = CALL %140(%154, %155, %153)
		%157 = ALLOC []u8
		%157 = STORE []u8 %154
		%158 = int 0
		%159 = LOAD *[]u32 %150
		%160 = %159[%0] []u32
		%161 = LOAD int %160
		%162 = int 0
		%163 = int 1
		%164 = ALLOC int
		%164 = STORE int %162
		JMP block_1


	block_1:
		%166 = LOAD int %164
		%167 = %166 < %161
		IF %167 goto block_2, else goto block_4


	block_2:
		%168 = LOAD *[]u32 %150
		%169 = %168[%1] []u32
		%170 = LOAD *u32 %169
		%171 = LOAD int %164
		%172 = %170[%171] *u32
		%173 = ALLOC *u8
		%173 = STORE *u8 %172
		%174 = LOAD *u8 %173
		%175 = i64 3
		%176 = %174[%175] *u8
		%173 = STORE *u8 %176
		JMP block_5


	block_5:
		%178 = LOAD *u8 %173
		%179 = LOAD u8 %178
		%180 = u8 0
		%181 = %179 == %180
		IF %181 goto block_6, else goto block_7


	block_6:
		%182 = LOAD *u8 %173
		%183 = i64 1
		%184 = int 0
		%185 = int %184 - %183
		%186 = %182[%185] *u8
		%173 = STORE *u8 %186
		JMP block_5


	block_7:
		%188 = LOAD *u8 %173
		%189 = CALL %127(%188)
		%190 = ALLOC int
		%190 = STORE int %189
		%191 = int 0
		%192 = LOAD int %190
		%193 = int 0
		%194 = int 1
		%195 = ALLOC int
		%195 = STORE int %193
		JMP block_8


	block_8:
		%197 = LOAD int %195
		%198 = %197 < %192
		IF %198 goto block_9, else goto block_11


	block_9:
		%199 = LOAD *u8 %173
		%200 = LOAD int %195
		%201 = int 0
		%202 = int %201 - %200
		%203 = %199[%202] *u8
		%204 = LOAD u8 %203
		%205 = CALL %141(%157, %204)
		JMP block_10


	block_10:
		%207 = LOAD int %195
		%208 = int %207 + %194
		%195 = STORE int %208
		JMP block_8


	block_11:
		JMP block_3


	block_3:
		%211 = LOAD int %164
		%212 = int %211 + %163
		%164 = STORE int %212
		JMP block_1


	block_4:
		RET []u8 %157

}

fn format_float:(type,*[]u32,f32,i32)->void(type %0, *[]u32 %1, f32 %2, i32 %3) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC type
		%148 = STORE type %147
		%149 = ARG #1
		%150 = ALLOC *[]u32
		%150 = STORE *[]u32 %149
		%151 = ARG #2
		%152 = ALLOC f32
		%152 = STORE f32 %151
		%153 = ARG #3
		%154 = ALLOC i32
		%154 = STORE i32 %153
		%155 = ALLOC [256]u32
		MEMSET %155
		%156 = ALLOC [256]u32
		%156 = STORE [256]u32 %155
		%157 = int 0
		%158 = ALLOC int
		%158 = STORE int %157
		%159 = LOAD f32 %152
		%160 = ALLOC f32
		%160 = STORE f32 %159
		%161 = ALLOC bool
		%162 = LOAD type %148
		%163 = uint 10
		%164 = %162 != %163
		IF %164 goto block_3, else goto block_2


	block_3:
		%165 = LOAD type %148
		%166 = uint 11
		%167 = %165 != %166
		IF %167 goto block_1, else goto block_2


	block_1:
		%168 = bool 1
		%161 = STORE bool %168
		JMP block_4


	block_2:
		%170 = bool 0
		%161 = STORE bool %170
		JMP block_4


	block_4:
		%172 = LOAD bool %161
		IF %172 goto block_5, else goto block_6


	block_5:
		RET


	block_6:
		JMP block_7


	block_7:
		%175 = LOAD f32 %160
		%176 = f32 0
		%177 = %175 == %176
		IF %177 goto block_8, else goto block_9


	block_8:
		%178 = LOAD *[]u32 %150
		%179 = u32 48
		%180 = CALL %136(%178, %179)
		RET


	block_9:
		JMP block_10


	block_10:
		%183 = bool 0
		%184 = ALLOC bool
		%184 = STORE bool %183
		%185 = LOAD f32 %160
		%186 = f32 0
		%187 = %185 < %186
		IF %187 goto block_11, else goto block_12


	block_11:
		%188 = f32 0
		%189 = LOAD f32 %160
		%190 = f32 %188 - %189
		%160 = STORE f32 %190
		%191 = bool 1
		%184 = STORE bool %191
		JMP block_13


	block_12:
		JMP block_13


	block_13:
		%194 = LOAD f32 %160
		%195 = f32 0.005000
		%196 = f32 %194 + %195
		%160 = STORE f32 %196
		%197 = LOAD f32 %160
		%198 = CAST f32 to i32 %197
		%199 = ALLOC i32
		%199 = STORE i32 %198
		%200 = LOAD f32 %160
		%201 = LOAD i32 %154
		%202 = CAST i32 to f32 %201
		%203 = f32 %200 * %202
		%204 = CAST f32 to i32 %203
		%205 = LOAD i32 %154
		%206 = i32 %204 % %205
		%207 = ALLOC i32
		%207 = STORE i32 %206
		%208 = LOAD i32 %207
		%209 = i32 0
		%210 = %208 == %209
		IF %210 goto block_14, else goto block_15


	block_14:
		%211 = LOAD int %158
		%212 = %156[%211] [256]u32
		%213 = u32 48
		%212 = STORE u32 %213
		%214 = LOAD int %158
		%215 = int 1
		%216 = int %214 + %215
		%158 = STORE int %216
		JMP block_16


	block_15:
		JMP block_17


	block_17:
		%219 = LOAD i32 %207
		%220 = i32 0
		%221 = %219 > %220
		IF %221 goto block_18, else goto block_19


	block_18:
		%222 = LOAD int %158
		%223 = %156[%222] [256]u32
		%224 = u32 48
		%225 = LOAD i32 %207
		%226 = i32 10
		%227 = i32 %225 % %226
		%228 = CAST i32 to u8 %227
		%229 = CAST u8 to u32 %228
		%230 = u32 %224 + %229
		%223 = STORE u32 %230
		%231 = LOAD int %158
		%232 = int 1
		%233 = int %231 + %232
		%158 = STORE int %233
		%234 = LOAD i32 %207
		%235 = i32 10
		%236 = i32 %234 / %235
		%207 = STORE i32 %236
		JMP block_17


	block_19:
		JMP block_16


	block_16:
		%239 = LOAD int %158
		%240 = %156[%239] [256]u32
		%241 = u32 46
		%240 = STORE u32 %241
		%242 = LOAD int %158
		%243 = int 1
		%244 = int %242 + %243
		%158 = STORE int %244
		%245 = LOAD i32 %199
		%246 = i32 0
		%247 = %245 == %246
		IF %247 goto block_20, else goto block_21


	block_20:
		%248 = LOAD int %158
		%249 = %156[%248] [256]u32
		%250 = u32 48
		%249 = STORE u32 %250
		%251 = LOAD int %158
		%252 = int 1
		%253 = int %251 + %252
		%158 = STORE int %253
		JMP block_22


	block_21:
		JMP block_23


	block_23:
		%256 = LOAD i32 %199
		%257 = i32 0
		%258 = %256 > %257
		IF %258 goto block_24, else goto block_25


	block_24:
		%259 = LOAD int %158
		%260 = %156[%259] [256]u32
		%261 = u32 48
		%262 = LOAD i32 %199
		%263 = i32 10
		%264 = i32 %262 % %263
		%265 = CAST i32 to u32 %264
		%266 = u32 %261 + %265
		%260 = STORE u32 %266
		%267 = LOAD int %158
		%268 = int 1
		%269 = int %267 + %268
		%158 = STORE int %269
		%270 = LOAD i32 %199
		%271 = i32 10
		%272 = i32 %270 / %271
		%199 = STORE i32 %272
		JMP block_23


	block_25:
		JMP block_22


	block_22:
		%275 = LOAD bool %184
		IF %275 goto block_26, else goto block_27


	block_26:
		%276 = LOAD *[]u32 %150
		%277 = u32 45
		%278 = CALL %136(%276, %277)
		JMP block_28


	block_27:
		JMP block_28


	block_28:
		%281 = int 0
		%282 = LOAD int %158
		%283 = int 0
		%284 = int 1
		%285 = ALLOC int
		%285 = STORE int %283
		JMP block_29


	block_29:
		%287 = LOAD int %285
		%288 = %287 < %282
		IF %288 goto block_30, else goto block_32


	block_30:
		%289 = LOAD *[]u32 %150
		%290 = LOAD int %158
		%291 = LOAD int %285
		%292 = int %290 - %291
		%293 = int 1
		%294 = int %292 - %293
		%295 = %156[%294] [256]u32
		%296 = LOAD u32 %295
		%297 = CALL %136(%289, %296)
		JMP block_31


	block_31:
		%299 = LOAD int %285
		%300 = int %299 + %284
		%285 = STORE int %300
		JMP block_29


	block_32:
		RET

}

fn format_float:(type,*[]u32,f64,i32)->void(type %0, *[]u32 %1, f64 %2, i32 %3) {

	block_0:
		%147 = ARG #0
		%148 = ALLOC type
		%148 = STORE type %147
		%149 = ARG #1
		%150 = ALLOC *[]u32
		%150 = STORE *[]u32 %149
		%151 = ARG #2
		%152 = ALLOC f64
		%152 = STORE f64 %151
		%153 = ARG #3
		%154 = ALLOC i32
		%154 = STORE i32 %153
		%155 = ALLOC [256]u32
		MEMSET %155
		%156 = ALLOC [256]u32
		%156 = STORE [256]u32 %155
		%157 = int 0
		%158 = ALLOC int
		%158 = STORE int %157
		%159 = LOAD f64 %152
		%160 = ALLOC f64
		%160 = STORE f64 %159
		%161 = ALLOC bool
		%162 = LOAD type %148
		%163 = uint 10
		%164 = %162 != %163
		IF %164 goto block_3, else goto block_2


	block_3:
		%165 = LOAD type %148
		%166 = uint 11
		%167 = %165 != %166
		IF %167 goto block_1, else goto block_2


	block_1:
		%168 = bool 1
		%161 = STORE bool %168
		JMP block_4


	block_2:
		%170 = bool 0
		%161 = STORE bool %170
		JMP block_4


	block_4:
		%172 = LOAD bool %161
		IF %172 goto block_5, else goto block_6


	block_5:
		RET


	block_6:
		JMP block_7


	block_7:
		%175 = LOAD f64 %160
		%176 = f64 0
		%177 = %175 == %176
		IF %177 goto block_8, else goto block_9


	block_8:
		%178 = LOAD *[]u32 %150
		%179 = u32 48
		%180 = CALL %136(%178, %179)
		RET


	block_9:
		JMP block_10


	block_10:
		%183 = bool 0
		%184 = ALLOC bool
		%184 = STORE bool %183
		%185 = LOAD f64 %160
		%186 = f64 0
		%187 = %185 < %186
		IF %187 goto block_11, else goto block_12


	block_11:
		%188 = f64 0
		%189 = LOAD f64 %160
		%190 = f64 %188 - %189
		%160 = STORE f64 %190
		%191 = bool 1
		%184 = STORE bool %191
		JMP block_13


	block_12:
		JMP block_13


	block_13:
		%194 = LOAD f64 %160
		%195 = f64 0.005000
		%196 = f64 %194 + %195
		%160 = STORE f64 %196
		%197 = LOAD f64 %160
		%198 = CAST f64 to i32 %197
		%199 = ALLOC i32
		%199 = STORE i32 %198
		%200 = LOAD f64 %160
		%201 = LOAD i32 %154
		%202 = CAST i32 to f64 %201
		%203 = f64 %200 * %202
		%204 = CAST f64 to i32 %203
		%205 = LOAD i32 %154
		%206 = i32 %204 % %205
		%207 = ALLOC i32
		%207 = STORE i32 %206
		%208 = LOAD i32 %207
		%209 = i32 0
		%210 = %208 == %209
		IF %210 goto block_14, else goto block_15


	block_14:
		%211 = LOAD int %158
		%212 = %156[%211] [256]u32
		%213 = u32 48
		%212 = STORE u32 %213
		%214 = LOAD int %158
		%215 = int 1
		%216 = int %214 + %215
		%158 = STORE int %216
		JMP block_16


	block_15:
		JMP block_17


	block_17:
		%219 = LOAD i32 %207
		%220 = i32 0
		%221 = %219 > %220
		IF %221 goto block_18, else goto block_19


	block_18:
		%222 = LOAD int %158
		%223 = %156[%222] [256]u32
		%224 = u32 48
		%225 = LOAD i32 %207
		%226 = i32 10
		%227 = i32 %225 % %226
		%228 = CAST i32 to u8 %227
		%229 = CAST u8 to u32 %228
		%230 = u32 %224 + %229
		%223 = STORE u32 %230
		%231 = LOAD int %158
		%232 = int 1
		%233 = int %231 + %232
		%158 = STORE int %233
		%234 = LOAD i32 %207
		%235 = i32 10
		%236 = i32 %234 / %235
		%207 = STORE i32 %236
		JMP block_17


	block_19:
		JMP block_16


	block_16:
		%239 = LOAD int %158
		%240 = %156[%239] [256]u32
		%241 = u32 46
		%240 = STORE u32 %241
		%242 = LOAD int %158
		%243 = int 1
		%244 = int %242 + %243
		%158 = STORE int %244
		%245 = LOAD i32 %199
		%246 = i32 0
		%247 = %245 == %246
		IF %247 goto block_20, else goto block_21


	block_20:
		%248 = LOAD int %158
		%249 = %156[%248] [256]u32
		%250 = u32 48
		%249 = STORE u32 %250
		%251 = LOAD int %158
		%252 = int 1
		%253 = int %251 + %252
		%158 = STORE int %253
		JMP block_22


	block_21:
		JMP block_23


	block_23:
		%256 = LOAD i32 %199
		%257 = i32 0
		%258 = %256 > %257
		IF %258 goto block_24, else goto block_25


	block_24:
		%259 = LOAD int %158
		%260 = %156[%259] [256]u32
		%261 = u32 48
		%262 = LOAD i32 %199
		%263 = i32 10
		%264 = i32 %262 % %263
		%265 = CAST i32 to u32 %264
		%266 = u32 %261 + %265
		%260 = STORE u32 %266
		%267 = LOAD int %158
		%268 = int 1
		%269 = int %267 + %268
		%158 = STORE int %269
		%270 = LOAD i32 %199
		%271 = i32 10
		%272 = i32 %270 / %271
		%199 = STORE i32 %272
		JMP block_23


	block_25:
		JMP block_22


	block_22:
		%275 = LOAD bool %184
		IF %275 goto block_26, else goto block_27


	block_26:
		%276 = LOAD *[]u32 %150
		%277 = u32 45
		%278 = CALL %136(%276, %277)
		JMP block_28


	block_27:
		JMP block_28


	block_28:
		%281 = int 0
		%282 = LOAD int %158
		%283 = int 0
		%284 = int 1
		%285 = ALLOC int
		%285 = STORE int %283
		JMP block_29


	block_29:
		%287 = LOAD int %285
		%288 = %287 < %282
		IF %288 goto block_30, else goto block_32


	block_30:
		%289 = LOAD *[]u32 %150
		%290 = LOAD int %158
		%291 = LOAD int %285
		%292 = int %290 - %291
		%293 = int 1
		%294 = int %292 - %293
		%295 = %156[%294] [256]u32
		%296 = LOAD u32 %295
		%297 = CALL %136(%289, %296)
		JMP block_31


	block_31:
		%299 = LOAD int %285
		%300 = int %299 + %284
		%285 = STORE int %300
		JMP block_29


	block_32:
		RET

}

