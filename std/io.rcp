io

#import os
#import array
#import mem
#import base as *
#import str as *

print :: fn(str: string, args: ...) {
    builder := internal_print(str, args);
    os.print(@*u8 &builder.data[0], @u32 builder.data.count);
    array.free(&builder.data);
}

println :: fn(str: string, args: ...) {
    builder := internal_print(str, args);
    builder_append_u8(&builder, @u8 '\n');
    os.print(@*u8 &builder.data[0], @u32 builder.data.count);
    array.free(&builder.data);
}

sprint :: fn(str: string, args: ...) -> string {
    builder := internal_print(str, args);
    res := from_builder(&builder, &mem.temp_alloc);
    return res;
}

vsprint :: fn(str: string, args: []Arg) -> string {
    builder := internal_print(str, args);
    res := from_builder(&builder, &mem.temp_alloc);
    return res;
}

read_entire_file :: fn(name: string, alloc: *mem.Allocator) -> (string, bool) {
	f_ := os.open(name);
	if f_ == null {
		return "", false;
	}
	f := ?f_;
	defer os.close(f);

	size := os.get_file_size(f);
	mem_ := alloc.alloc(size+1, alloc);
	if mem_ == null {
		return "", false;
	}

	mem := @*u8 ?mem_;
	read := os.read(f, mem, size);
    mem[read] = 0;
	return string { read, mem }, true;
}

readln :: fn(alloc: *mem.Allocator) -> string {
	MAX :: 1024;
    mem := alloc.alloc(MAX, alloc);
    if mem == null {
		println("Failed to allocate buffer for readln");
        return "";
    }

    buf := @*u8 ?mem;
    count := os.read_stdin_line(buf, @u32 MAX);
    if count == 0 {
        return "";
    }
    
    res: string;
    res.data = buf;
    res.count = @int count;

    return res;
}

read :: fn(bytes: int, alloc: *mem.Allocator) -> string {
	stdin := os.stdin();
	allocated := alloc.alloc(bytes, alloc);
	if allocated == null return "";
	buf := @*u8 ?allocated;
	read := os.read(stdin, buf, bytes);
	if read == -1 || read == 0 {
		alloc.free(buf, alloc);
		return "";
	}

	return string { read, buf };
}

// PRIVATE SECTION
#private

print_typetype :: fn(b: *Builder, info: *TypeInfo) {
    match info.kind {
        TypeKind.Invalid: {
            builder_append(b, "invalid");
        }
        TypeKind.Basic: {
            builder_append(b, info.t.basic.name);
        }
        TypeKind.Function: {
            builder_append(b, "fn(");
            args := info.t.function.args_t;
            for i, arg in args {
                print_typetype(b, type_info(arg));
                if i + 1 != args.count {
                    builder_append(b, ", ");
                }
            }
            builder_append(b, ")");
            if info.t.function.returns.count != 0 {
                builder_append(b, " -> ");
                for i, t in info.t.function.returns {
                    if i != 0
                        builder_append(b, ", ");
                    print_typetype(b, type_info(t));
                }
            }
        }
        TypeKind.Struct: {
            builder_append(b, info.t.struct_.name);
        }
        TypeKind.Pointer: {
            builder_append(b, "*");
            print_typetype(b, type_info(info.t.pointer.pointee));
        }
        TypeKind.Array: {
            builder_append_u8(b, @u8 '[');
            format_uint(b, info.t.array.member_count);
            builder_append_u8(b, @u8 ']');
            print_typetype(b, type_info(info.t.array.t));
        }
        TypeKind.Slice: {
            builder_append(b, "[]");
            print_typetype(b, type_info(info.t.slice.t));
        }
        TypeKind.Vector: {
            vect := info.t.vector;
            builder_append_u8(b, @u8 '<');
            match vect.kind {
                .Float: {
                    builder_append(b, "f32x");
                }
                .Int: {
                    builder_append(b, "i32x");
                }
                .UInt: {
                    builder_append(b, "u32x");
                }
            };
            format_uint(b, vect.elem_count);
            builder_append_u8(b, @u8 '>');
        }
        TypeKind.Enum: {
            builder_append(b, info.t.enum_.name);
        }
        TypeKind.Generic: {
            builder_append(b, info.t.generic.name);
        }
    };

}


is_digit :: fn(c: u32) -> bool {
    return c >= '0' && c <= '9';
}

internal_print :: fn(fmt: string, args: []base.Arg) -> Builder {
    builder := create_builder(&mem.temp_alloc);
    arg_count := 0;
    need_to_print_arg := false;
    for c in fmt {
        if c == '%' && args.count > arg_count {
            need_to_print_arg = true;
        } else {
            if need_to_print_arg {
                arg: Arg;
                if is_digit(c) {
                    arg = args[c - '0'];
                }
                else {
                    arg = args[arg_count];
                    arg_count += 1;
                }
                print_type_with_formatter(&builder, c, arg);
                need_to_print_arg = false;
            } else {
                builder_append_u32(&builder, c);
            }
        }
    }

    if need_to_print_arg {
        arg := args[arg_count];
        arg_count += 1;
        print_type_with_formatter(&builder, '\0', arg);
        need_to_print_arg = false;
    }

    return builder;
}

print_type_with_formatter :: fn(b: *Builder, c: u32, arg: Arg) {
    t := type_info(arg.t);
    if c == 's' && t.kind == TypeKind.Pointer && t.t.pointer.pointee == u8 {
        str: *u8 = *@**u8 arg.val;
        for i := 0; str[i] != '\0'; i += 1 {
            builder_append_u8(b, str[i]);
        }
    } else if c == 'c' && t.kind == TypeKind.Basic &&
        (t.t.basic.kind == BasicKind.U8 || t.t.basic.kind == BasicKind.U32) {
            c: u32;
            if t.t.basic.kind == BasicKind.U8 {
                c = *@*u8 arg.val;
            } else if t.t.basic.kind == BasicKind.U32 {
                c = *@*u32 arg.val;
            }
            builder_append_u32(b, c);
    } else {
        print_type(b, arg);
		if c != 0 && !is_digit(c)
			builder_append_u32(b, c);
    }
}

print_type :: fn(b: *Builder, arg: base.Arg) {
    t := type_info(arg.t);
    match t.kind {
        base.TypeKind.Invalid: {
        }
        TypeKind.Basic: {
            basic := t.t.basic;
            if basic.kind == BasicKind.Bool {
                if *@*bool arg.val {
                    builder_append(b, "true");
                } else {
                    builder_append(b, "false");
                }
            }
            else if basic.kind == BasicKind.String {
                str: string = *@*string arg.val;
                builder_append(b, str);
            }
            //else if basic.kind == base.BasicKind.Cstring {
            //    str: cstring = *@*cstring arg.val;
            //    for i := 0; str[i] != '\0'; i += 1 {
            //        array.add(b, str[i]);
            //    }

            //}
            else if basic.kind == BasicKind.U8  {
                num: uint = *@*u8 arg.val;
                format_uint(b, num);
            }
            else if basic.kind == BasicKind.U16 {
                num: uint = *@*u16 arg.val;
                format_uint(b, num);
            }
            else if basic.kind == BasicKind.U32 {
                num: uint = *@*u32 arg.val;
                format_uint(b, num);
            }
            else if basic.kind == BasicKind.U64 {
                num: uint = *@*u64 arg.val;
                format_uint(b, num);
            }
            else if basic.kind == BasicKind.I8  {
                num: int = *@*i8 arg.val;
                format_int(b, num);
            }
            else if basic.kind == BasicKind.I16 {
                num: int = *@*i16 arg.val;
                format_int(b, num);
            }
            else if basic.kind == BasicKind.I32 {
                num: int = *@*i32 arg.val;
                format_int(b, num);
            }
            else if basic.kind == BasicKind.I64 {
                num: int = *@*i64 arg.val;
                format_int(b, num);
            }
            else if basic.kind == BasicKind.Int {
                num: int = *@*int arg.val;
                format_int(b, num);
            }
            else if basic.kind == BasicKind.Uint {
                num: uint = *@*uint arg.val;
                format_uint(b, num);
            }
            else if basic.kind == BasicKind.F32 {
                num := *@*f32 arg.val;
                format_float(f32, b, num, 100);
            }
            else if basic.kind == BasicKind.F64 {
                num := *@*f64 arg.val;
                format_float(f64, b, num, 100);
            }
            else if basic.kind == BasicKind.Type {
                pt := *@*type arg.val;
                info := type_info(pt);
                print_typetype(b, info);
            }
            else {
                builder_append_u32(b, '%');
            }
        }
        TypeKind.Function: {
        }
        TypeKind.Struct: {
            st := t.t.struct_;
            builder_append(b, st.name);
            builder_append(b, " { ");
            for n in st.members.count {
                m := st.members[n];
                builder_append(b, m.name);
                builder_append(b, " = ");
                ptr := @*u8 arg.val;
                offset := get_struct_member_offset(st, n);
                mem_arg := Arg {
                    t = m.t,
                    val = &ptr[offset],
                };
                mem_arg.t = m.t;

                print_type(b, mem_arg);
                if n + 1 != st.members.count {
                    builder_append(b, ", ");
                }
            }
            builder_append(b, " }");
        }
        TypeKind.Pointer: {
			num: uint = *@*uint arg.val;
	 		format_uint(b, num);
        }
        TypeKind.Array: {
        }
        TypeKind.Slice: {
        }
        TypeKind.Vector: {
            vect := t.t.vector;
            at := @*u8 arg.val;
            builder_append(b, "{ ");
            for i in vect.elem_count {
                if i != 0 builder_append(b, ", ");
                match vect.kind {
                    .Float: {
                        num := *@*f32 at;
                        format_float(f32, b, num, 100);
                    }
                    .Int: {
                        num := *@*i32 at;
                        format_int(b, num);
                    }
                    .UInt: {
                        num := *@*u32 at;
                        format_uint(b, num);
                    }
                };
                at += 4;
            }
            builder_append(b, " }");
        }
        TypeKind.Enum: {
            e := t.t.enum_;
            size := get_type_size(e.t);
            val := match size {
                1: { yield @int *@*i8 arg.val; }
                2: { yield @int *@*i16 arg.val; }
                4: { yield @int *@*i32 arg.val; }
                8: { yield @int *@*i64 arg.val; }
            };

            for m in e.members {
                if m.value == val {
                    builder_append(b, m.name);
                    break;
                }
            }
        }
        TypeKind.Generic: {
        }
    };
}

