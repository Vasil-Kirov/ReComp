
//printf :: fn #cdecl(fmt: cstring, num: i64);
//malloc :: fn #cdecl(size: int) -> u8*;
//free   :: fn #cdecl(ptr: u8*);

struct Foo {
	data: i32[5],
}

memcpy :: fn(dst: u8*, src: u8*, num: uint)
{
	c0 := dst;
	c1 := src;
	size := num;
	for ; size > 0 ; {
		*c0 = *c1;
		c0 += 1;
		c1 += 1;
		size -= 1;
	}
}

main :: fn() -> i32 {
	x := Foo { data = {@i32 1, 2, 3, 4, 5} };


	return x.data[3];

}


// GENERICS SYNTAX
// struct stack!T {
// 	items: T[];
//  top: int;
// }
// 
// push!T :: fn(Stack: *stack!T, item: T) -> T {
// 	return stack.items[stack.top++] = item;
// }

// 1. 2 * 3
// 2. 4 / 1
// 3. (2) % 0
// 4. 10 + (1) - (3)

