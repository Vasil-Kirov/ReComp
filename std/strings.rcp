str

#import mem 
#import array

struct Builder {
    data: []u8,
}

to_int :: fn (str: string) -> int {
    neg := false;
    res := 0;
    for c in str {
        if c == '-' {
            if neg return 0;
            neg = true;
            continue;
        }

        res *= 10;
        
        val := match c {
            '0': yield 0;
            '1': yield 1;
            '2': yield 2;
            '3': yield 3;
            '4': yield 4;
            '5': yield 5;
            '6': yield 6;
            '7': yield 7;
            '8': yield 8;
            '9': yield 9;
        };
        res += val;
    }

    if neg res = -res;
    return res;
}

create_builder :: fn (alloc: *mem.Allocator) -> Builder {
    return Builder {
        data = array.create(u8, alloc)
    };
}

printf :: fn(fmt: *u8, args: ...) -> int #foreign;

builder_append :: fn(b: *Builder, str: string) {
    b := b;
    for i in str.count {
        array.add(&b.data, str.data[i]);
		//printf(c"char: 0x%X\n", c);
    }
}

builder_append_u32 :: fn(b: *Builder, c: u32) {
	b := b;
	c := c;
	scan := @*u8 &c;
	for *scan & CONTINUE_BIT {
		array.add(&b.data, *scan);
		scan += 1;
	}
	array.add(&b.data, *scan);
    //b := b;
    //array.add(&b.data, c);
}

builder_append_u8 :: fn(b: *Builder, c: u8) {
    b := b;
    array.add(&b.data, c);
}

// @TODO: proper utf8-handling
from_builder :: fn (b: *Builder, alloc: *mem.Allocator) -> string {
    b := b;
    data_ := alloc.alloc(b.data.count+1, alloc);
	if data_ == null return "";
	data := @*u8 ?data_;
    scan := b.data.data;
	len := b.data.count;
    for i := 0; i < len; i += 1 {
        data[i] = scan[i];
    }
	data[len] = 0;

    array.free(&b.data);

    return string { len, data };
}

CONTINUE_BIT :: @u8 0b1000_0000;

substr :: fn(original: string, from: int, to_excl: int) -> string {
    o := original;
    r: string;
    r.data = &o.data[from];
    r.count = to_excl-from;
    return r;
}

get_codepoint_size :: fn(codepoint: *u8) -> int {
    p := codepoint;
    if (*p & CONTINUE_BIT) == 0 {
        return 1;
    }

    size := 1;
    for i := 1; @u32 *p & (@u32 CONTINUE_BIT >> @u32 i); i += 1 {
        size += 1;
    }
    return size;
}

advance :: fn(pos: *u8) -> *u8 {
    size := get_codepoint_size(pos);
    p := pos;
    return &p[size];
}

deref :: fn(pos: *u8) -> u32 {
    p := pos;
    size := get_codepoint_size(p);
    res: u32;
    for i in size {
        res <<= 8;
        res |= p[i];
    }

    return res;
}

index :: fn(s: string, idx: int) -> u32 {
    if idx >= s.count {
        return 0;
    }

    p := s.data;
    for i in idx {
        p = advance(p);
    }
    return deref(p);
}

format_uint :: fn(b: *Builder, num_in: uint) {
    temp := [256]u32{};
    num := num_in;
    if num == 0 {
        builder_append_u32(b, '0');
        return;
    }

    count := 0;
    for num > 0 {
        digit := num % 10;
        num /= 10;
        c := '0' + digit;
        temp[count] = @u32 c;
        count += 1;
    }

    for i in count {
        builder_append_u32(b, temp[count - i - 1]);
    }
}

format_int :: fn(b: *Builder, num_in: int) {
    temp := [256]u32{};
    num := num_in;
    if num == 0 {
        builder_append_u32(b, '0');
        return;
    }

    is_neg := false;
    if num < 0 {
        num = 0 - num;
        is_neg = true;
    }

    count := 0;
    for num > 0 {
        digit := num % 10;
        num /= 10;
        c := '0' + @u8 digit;
        temp[count] = c;
        count += 1;
    }
    
    if is_neg builder_append_u32(b, '-');

    for i in count {
        builder_append_u32(b, temp[count - i - 1]);
    }
}

format_float :: fn(ft: type, b: *Builder, num_in: ft, round_at: i32) {
    temp := [256]u32{};
    count := 0;
    num := num_in;

    if ft != f32 && ft != f64 {
        return;
    }

    if num == 0 {
        builder_append_u32(b, '0');
        return;
    }

    is_neg := false;
    if num < 0 {
        num = 0 - num;
        is_neg = true;
    }

    num += 0.005;
    int_val := @i32 num;
    dec := @i32 (num * round_at) % round_at;

    if dec == 0 {
        temp[count] = '0';
        count += 1;
    }
    else {
        for dec > 0 {
            temp[count] = '0' + @u8(dec % 10);
            count += 1;
            dec /= 10;
        }
    }

    temp[count] = '.';
    count += 1;

    if int_val == 0 {
        temp[count] = '0';
        count += 1;
    } else {
        for int_val > 0 {
            temp[count] = '0' + @u32 (int_val % 10);
            count += 1;
            int_val /= 10;
        }
    }


    if is_neg {
        builder_append_u32(b, '-');
    }

    for i in count {
        builder_append_u32(b, temp[count - i - 1]);
    }
}

