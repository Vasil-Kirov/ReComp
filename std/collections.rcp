module collection;


#import array;
#import mem;


struct Stack<T>
{
	data: []T,
	top: int,
}


make_stack :: fn(t: type, alloc: *mem.Allocator = null) -> Stack<t> {
	if alloc == null
		alloc = &mem.temp_alloc;
	return Stack<t> {
		data = array.create(t, alloc),
		top = 0,
	};
}

push :: fn(s: *Stack<$t>, elem: t) {
	using s;
	if top == data.count {
		array.add(&data, elem);
		top += 1;
	}
	else {
		data[top] = elem;
		top += 1;
	}
}

pop :: fn(s: *Stack<$t>) -> t {
	using s;
	top -= 1;
	result := data[top];
	return result;
}

free_stack :: fn(s: *Stack<$t>) {
	using s;
	array.free(&data);
}


struct Queue<T>
{
	data: []T,
	front: int,
	size: int,
	capacity: int,
	alloc: *mem.Allocator,
};

make_queue :: fn(t: type, capacity: int, alloc: *mem.Allocator = null) -> Queue<t> {
	if alloc == null
		alloc = &mem.temp_alloc;
	return Queue<t> {
		data = mem.make_slice(t, capacity, alloc),
		front = 0,
		size = 0,
		capacity = capacity,
		alloc = alloc,
	};
}

enqueue :: fn(q: *Queue<$t>, elem: t) {
	using q;
	data[(front + size) % capacity] = elem;
	size += 1;
}

dequeue :: fn(q: *Queue<$t>) -> t {
	using q;
 	#assert size > 0;
	result := data[front];
	front = (front + 1) % capacity;
	size -= 1;
	return result;
}

free_queue :: fn(q: *Queue<$t>) {
	using q;
	mem.destroy_slice(&data, alloc);
	front = 0;
	size = 0;
	capacity = 0;
}




