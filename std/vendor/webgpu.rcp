module webgpu;

UINT32_MAX :: 0xFFFF_FFFF;
UINT64_MAX :: 0xFFFF_FFFF_FFFF_FFFF;

TRUE :: 1 as u32;
FALSE :: 0 as u32;
ARRAY_LAYER_COUNT_UNDEFINED :: UINT32_MAX;
COPY_STRIDE_UNDEFINED :: UINT32_MAX;
DEPTH_SLICE_UNDEFINED :: UINT32_MAX;
LIMIT_U32_UNDEFINED :: UINT32_MAX;
LIMIT_U64_UNDEFINED :: UINT64_MAX;
MIP_LEVEL_COUNT_UNDEFINED :: UINT32_MAX;
QUERY_SET_INDEX_UNDEFINED :: UINT32_MAX;
WHOLE_SIZE :: UINT64_MAX;

struct StringView {
	data: ?*u8,
	length: uint,
}

Flags :: u64;

Bool :: u32;

struct AdapterImpl {
}

Adapter :: ?*AdapterImpl;

struct BindGroupImpl {
}

BindGroup :: ?*BindGroupImpl;

struct BindGroupLayoutImpl {
}

BindGroupLayout :: ?*BindGroupLayoutImpl;

struct BufferImpl {
}

Buffer :: ?*BufferImpl;

struct CommandBufferImpl {
}

CommandBuffer :: ?*CommandBufferImpl;

struct CommandEncoderImpl {
}

CommandEncoder :: ?*CommandEncoderImpl;

struct ComputePassEncoderImpl {
}

ComputePassEncoder :: ?*ComputePassEncoderImpl;

struct ComputePipelineImpl {
}

ComputePipeline :: ?*ComputePipelineImpl;

struct DeviceImpl {
}

Device :: ?*DeviceImpl;

struct InstanceImpl {
}

Instance :: ?*InstanceImpl;

struct PipelineLayoutImpl {
}

PipelineLayout :: ?*PipelineLayoutImpl;

struct QuerySetImpl {
}

QuerySet :: ?*QuerySetImpl;

struct QueueImpl {
}

Queue :: ?*QueueImpl;

struct RenderBundleImpl {
}

RenderBundle :: ?*RenderBundleImpl;

struct RenderBundleEncoderImpl {
}

RenderBundleEncoder :: ?*RenderBundleEncoderImpl;

struct RenderPassEncoderImpl {
}

RenderPassEncoder :: ?*RenderPassEncoderImpl;

struct RenderPipelineImpl {
}

RenderPipeline :: ?*RenderPipelineImpl;

struct SamplerImpl {
}

Sampler :: ?*SamplerImpl;

struct ShaderModuleImpl {
}

ShaderModule :: ?*ShaderModuleImpl;

struct SurfaceImpl {
}

Surface :: ?*SurfaceImpl;

struct TextureImpl {
}

Texture :: ?*TextureImpl;

struct TextureViewImpl {
}

TextureView :: ?*TextureViewImpl;

enum AdapterType: u32 {
	DiscreteGPU = 0x1,
	IntegratedGPU = 0x2,
	CPU = 0x3,
	Unknown = 0x4,
	Force32 = 0x7fffffff,
}

enum AddressMode: u32 {
	Undefined = 0x0,
	ClampToEdge = 0x1,
	Repeat = 0x2,
	MirrorRepeat = 0x3,
	Force32 = 0x7fffffff,
}

enum BackendType: u32 {
	Undefined = 0x0,
	Null = 0x1,
	WebGPU = 0x2,
	D3D11 = 0x3,
	D3D12 = 0x4,
	Metal = 0x5,
	Vulkan = 0x6,
	OpenGL = 0x7,
	OpenGLES = 0x8,
	Force32 = 0x7fffffff,
}

enum BlendFactor: u32 {
	Undefined = 0x0,
	Zero = 0x1,
	One = 0x2,
	Src = 0x3,
	OneMinusSrc = 0x4,
	SrcAlpha = 0x5,
	OneMinusSrcAlpha = 0x6,
	Dst = 0x7,
	OneMinusDst = 0x8,
	DstAlpha = 0x9,
	OneMinusDstAlpha = 0xa,
	SrcAlphaSaturated = 0xb,
	Constant = 0xc,
	OneMinusConstant = 0xd,
	Src1 = 0xe,
	OneMinusSrc1 = 0xf,
	Src1Alpha = 0x10,
	OneMinusSrc1Alpha = 0x11,
	Force32 = 0x7fffffff,
}

enum BlendOperation: u32 {
	Undefined = 0x0,
	Add = 0x1,
	Subtract = 0x2,
	ReverseSubtract = 0x3,
	Min = 0x4,
	Max = 0x5,
	Force32 = 0x7fffffff,
}

enum BufferBindingType: u32 {
	BindingNotUsed = 0x0,
	Undefined = 0x1,
	Uniform = 0x2,
	Storage = 0x3,
	ReadOnlyStorage = 0x4,
	Force32 = 0x7fffffff,
}

enum BufferMapState: u32 {
	Unmapped = 0x1,
	Pending = 0x2,
	Mapped = 0x3,
	Force32 = 0x7fffffff,
}

enum CallbackMode: u32 {
	WaitAnyOnly = 0x1,
	AllowProcessEvents = 0x2,
	AllowSpontaneous = 0x3,
	Force32 = 0x7fffffff,
}

enum CompareFunction: u32 {
	Undefined = 0x0,
	Never = 0x1,
	Less = 0x2,
	Equal = 0x3,
	LessEqual = 0x4,
	Greater = 0x5,
	NotEqual = 0x6,
	GreaterEqual = 0x7,
	Always = 0x8,
	Force32 = 0x7fffffff,
}

enum CompilationInfoRequestStatus: u32 {
	Success = 0x1,
	CallbackCancelled = 0x2,
	Force32 = 0x7fffffff,
}

enum CompilationMessageType: u32 {
	Error = 0x1,
	Warning = 0x2,
	Info = 0x3,
	Force32 = 0x7fffffff,
}

enum CompositeAlphaMode: u32 {
	Auto = 0x0,
	Opaque = 0x1,
	Premultiplied = 0x2,
	Unpremultiplied = 0x3,
	Inherit = 0x4,
	Force32 = 0x7fffffff,
}

enum CreatePipelineAsyncStatus: u32 {
	Success = 0x1,
	CallbackCancelled = 0x2,
	ValidationError = 0x3,
	InternalError = 0x4,
	Force32 = 0x7fffffff,
}

enum CullMode: u32 {
	Undefined = 0x0,
	None = 0x1,
	Front = 0x2,
	Back = 0x3,
	Force32 = 0x7fffffff,
}

enum DeviceLostReason: u32 {
	Unknown = 0x1,
	Destroyed = 0x2,
	CallbackCancelled = 0x3,
	FailedCreation = 0x4,
	Force32 = 0x7fffffff,
}

enum ErrorFilter: u32 {
	Validation = 0x1,
	OutOfMemory = 0x2,
	Internal = 0x3,
	Force32 = 0x7fffffff,
}

enum ErrorType: u32 {
	NoError = 0x1,
	Validation = 0x2,
	OutOfMemory = 0x3,
	Internal = 0x4,
	Unknown = 0x5,
	Force32 = 0x7fffffff,
}

enum FeatureLevel: u32 {
	Undefined = 0x0,
	Compatibility = 0x1,
	Core = 0x2,
	Force32 = 0x7fffffff,
}

enum FeatureName: u32 {
	CoreFeaturesAndLimits = 0x1,
	DepthClipControl = 0x2,
	Depth32FloatStencil8 = 0x3,
	TextureCompressionBC = 0x4,
	TextureCompressionBCSliced3D = 0x5,
	TextureCompressionETC2 = 0x6,
	TextureCompressionASTC = 0x7,
	TextureCompressionASTCSliced3D = 0x8,
	TimestampQuery = 0x9,
	IndirectFirstInstance = 0xa,
	ShaderF16 = 0xb,
	RG11B10UfloatRenderable = 0xc,
	BGRA8UnormStorage = 0xd,
	Float32Filterable = 0xe,
	Float32Blendable = 0xf,
	ClipDistances = 0x10,
	DualSourceBlending = 0x11,
	Subgroups = 0x12,
	TextureFormatsTier1 = 0x13,
	TextureFormatsTier2 = 0x14,
	PrimitiveIndex = 0x15,
	Force32 = 0x7fffffff,
}

enum FilterMode: u32 {
	Undefined = 0x0,
	Nearest = 0x1,
	Linear = 0x2,
	Force32 = 0x7fffffff,
}

enum FrontFace: u32 {
	Undefined = 0x0,
	CCW = 0x1,
	CW = 0x2,
	Force32 = 0x7fffffff,
}

enum IndexFormat: u32 {
	Undefined = 0x0,
	Uint16 = 0x1,
	Uint32 = 0x2,
	Force32 = 0x7fffffff,
}

enum InstanceFeatureName: u32 {
	TimedWaitAny = 0x1,
	ShaderSourceSPIRV = 0x2,
	MultipleDevicesPerAdapter = 0x3,
	Force32 = 0x7fffffff,
}

enum LoadOp: u32 {
	Undefined = 0x0,
	Load = 0x1,
	Clear = 0x2,
	Force32 = 0x7fffffff,
}

enum MapAsyncStatus: u32 {
	Success = 0x1,
	CallbackCancelled = 0x2,
	Error = 0x3,
	Aborted = 0x4,
	Force32 = 0x7fffffff,
}

enum MipmapFilterMode: u32 {
	Undefined = 0x0,
	Nearest = 0x1,
	Linear = 0x2,
	Force32 = 0x7fffffff,
}

enum OptionalBool: u32 {
	False = 0x0,
	True = 0x1,
	Undefined = 0x2,
	Force32 = 0x7fffffff,
}

enum PopErrorScopeStatus: u32 {
	Success = 0x1,
	CallbackCancelled = 0x2,
	Error = 0x3,
	Force32 = 0x7fffffff,
}

enum PowerPreference: u32 {
	Undefined = 0x0,
	LowPower = 0x1,
	HighPerformance = 0x2,
	Force32 = 0x7fffffff,
}

enum PredefinedColorSpace: u32 {
	SRGB = 0x1,
	DisplayP3 = 0x2,
	Force32 = 0x7fffffff,
}

enum PresentMode: u32 {
	Undefined = 0x0,
	Fifo = 0x1,
	FifoRelaxed = 0x2,
	Immediate = 0x3,
	Mailbox = 0x4,
	Force32 = 0x7fffffff,
}

enum PrimitiveTopology: u32 {
	Undefined = 0x0,
	PointList = 0x1,
	LineList = 0x2,
	LineStrip = 0x3,
	TriangleList = 0x4,
	TriangleStrip = 0x5,
	Force32 = 0x7fffffff,
}

enum QueryType: u32 {
	Occlusion = 0x1,
	Timestamp = 0x2,
	Force32 = 0x7fffffff,
}

enum QueueWorkDoneStatus: u32 {
	Success = 0x1,
	CallbackCancelled = 0x2,
	Error = 0x3,
	Force32 = 0x7fffffff,
}

enum RequestAdapterStatus: u32 {
	Success = 0x1,
	CallbackCancelled = 0x2,
	Unavailable = 0x3,
	Error = 0x4,
	Force32 = 0x7fffffff,
}

enum RequestDeviceStatus: u32 {
	Success = 0x1,
	CallbackCancelled = 0x2,
	Error = 0x3,
	Force32 = 0x7fffffff,
}

enum SamplerBindingType: u32 {
	BindingNotUsed = 0x0,
	Undefined = 0x1,
	Filtering = 0x2,
	NonFiltering = 0x3,
	Comparison = 0x4,
	Force32 = 0x7fffffff,
}

enum Status: u32 {
	Success = 0x1,
	Error = 0x2,
	Force32 = 0x7fffffff,
}

enum StencilOperation: u32 {
	Undefined = 0x0,
	Keep = 0x1,
	Zero = 0x2,
	Replace = 0x3,
	Invert = 0x4,
	IncrementClamp = 0x5,
	DecrementClamp = 0x6,
	IncrementWrap = 0x7,
	DecrementWrap = 0x8,
	Force32 = 0x7fffffff,
}

enum StorageTextureAccess: u32 {
	BindingNotUsed = 0x0,
	Undefined = 0x1,
	WriteOnly = 0x2,
	ReadOnly = 0x3,
	ReadWrite = 0x4,
	Force32 = 0x7fffffff,
}

enum StoreOp: u32 {
	Undefined = 0x0,
	Store = 0x1,
	Discard = 0x2,
	Force32 = 0x7fffffff,
}

enum SType: u32 {
	ShaderSourceSPIRV = 0x1,
	ShaderSourceWGSL = 0x2,
	RenderPassMaxDrawCount = 0x3,
	SurfaceSourceMetalLayer = 0x4,
	SurfaceSourceWindowsHWND = 0x5,
	SurfaceSourceXlibWindow = 0x6,
	SurfaceSourceWaylandSurface = 0x7,
	SurfaceSourceAndroidNativeWindow = 0x8,
	SurfaceSourceXCBWindow = 0x9,
	SurfaceColorManagement = 0xa,
	RequestAdapterWebXROptions = 0xb,
	Force32 = 0x7fffffff,
}

enum SurfaceGetCurrentTextureStatus: u32 {
	SuccessOptimal = 0x1,
	SuccessSuboptimal = 0x2,
	Timeout = 0x3,
	Outdated = 0x4,
	Lost = 0x5,
	Error = 0x6,
	Force32 = 0x7fffffff,
}

enum TextureAspect: u32 {
	Undefined = 0x0,
	All = 0x1,
	StencilOnly = 0x2,
	DepthOnly = 0x3,
	Force32 = 0x7fffffff,
}

enum TextureDimension: u32 {
	Undefined = 0x0,
	_1D = 0x1,
	_2D = 0x2,
	_3D = 0x3,
	Force32 = 0x7fffffff,
}

enum TextureFormat: u32 {
	Undefined = 0x0,
	R8Unorm = 0x1,
	R8Snorm = 0x2,
	R8Uint = 0x3,
	R8Sint = 0x4,
	R16Unorm = 0x5,
	R16Snorm = 0x6,
	R16Uint = 0x7,
	R16Sint = 0x8,
	R16Float = 0x9,
	RG8Unorm = 0xa,
	RG8Snorm = 0xb,
	RG8Uint = 0xc,
	RG8Sint = 0xd,
	R32Float = 0xe,
	R32Uint = 0xf,
	R32Sint = 0x10,
	RG16Unorm = 0x11,
	RG16Snorm = 0x12,
	RG16Uint = 0x13,
	RG16Sint = 0x14,
	RG16Float = 0x15,
	RGBA8Unorm = 0x16,
	RGBA8UnormSrgb = 0x17,
	RGBA8Snorm = 0x18,
	RGBA8Uint = 0x19,
	RGBA8Sint = 0x1a,
	BGRA8Unorm = 0x1b,
	BGRA8UnormSrgb = 0x1c,
	RGB10A2Uint = 0x1d,
	RGB10A2Unorm = 0x1e,
	RG11B10Ufloat = 0x1f,
	RGB9E5Ufloat = 0x20,
	RG32Float = 0x21,
	RG32Uint = 0x22,
	RG32Sint = 0x23,
	RGBA16Unorm = 0x24,
	RGBA16Snorm = 0x25,
	RGBA16Uint = 0x26,
	RGBA16Sint = 0x27,
	RGBA16Float = 0x28,
	RGBA32Float = 0x29,
	RGBA32Uint = 0x2a,
	RGBA32Sint = 0x2b,
	Stencil8 = 0x2c,
	Depth16Unorm = 0x2d,
	Depth24Plus = 0x2e,
	Depth24PlusStencil8 = 0x2f,
	Depth32Float = 0x30,
	Depth32FloatStencil8 = 0x31,
	BC1RGBAUnorm = 0x32,
	BC1RGBAUnormSrgb = 0x33,
	BC2RGBAUnorm = 0x34,
	BC2RGBAUnormSrgb = 0x35,
	BC3RGBAUnorm = 0x36,
	BC3RGBAUnormSrgb = 0x37,
	BC4RUnorm = 0x38,
	BC4RSnorm = 0x39,
	BC5RGUnorm = 0x3a,
	BC5RGSnorm = 0x3b,
	BC6HRGBUfloat = 0x3c,
	BC6HRGBFloat = 0x3d,
	BC7RGBAUnorm = 0x3e,
	BC7RGBAUnormSrgb = 0x3f,
	ETC2RGB8Unorm = 0x40,
	ETC2RGB8UnormSrgb = 0x41,
	ETC2RGB8A1Unorm = 0x42,
	ETC2RGB8A1UnormSrgb = 0x43,
	ETC2RGBA8Unorm = 0x44,
	ETC2RGBA8UnormSrgb = 0x45,
	EACR11Unorm = 0x46,
	EACR11Snorm = 0x47,
	EACRG11Unorm = 0x48,
	EACRG11Snorm = 0x49,
	ASTC4x4Unorm = 0x4a,
	ASTC4x4UnormSrgb = 0x4b,
	ASTC5x4Unorm = 0x4c,
	ASTC5x4UnormSrgb = 0x4d,
	ASTC5x5Unorm = 0x4e,
	ASTC5x5UnormSrgb = 0x4f,
	ASTC6x5Unorm = 0x50,
	ASTC6x5UnormSrgb = 0x51,
	ASTC6x6Unorm = 0x52,
	ASTC6x6UnormSrgb = 0x53,
	ASTC8x5Unorm = 0x54,
	ASTC8x5UnormSrgb = 0x55,
	ASTC8x6Unorm = 0x56,
	ASTC8x6UnormSrgb = 0x57,
	ASTC8x8Unorm = 0x58,
	ASTC8x8UnormSrgb = 0x59,
	ASTC10x5Unorm = 0x5a,
	ASTC10x5UnormSrgb = 0x5b,
	ASTC10x6Unorm = 0x5c,
	ASTC10x6UnormSrgb = 0x5d,
	ASTC10x8Unorm = 0x5e,
	ASTC10x8UnormSrgb = 0x5f,
	ASTC10x10Unorm = 0x60,
	ASTC10x10UnormSrgb = 0x61,
	ASTC12x10Unorm = 0x62,
	ASTC12x10UnormSrgb = 0x63,
	ASTC12x12Unorm = 0x64,
	ASTC12x12UnormSrgb = 0x65,
	Force32 = 0x7fffffff,
}

enum TextureSampleType: u32 {
	BindingNotUsed = 0x0,
	Undefined = 0x1,
	Float = 0x2,
	UnfilterableFloat = 0x3,
	Depth = 0x4,
	Sint = 0x5,
	Uint = 0x6,
	Force32 = 0x7fffffff,
}

enum TextureViewDimension: u32 {
	Undefined = 0x0,
	_1D = 0x1,
	_2D = 0x2,
	_2DArray = 0x3,
	Cube = 0x4,
	CubeArray = 0x5,
	_3D = 0x6,
	Force32 = 0x7fffffff,
}

enum ToneMappingMode: u32 {
	Standard = 0x1,
	Extended = 0x2,
	Force32 = 0x7fffffff,
}

enum VertexFormat: u32 {
	Uint8 = 0x1,
	Uint8x2 = 0x2,
	Uint8x4 = 0x3,
	Sint8 = 0x4,
	Sint8x2 = 0x5,
	Sint8x4 = 0x6,
	Unorm8 = 0x7,
	Unorm8x2 = 0x8,
	Unorm8x4 = 0x9,
	Snorm8 = 0xa,
	Snorm8x2 = 0xb,
	Snorm8x4 = 0xc,
	Uint16 = 0xd,
	Uint16x2 = 0xe,
	Uint16x4 = 0xf,
	Sint16 = 0x10,
	Sint16x2 = 0x11,
	Sint16x4 = 0x12,
	Unorm16 = 0x13,
	Unorm16x2 = 0x14,
	Unorm16x4 = 0x15,
	Snorm16 = 0x16,
	Snorm16x2 = 0x17,
	Snorm16x4 = 0x18,
	Float16 = 0x19,
	Float16x2 = 0x1a,
	Float16x4 = 0x1b,
	Float32 = 0x1c,
	Float32x2 = 0x1d,
	Float32x3 = 0x1e,
	Float32x4 = 0x1f,
	Uint32 = 0x20,
	Uint32x2 = 0x21,
	Uint32x3 = 0x22,
	Uint32x4 = 0x23,
	Sint32 = 0x24,
	Sint32x2 = 0x25,
	Sint32x3 = 0x26,
	Sint32x4 = 0x27,
	Unorm10_10_10_2 = 0x28,
	Unorm8x4BGRA = 0x29,
	Force32 = 0x7fffffff,
}

enum VertexStepMode: u32 {
	Undefined = 0x0,
	Vertex = 0x1,
	Instance = 0x2,
	Force32 = 0x7fffffff,
}

enum WaitStatus: u32 {
	Success = 0x1,
	TimedOut = 0x2,
	Error = 0x3,
	Force32 = 0x7fffffff,
}

enum WGSLLanguageFeatureName: u32 {
	ReadonlyAndReadwriteStorageTextures = 0x1,
	Packed4x8IntegerDotProduct = 0x2,
	UnrestrictedPointerParameters = 0x3,
	PointerCompositeAccess = 0x4,
	Force32 = 0x7fffffff,
}

BufferUsage :: Flags;

ColorWriteMask :: Flags;

MapMode :: Flags;

ShaderStage :: Flags;

TextureUsage :: Flags;

Proc :: ?*fn() #foreign;

BufferMapCallback :: ?*fn(a: MapAsyncStatus, b: StringView, c: ?*, d: ?*) #foreign;

CompilationInfoCallback :: ?*fn(a: CompilationInfoRequestStatus, b: ?*CompilationInfo, c: ?*, d: ?*) #foreign;

CreateComputePipelineAsyncCallback :: ?*fn(a: CreatePipelineAsyncStatus, b: ComputePipeline, c: StringView, d: ?*, e: ?*) #foreign;

CreateRenderPipelineAsyncCallback :: ?*fn(a: CreatePipelineAsyncStatus, b: RenderPipeline, c: StringView, d: ?*, e: ?*) #foreign;

DeviceLostCallback :: ?*fn(a: ?*Device, b: DeviceLostReason, c: StringView, d: ?*, e: ?*) #foreign;

PopErrorScopeCallback :: ?*fn(a: PopErrorScopeStatus, b: ErrorType, c: StringView, d: ?*, e: ?*) #foreign;

QueueWorkDoneCallback :: ?*fn(a: QueueWorkDoneStatus, b: StringView, c: ?*, d: ?*) #foreign;

RequestAdapterCallback :: ?*fn(a: RequestAdapterStatus, b: Adapter, c: StringView, d: ?*, e: ?*) #foreign;

RequestDeviceCallback :: ?*fn(a: RequestDeviceStatus, b: Device, c: StringView, d: ?*, e: ?*) #foreign;

UncapturedErrorCallback :: ?*fn(a: ?*Device, b: ErrorType, c: StringView, d: ?*, e: ?*) #foreign;

struct ChainedStruct {
	next: ?*ChainedStruct,
	sType: SType,
}

struct BufferMapCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: BufferMapCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct CompilationInfoCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: CompilationInfoCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct CreateComputePipelineAsyncCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: CreateComputePipelineAsyncCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct CreateRenderPipelineAsyncCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: CreateRenderPipelineAsyncCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct DeviceLostCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: DeviceLostCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct PopErrorScopeCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: PopErrorScopeCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct QueueWorkDoneCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: QueueWorkDoneCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct RequestAdapterCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: RequestAdapterCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct RequestDeviceCallbackInfo {
	nextInChain: ?*ChainedStruct,
	mode: CallbackMode,
	callback: RequestDeviceCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct UncapturedErrorCallbackInfo {
	nextInChain: ?*ChainedStruct,
	callback: UncapturedErrorCallback,
	userdata1: ?*,
	userdata2: ?*,
}

struct AdapterInfo {
	nextInChain: ?*ChainedStruct,
	vendor: StringView,
	architecture: StringView,
	device: StringView,
	description: StringView,
	backendType: BackendType,
	adapterType: AdapterType,
	vendorID: u32,
	deviceID: u32,
	subgroupMinSize: u32,
	subgroupMaxSize: u32,
}

struct BindGroupEntry {
	nextInChain: ?*ChainedStruct,
	binding: u32,
	buffer: Buffer,
	offset: u64,
	size: u64,
	sampler: Sampler,
	textureView: TextureView,
}

struct BlendComponent {
	operation: BlendOperation,
	srcFactor: BlendFactor,
	dstFactor: BlendFactor,
}

struct BufferBindingLayout {
	nextInChain: ?*ChainedStruct,
	type: BufferBindingType,
	hasDynamicOffset: Bool,
	minBindingSize: u64,
}

struct BufferDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	usage: BufferUsage,
	size: u64,
	mappedAtCreation: Bool,
}

struct Color {
	r: f64,
	g: f64,
	b: f64,
	a: f64,
}

struct CommandBufferDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
}

struct CommandEncoderDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
}

struct CompilationMessage {
	nextInChain: ?*ChainedStruct,
	message: StringView,
	type: CompilationMessageType,
	lineNum: u64,
	linePos: u64,
	offset: u64,
	length: u64,
}

struct ConstantEntry {
	nextInChain: ?*ChainedStruct,
	key: StringView,
	value: f64,
}

struct Extent3D {
	width: u32,
	height: u32,
	depthOrArrayLayers: u32,
}

struct Future {
	id: u64,
}

struct InstanceLimits {
	nextInChain: ?*ChainedStruct,
	timedWaitAnyMaxCount: uint,
}

struct Limits {
	nextInChain: ?*ChainedStruct,
	maxTextureDimension1D: u32,
	maxTextureDimension2D: u32,
	maxTextureDimension3D: u32,
	maxTextureArrayLayers: u32,
	maxBindGroups: u32,
	maxBindGroupsPlusVertexBuffers: u32,
	maxBindingsPerBindGroup: u32,
	maxDynamicUniformBuffersPerPipelineLayout: u32,
	maxDynamicStorageBuffersPerPipelineLayout: u32,
	maxSampledTexturesPerShaderStage: u32,
	maxSamplersPerShaderStage: u32,
	maxStorageBuffersPerShaderStage: u32,
	maxStorageTexturesPerShaderStage: u32,
	maxUniformBuffersPerShaderStage: u32,
	maxUniformBufferBindingSize: u64,
	maxStorageBufferBindingSize: u64,
	minUniformBufferOffsetAlignment: u32,
	minStorageBufferOffsetAlignment: u32,
	maxVertexBuffers: u32,
	maxBufferSize: u64,
	maxVertexAttributes: u32,
	maxVertexBufferArrayStride: u32,
	maxInterStageShaderVariables: u32,
	maxColorAttachments: u32,
	maxColorAttachmentBytesPerSample: u32,
	maxComputeWorkgroupStorageSize: u32,
	maxComputeInvocationsPerWorkgroup: u32,
	maxComputeWorkgroupSizeX: u32,
	maxComputeWorkgroupSizeY: u32,
	maxComputeWorkgroupSizeZ: u32,
	maxComputeWorkgroupsPerDimension: u32,
	maxImmediateSize: u32,
}

struct MultisampleState {
	nextInChain: ?*ChainedStruct,
	count: u32,
	mask: u32,
	alphaToCoverageEnabled: Bool,
}

struct Origin3D {
	x: u32,
	y: u32,
	z: u32,
}

struct PassTimestampWrites {
	nextInChain: ?*ChainedStruct,
	querySet: QuerySet,
	beginningOfPassWriteIndex: u32,
	endOfPassWriteIndex: u32,
}

struct PipelineLayoutDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	bindGroupLayoutCount: uint,
	bindGroupLayouts: ?*BindGroupLayout,
	immediateSize: u32,
}

struct PrimitiveState {
	nextInChain: ?*ChainedStruct,
	topology: PrimitiveTopology,
	stripIndexFormat: IndexFormat,
	frontFace: FrontFace,
	cullMode: CullMode,
	unclippedDepth: Bool,
}

struct QuerySetDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	type: QueryType,
	count: u32,
}

struct QueueDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
}

struct RenderBundleDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
}

struct RenderBundleEncoderDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	colorFormatCount: uint,
	colorFormats: ?*TextureFormat,
	depthStencilFormat: TextureFormat,
	sampleCount: u32,
	depthReadOnly: Bool,
	stencilReadOnly: Bool,
}

struct RenderPassDepthStencilAttachment {
	nextInChain: ?*ChainedStruct,
	view: TextureView,
	depthLoadOp: LoadOp,
	depthStoreOp: StoreOp,
	depthClearValue: f32,
	depthReadOnly: Bool,
	stencilLoadOp: LoadOp,
	stencilStoreOp: StoreOp,
	stencilClearValue: u32,
	stencilReadOnly: Bool,
}

struct RenderPassMaxDrawCount {
	chain: ChainedStruct,
	maxDrawCount: u64,
}

struct RequestAdapterWebXROptions {
	chain: ChainedStruct,
	xrCompatible: Bool,
}

struct SamplerBindingLayout {
	nextInChain: ?*ChainedStruct,
	type: SamplerBindingType,
}

struct SamplerDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	addressModeU: AddressMode,
	addressModeV: AddressMode,
	addressModeW: AddressMode,
	magFilter: FilterMode,
	minFilter: FilterMode,
	mipmapFilter: MipmapFilterMode,
	lodMinClamp: f32,
	lodMaxClamp: f32,
	compare: CompareFunction,
	maxAnisotropy: u16,
}

struct ShaderSourceSPIRV {
	chain: ChainedStruct,
	codeSize: u32,
	code: ?*u32,
}

struct ShaderSourceWGSL {
	chain: ChainedStruct,
	code: StringView,
}

struct StencilFaceState {
	compare: CompareFunction,
	failOp: StencilOperation,
	depthFailOp: StencilOperation,
	passOp: StencilOperation,
}

struct StorageTextureBindingLayout {
	nextInChain: ?*ChainedStruct,
	access: StorageTextureAccess,
	format: TextureFormat,
	viewDimension: TextureViewDimension,
}

struct SupportedFeatures {
	featureCount: uint,
	features: ?*FeatureName,
}

struct SupportedInstanceFeatures {
	featureCount: uint,
	features: ?*InstanceFeatureName,
}

struct SupportedWGSLLanguageFeatures {
	featureCount: uint,
	features: ?*WGSLLanguageFeatureName,
}

struct SurfaceCapabilities {
	nextInChain: ?*ChainedStruct,
	usages: TextureUsage,
	formatCount: uint,
	formats: ?*TextureFormat,
	presentModeCount: uint,
	presentModes: ?*PresentMode,
	alphaModeCount: uint,
	alphaModes: ?*CompositeAlphaMode,
}

struct SurfaceColorManagement {
	chain: ChainedStruct,
	colorSpace: PredefinedColorSpace,
	toneMappingMode: ToneMappingMode,
}

struct SurfaceConfiguration {
	nextInChain: ?*ChainedStruct,
	device: Device,
	format: TextureFormat,
	usage: TextureUsage,
	width: u32,
	height: u32,
	viewFormatCount: uint,
	viewFormats: ?*TextureFormat,
	alphaMode: CompositeAlphaMode,
	presentMode: PresentMode,
}

struct SurfaceSourceAndroidNativeWindow {
	chain: ChainedStruct,
	window: ?*,
}

struct SurfaceSourceMetalLayer {
	chain: ChainedStruct,
	layer: ?*,
}

struct SurfaceSourceWaylandSurface {
	chain: ChainedStruct,
	display: ?*,
	surface: ?*,
}

struct SurfaceSourceWindowsHWND {
	chain: ChainedStruct,
	hinstance: ?*,
	hwnd: ?*,
}

struct SurfaceSourceXCBWindow {
	chain: ChainedStruct,
	connection: ?*,
	window: u32,
}

struct SurfaceSourceXlibWindow {
	chain: ChainedStruct,
	display: ?*,
	window: u64,
}

struct SurfaceTexture {
	nextInChain: ?*ChainedStruct,
	texture: Texture,
	status: SurfaceGetCurrentTextureStatus,
}

struct TexelCopyBufferLayout {
	offset: u64,
	bytesPerRow: u32,
	rowsPerImage: u32,
}

struct TextureBindingLayout {
	nextInChain: ?*ChainedStruct,
	sampleType: TextureSampleType,
	viewDimension: TextureViewDimension,
	multisampled: Bool,
}

struct TextureViewDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	format: TextureFormat,
	dimension: TextureViewDimension,
	baseMipLevel: u32,
	mipLevelCount: u32,
	baseArrayLayer: u32,
	arrayLayerCount: u32,
	aspect: TextureAspect,
	usage: TextureUsage,
}

struct VertexAttribute {
	nextInChain: ?*ChainedStruct,
	format: VertexFormat,
	offset: u64,
	shaderLocation: u32,
}

struct BindGroupDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	layout: BindGroupLayout,
	entryCount: uint,
	entries: ?*BindGroupEntry,
}

struct BindGroupLayoutEntry {
	nextInChain: ?*ChainedStruct,
	binding: u32,
	visibility: ShaderStage,
	bindingArraySize: u32,
	buffer: BufferBindingLayout,
	sampler: SamplerBindingLayout,
	texture: TextureBindingLayout,
	storageTexture: StorageTextureBindingLayout,
}

struct BlendState {
	color: BlendComponent,
	alpha: BlendComponent,
}

struct CompilationInfo {
	nextInChain: ?*ChainedStruct,
	messageCount: uint,
	messages: ?*CompilationMessage,
}

struct ComputePassDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	timestampWrites: ?*PassTimestampWrites,
}

struct ComputeState {
	nextInChain: ?*ChainedStruct,
	module_: ShaderModule,
	entryPoint: StringView,
	constantCount: uint,
	constants: ?*ConstantEntry,
}

struct DepthStencilState {
	nextInChain: ?*ChainedStruct,
	format: TextureFormat,
	depthWriteEnabled: OptionalBool,
	depthCompare: CompareFunction,
	stencilFront: StencilFaceState,
	stencilBack: StencilFaceState,
	stencilReadMask: u32,
	stencilWriteMask: u32,
	depthBias: i32,
	depthBiasSlopeScale: f32,
	depthBiasClamp: f32,
}

struct DeviceDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	requiredFeatureCount: uint,
	requiredFeatures: ?*FeatureName,
	requiredLimits: ?*Limits,
	defaultQueue: QueueDescriptor,
	deviceLostCallbackInfo: DeviceLostCallbackInfo,
	uncapturedErrorCallbackInfo: UncapturedErrorCallbackInfo,
}

struct FutureWaitInfo {
	future: Future,
	completed: Bool,
}

struct InstanceDescriptor {
	nextInChain: ?*ChainedStruct,
	requiredFeatureCount: uint,
	requiredFeatures: ?*InstanceFeatureName,
	requiredLimits: ?*InstanceLimits,
}

struct RenderPassColorAttachment {
	nextInChain: ?*ChainedStruct,
	view: TextureView,
	depthSlice: u32,
	resolveTarget: TextureView,
	loadOp: LoadOp,
	storeOp: StoreOp,
	clearValue: Color,
}

struct RequestAdapterOptions {
	nextInChain: ?*ChainedStruct,
	featureLevel: FeatureLevel,
	powerPreference: PowerPreference,
	forceFallbackAdapter: Bool,
	backendType: BackendType,
	compatibleSurface: Surface,
}

struct ShaderModuleDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
}

struct SurfaceDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
}

struct TexelCopyBufferInfo {
	layout: TexelCopyBufferLayout,
	buffer: Buffer,
}

struct TexelCopyTextureInfo {
	texture: Texture,
	mipLevel: u32,
	origin: Origin3D,
	aspect: TextureAspect,
}

struct TextureDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	usage: TextureUsage,
	dimension: TextureDimension,
	size: Extent3D,
	format: TextureFormat,
	mipLevelCount: u32,
	sampleCount: u32,
	viewFormatCount: uint,
	viewFormats: ?*TextureFormat,
}

struct VertexBufferLayout {
	nextInChain: ?*ChainedStruct,
	stepMode: VertexStepMode,
	arrayStride: u64,
	attributeCount: uint,
	attributes: ?*VertexAttribute,
}

struct BindGroupLayoutDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	entryCount: uint,
	entries: ?*BindGroupLayoutEntry,
}

struct ColorTargetState {
	nextInChain: ?*ChainedStruct,
	format: TextureFormat,
	blend: ?*BlendState,
	writeMask: ColorWriteMask,
}

struct ComputePipelineDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	layout: PipelineLayout,
	compute: ComputeState,
}

struct RenderPassDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	colorAttachmentCount: uint,
	colorAttachments: ?*RenderPassColorAttachment,
	depthStencilAttachment: ?*RenderPassDepthStencilAttachment,
	occlusionQuerySet: QuerySet,
	timestampWrites: ?*PassTimestampWrites,
}

struct VertexState {
	nextInChain: ?*ChainedStruct,
	module_: ShaderModule,
	entryPoint: StringView,
	constantCount: uint,
	constants: ?*ConstantEntry,
	bufferCount: uint,
	buffers: ?*VertexBufferLayout,
}

struct FragmentState {
	nextInChain: ?*ChainedStruct,
	module_: ShaderModule,
	entryPoint: StringView,
	constantCount: uint,
	constants: ?*ConstantEntry,
	targetCount: uint,
	targets: ?*ColorTargetState,
}

struct RenderPipelineDescriptor {
	nextInChain: ?*ChainedStruct,
	label: StringView,
	layout: PipelineLayout,
	vertex: VertexState,
	primitive: PrimitiveState,
	depthStencil: ?*DepthStencilState,
	multisample: MultisampleState,
	fragment: ?*FragmentState,
}

ProcCreateInstance :: ?*fn(a: ?*InstanceDescriptor) -> Instance #foreign;

ProcGetInstanceFeatures :: ?*fn(a: ?*SupportedInstanceFeatures) #foreign;

ProcGetInstanceLimits :: ?*fn(a: ?*InstanceLimits) -> Status #foreign;

ProcHasInstanceFeature :: ?*fn(a: InstanceFeatureName) -> Bool #foreign;

ProcGetProcAddress :: ?*fn(a: StringView) -> Proc #foreign;

ProcAdapterGetFeatures :: ?*fn(a: Adapter, b: ?*SupportedFeatures) #foreign;

ProcAdapterGetInfo :: ?*fn(a: Adapter, b: ?*AdapterInfo) -> Status #foreign;

ProcAdapterGetLimits :: ?*fn(a: Adapter, b: ?*Limits) -> Status #foreign;

ProcAdapterHasFeature :: ?*fn(a: Adapter, b: FeatureName) -> Bool #foreign;

ProcAdapterRequestDevice :: ?*fn(a: Adapter, b: ?*DeviceDescriptor, c: RequestDeviceCallbackInfo) -> Future #foreign;

ProcAdapterAddRef :: ?*fn(a: Adapter) #foreign;

ProcAdapterRelease :: ?*fn(a: Adapter) #foreign;

ProcAdapterInfoFreeMembers :: ?*fn(a: AdapterInfo) #foreign;

ProcBindGroupSetLabel :: ?*fn(a: BindGroup, b: StringView) #foreign;

ProcBindGroupAddRef :: ?*fn(a: BindGroup) #foreign;

ProcBindGroupRelease :: ?*fn(a: BindGroup) #foreign;

ProcBindGroupLayoutSetLabel :: ?*fn(a: BindGroupLayout, b: StringView) #foreign;

ProcBindGroupLayoutAddRef :: ?*fn(a: BindGroupLayout) #foreign;

ProcBindGroupLayoutRelease :: ?*fn(a: BindGroupLayout) #foreign;

ProcBufferDestroy :: ?*fn(a: Buffer) #foreign;

ProcBufferGetConstMappedRange :: ?*fn(a: Buffer, b: uint, c: uint) -> ?* #foreign;

ProcBufferGetMappedRange :: ?*fn(a: Buffer, b: uint, c: uint) -> ?* #foreign;

ProcBufferGetMapState :: ?*fn(a: Buffer) -> BufferMapState #foreign;

ProcBufferGetSize :: ?*fn(a: Buffer) -> u64 #foreign;

ProcBufferGetUsage :: ?*fn(a: Buffer) -> BufferUsage #foreign;

ProcBufferMapAsync :: ?*fn(a: Buffer, b: MapMode, c: uint, d: uint, e: BufferMapCallbackInfo) -> Future #foreign;

ProcBufferReadMappedRange :: ?*fn(a: Buffer, b: uint, c: ?*, d: uint) -> Status #foreign;

ProcBufferSetLabel :: ?*fn(a: Buffer, b: StringView) #foreign;

ProcBufferUnmap :: ?*fn(a: Buffer) #foreign;

ProcBufferWriteMappedRange :: ?*fn(a: Buffer, b: uint, c: ?*, d: uint) -> Status #foreign;

ProcBufferAddRef :: ?*fn(a: Buffer) #foreign;

ProcBufferRelease :: ?*fn(a: Buffer) #foreign;

ProcCommandBufferSetLabel :: ?*fn(a: CommandBuffer, b: StringView) #foreign;

ProcCommandBufferAddRef :: ?*fn(a: CommandBuffer) #foreign;

ProcCommandBufferRelease :: ?*fn(a: CommandBuffer) #foreign;

ProcCommandEncoderBeginComputePass :: ?*fn(a: CommandEncoder, b: ?*ComputePassDescriptor) -> ComputePassEncoder #foreign;

ProcCommandEncoderBeginRenderPass :: ?*fn(a: CommandEncoder, b: ?*RenderPassDescriptor) -> RenderPassEncoder #foreign;

ProcCommandEncoderClearBuffer :: ?*fn(a: CommandEncoder, b: Buffer, c: u64, d: u64) #foreign;

ProcCommandEncoderCopyBufferToBuffer :: ?*fn(a: CommandEncoder, b: Buffer, c: u64, d: Buffer, e: u64, f: u64) #foreign;

ProcCommandEncoderCopyBufferToTexture :: ?*fn(a: CommandEncoder, b: ?*TexelCopyBufferInfo, c: ?*TexelCopyTextureInfo, d: ?*Extent3D) #foreign;

ProcCommandEncoderCopyTextureToBuffer :: ?*fn(a: CommandEncoder, b: ?*TexelCopyTextureInfo, c: ?*TexelCopyBufferInfo, d: ?*Extent3D) #foreign;

ProcCommandEncoderCopyTextureToTexture :: ?*fn(a: CommandEncoder, b: ?*TexelCopyTextureInfo, c: ?*TexelCopyTextureInfo, d: ?*Extent3D) #foreign;

ProcCommandEncoderFinish :: ?*fn(a: CommandEncoder, b: ?*CommandBufferDescriptor) -> CommandBuffer #foreign;

ProcCommandEncoderInsertDebugMarker :: ?*fn(a: CommandEncoder, b: StringView) #foreign;

ProcCommandEncoderPopDebugGroup :: ?*fn(a: CommandEncoder) #foreign;

ProcCommandEncoderPushDebugGroup :: ?*fn(a: CommandEncoder, b: StringView) #foreign;

ProcCommandEncoderResolveQuerySet :: ?*fn(a: CommandEncoder, b: QuerySet, c: u32, d: u32, e: Buffer, f: u64) #foreign;

ProcCommandEncoderSetLabel :: ?*fn(a: CommandEncoder, b: StringView) #foreign;

ProcCommandEncoderWriteTimestamp :: ?*fn(a: CommandEncoder, b: QuerySet, c: u32) #foreign;

ProcCommandEncoderAddRef :: ?*fn(a: CommandEncoder) #foreign;

ProcCommandEncoderRelease :: ?*fn(a: CommandEncoder) #foreign;

ProcComputePassEncoderDispatchWorkgroups :: ?*fn(a: ComputePassEncoder, b: u32, c: u32, d: u32) #foreign;

ProcComputePassEncoderDispatchWorkgroupsIndirect :: ?*fn(a: ComputePassEncoder, b: Buffer, c: u64) #foreign;

ProcComputePassEncoderEnd :: ?*fn(a: ComputePassEncoder) #foreign;

ProcComputePassEncoderInsertDebugMarker :: ?*fn(a: ComputePassEncoder, b: StringView) #foreign;

ProcComputePassEncoderPopDebugGroup :: ?*fn(a: ComputePassEncoder) #foreign;

ProcComputePassEncoderPushDebugGroup :: ?*fn(a: ComputePassEncoder, b: StringView) #foreign;

ProcComputePassEncoderSetBindGroup :: ?*fn(a: ComputePassEncoder, b: u32, c: BindGroup, d: uint, e: ?*u32) #foreign;

ProcComputePassEncoderSetLabel :: ?*fn(a: ComputePassEncoder, b: StringView) #foreign;

ProcComputePassEncoderSetPipeline :: ?*fn(a: ComputePassEncoder, b: ComputePipeline) #foreign;

ProcComputePassEncoderAddRef :: ?*fn(a: ComputePassEncoder) #foreign;

ProcComputePassEncoderRelease :: ?*fn(a: ComputePassEncoder) #foreign;

ProcComputePipelineGetBindGroupLayout :: ?*fn(a: ComputePipeline, b: u32) -> BindGroupLayout #foreign;

ProcComputePipelineSetLabel :: ?*fn(a: ComputePipeline, b: StringView) #foreign;

ProcComputePipelineAddRef :: ?*fn(a: ComputePipeline) #foreign;

ProcComputePipelineRelease :: ?*fn(a: ComputePipeline) #foreign;

ProcDeviceCreateBindGroup :: ?*fn(a: Device, b: ?*BindGroupDescriptor) -> BindGroup #foreign;

ProcDeviceCreateBindGroupLayout :: ?*fn(a: Device, b: ?*BindGroupLayoutDescriptor) -> BindGroupLayout #foreign;

ProcDeviceCreateBuffer :: ?*fn(a: Device, b: ?*BufferDescriptor) -> Buffer #foreign;

ProcDeviceCreateCommandEncoder :: ?*fn(a: Device, b: ?*CommandEncoderDescriptor) -> CommandEncoder #foreign;

ProcDeviceCreateComputePipeline :: ?*fn(a: Device, b: ?*ComputePipelineDescriptor) -> ComputePipeline #foreign;

ProcDeviceCreateComputePipelineAsync :: ?*fn(a: Device, b: ?*ComputePipelineDescriptor, c: CreateComputePipelineAsyncCallbackInfo) -> Future #foreign;

ProcDeviceCreatePipelineLayout :: ?*fn(a: Device, b: ?*PipelineLayoutDescriptor) -> PipelineLayout #foreign;

ProcDeviceCreateQuerySet :: ?*fn(a: Device, b: ?*QuerySetDescriptor) -> QuerySet #foreign;

ProcDeviceCreateRenderBundleEncoder :: ?*fn(a: Device, b: ?*RenderBundleEncoderDescriptor) -> RenderBundleEncoder #foreign;

ProcDeviceCreateRenderPipeline :: ?*fn(a: Device, b: ?*RenderPipelineDescriptor) -> RenderPipeline #foreign;

ProcDeviceCreateRenderPipelineAsync :: ?*fn(a: Device, b: ?*RenderPipelineDescriptor, c: CreateRenderPipelineAsyncCallbackInfo) -> Future #foreign;

ProcDeviceCreateSampler :: ?*fn(a: Device, b: ?*SamplerDescriptor) -> Sampler #foreign;

ProcDeviceCreateShaderModule :: ?*fn(a: Device, b: ?*ShaderModuleDescriptor) -> ShaderModule #foreign;

ProcDeviceCreateTexture :: ?*fn(a: Device, b: ?*TextureDescriptor) -> Texture #foreign;

ProcDeviceDestroy :: ?*fn(a: Device) #foreign;

ProcDeviceGetAdapterInfo :: ?*fn(a: Device, b: ?*AdapterInfo) -> Status #foreign;

ProcDeviceGetFeatures :: ?*fn(a: Device, b: ?*SupportedFeatures) #foreign;

ProcDeviceGetLimits :: ?*fn(a: Device, b: ?*Limits) -> Status #foreign;

ProcDeviceGetLostFuture :: ?*fn(a: Device) -> Future #foreign;

ProcDeviceGetQueue :: ?*fn(a: Device) -> Queue #foreign;

ProcDeviceHasFeature :: ?*fn(a: Device, b: FeatureName) -> Bool #foreign;

ProcDevicePopErrorScope :: ?*fn(a: Device, b: PopErrorScopeCallbackInfo) -> Future #foreign;

ProcDevicePushErrorScope :: ?*fn(a: Device, b: ErrorFilter) #foreign;

ProcDeviceSetLabel :: ?*fn(a: Device, b: StringView) #foreign;

ProcDeviceAddRef :: ?*fn(a: Device) #foreign;

ProcDeviceRelease :: ?*fn(a: Device) #foreign;

ProcInstanceCreateSurface :: ?*fn(a: Instance, b: ?*SurfaceDescriptor) -> Surface #foreign;

ProcInstanceGetWGSLLanguageFeatures :: ?*fn(a: Instance, b: ?*SupportedWGSLLanguageFeatures) #foreign;

ProcInstanceHasWGSLLanguageFeature :: ?*fn(a: Instance, b: WGSLLanguageFeatureName) -> Bool #foreign;

ProcInstanceProcessEvents :: ?*fn(a: Instance) #foreign;

ProcInstanceRequestAdapter :: ?*fn(a: Instance, b: ?*RequestAdapterOptions, c: RequestAdapterCallbackInfo) -> Future #foreign;

ProcInstanceWaitAny :: ?*fn(a: Instance, b: uint, c: ?*FutureWaitInfo, d: u64) -> WaitStatus #foreign;

ProcInstanceAddRef :: ?*fn(a: Instance) #foreign;

ProcInstanceRelease :: ?*fn(a: Instance) #foreign;

ProcPipelineLayoutSetLabel :: ?*fn(a: PipelineLayout, b: StringView) #foreign;

ProcPipelineLayoutAddRef :: ?*fn(a: PipelineLayout) #foreign;

ProcPipelineLayoutRelease :: ?*fn(a: PipelineLayout) #foreign;

ProcQuerySetDestroy :: ?*fn(a: QuerySet) #foreign;

ProcQuerySetGetCount :: ?*fn(a: QuerySet) -> u32 #foreign;

ProcQuerySetGetType :: ?*fn(a: QuerySet) -> QueryType #foreign;

ProcQuerySetSetLabel :: ?*fn(a: QuerySet, b: StringView) #foreign;

ProcQuerySetAddRef :: ?*fn(a: QuerySet) #foreign;

ProcQuerySetRelease :: ?*fn(a: QuerySet) #foreign;

ProcQueueOnSubmittedWorkDone :: ?*fn(a: Queue, b: QueueWorkDoneCallbackInfo) -> Future #foreign;

ProcQueueSetLabel :: ?*fn(a: Queue, b: StringView) #foreign;

ProcQueueSubmit :: ?*fn(a: Queue, b: uint, c: ?*CommandBuffer) #foreign;

ProcQueueWriteBuffer :: ?*fn(a: Queue, b: Buffer, c: u64, d: ?*, e: uint) #foreign;

ProcQueueWriteTexture :: ?*fn(a: Queue, b: ?*TexelCopyTextureInfo, c: ?*, d: uint, e: ?*TexelCopyBufferLayout, f: ?*Extent3D) #foreign;

ProcQueueAddRef :: ?*fn(a: Queue) #foreign;

ProcQueueRelease :: ?*fn(a: Queue) #foreign;

ProcRenderBundleSetLabel :: ?*fn(a: RenderBundle, b: StringView) #foreign;

ProcRenderBundleAddRef :: ?*fn(a: RenderBundle) #foreign;

ProcRenderBundleRelease :: ?*fn(a: RenderBundle) #foreign;

ProcRenderBundleEncoderDraw :: ?*fn(a: RenderBundleEncoder, b: u32, c: u32, d: u32, e: u32) #foreign;

ProcRenderBundleEncoderDrawIndexed :: ?*fn(a: RenderBundleEncoder, b: u32, c: u32, d: u32, e: i32, f: u32) #foreign;

ProcRenderBundleEncoderDrawIndexedIndirect :: ?*fn(a: RenderBundleEncoder, b: Buffer, c: u64) #foreign;

ProcRenderBundleEncoderDrawIndirect :: ?*fn(a: RenderBundleEncoder, b: Buffer, c: u64) #foreign;

ProcRenderBundleEncoderFinish :: ?*fn(a: RenderBundleEncoder, b: ?*RenderBundleDescriptor) -> RenderBundle #foreign;

ProcRenderBundleEncoderInsertDebugMarker :: ?*fn(a: RenderBundleEncoder, b: StringView) #foreign;

ProcRenderBundleEncoderPopDebugGroup :: ?*fn(a: RenderBundleEncoder) #foreign;

ProcRenderBundleEncoderPushDebugGroup :: ?*fn(a: RenderBundleEncoder, b: StringView) #foreign;

ProcRenderBundleEncoderSetBindGroup :: ?*fn(a: RenderBundleEncoder, b: u32, c: BindGroup, d: uint, e: ?*u32) #foreign;

ProcRenderBundleEncoderSetIndexBuffer :: ?*fn(a: RenderBundleEncoder, b: Buffer, c: IndexFormat, d: u64, e: u64) #foreign;

ProcRenderBundleEncoderSetLabel :: ?*fn(a: RenderBundleEncoder, b: StringView) #foreign;

ProcRenderBundleEncoderSetPipeline :: ?*fn(a: RenderBundleEncoder, b: RenderPipeline) #foreign;

ProcRenderBundleEncoderSetVertexBuffer :: ?*fn(a: RenderBundleEncoder, b: u32, c: Buffer, d: u64, e: u64) #foreign;

ProcRenderBundleEncoderAddRef :: ?*fn(a: RenderBundleEncoder) #foreign;

ProcRenderBundleEncoderRelease :: ?*fn(a: RenderBundleEncoder) #foreign;

ProcRenderPassEncoderBeginOcclusionQuery :: ?*fn(a: RenderPassEncoder, b: u32) #foreign;

ProcRenderPassEncoderDraw :: ?*fn(a: RenderPassEncoder, b: u32, c: u32, d: u32, e: u32) #foreign;

ProcRenderPassEncoderDrawIndexed :: ?*fn(a: RenderPassEncoder, b: u32, c: u32, d: u32, e: i32, f: u32) #foreign;

ProcRenderPassEncoderDrawIndexedIndirect :: ?*fn(a: RenderPassEncoder, b: Buffer, c: u64) #foreign;

ProcRenderPassEncoderDrawIndirect :: ?*fn(a: RenderPassEncoder, b: Buffer, c: u64) #foreign;

ProcRenderPassEncoderEnd :: ?*fn(a: RenderPassEncoder) #foreign;

ProcRenderPassEncoderEndOcclusionQuery :: ?*fn(a: RenderPassEncoder) #foreign;

ProcRenderPassEncoderExecuteBundles :: ?*fn(a: RenderPassEncoder, b: uint, c: ?*RenderBundle) #foreign;

ProcRenderPassEncoderInsertDebugMarker :: ?*fn(a: RenderPassEncoder, b: StringView) #foreign;

ProcRenderPassEncoderPopDebugGroup :: ?*fn(a: RenderPassEncoder) #foreign;

ProcRenderPassEncoderPushDebugGroup :: ?*fn(a: RenderPassEncoder, b: StringView) #foreign;

ProcRenderPassEncoderSetBindGroup :: ?*fn(a: RenderPassEncoder, b: u32, c: BindGroup, d: uint, e: ?*u32) #foreign;

ProcRenderPassEncoderSetBlendConstant :: ?*fn(a: RenderPassEncoder, b: ?*Color) #foreign;

ProcRenderPassEncoderSetIndexBuffer :: ?*fn(a: RenderPassEncoder, b: Buffer, c: IndexFormat, d: u64, e: u64) #foreign;

ProcRenderPassEncoderSetLabel :: ?*fn(a: RenderPassEncoder, b: StringView) #foreign;

ProcRenderPassEncoderSetPipeline :: ?*fn(a: RenderPassEncoder, b: RenderPipeline) #foreign;

ProcRenderPassEncoderSetScissorRect :: ?*fn(a: RenderPassEncoder, b: u32, c: u32, d: u32, e: u32) #foreign;

ProcRenderPassEncoderSetStencilReference :: ?*fn(a: RenderPassEncoder, b: u32) #foreign;

ProcRenderPassEncoderSetVertexBuffer :: ?*fn(a: RenderPassEncoder, b: u32, c: Buffer, d: u64, e: u64) #foreign;

ProcRenderPassEncoderSetViewport :: ?*fn(a: RenderPassEncoder, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32) #foreign;

ProcRenderPassEncoderAddRef :: ?*fn(a: RenderPassEncoder) #foreign;

ProcRenderPassEncoderRelease :: ?*fn(a: RenderPassEncoder) #foreign;

ProcRenderPipelineGetBindGroupLayout :: ?*fn(a: RenderPipeline, b: u32) -> BindGroupLayout #foreign;

ProcRenderPipelineSetLabel :: ?*fn(a: RenderPipeline, b: StringView) #foreign;

ProcRenderPipelineAddRef :: ?*fn(a: RenderPipeline) #foreign;

ProcRenderPipelineRelease :: ?*fn(a: RenderPipeline) #foreign;

ProcSamplerSetLabel :: ?*fn(a: Sampler, b: StringView) #foreign;

ProcSamplerAddRef :: ?*fn(a: Sampler) #foreign;

ProcSamplerRelease :: ?*fn(a: Sampler) #foreign;

ProcShaderModuleGetCompilationInfo :: ?*fn(a: ShaderModule, b: CompilationInfoCallbackInfo) -> Future #foreign;

ProcShaderModuleSetLabel :: ?*fn(a: ShaderModule, b: StringView) #foreign;

ProcShaderModuleAddRef :: ?*fn(a: ShaderModule) #foreign;

ProcShaderModuleRelease :: ?*fn(a: ShaderModule) #foreign;

ProcSupportedFeaturesFreeMembers :: ?*fn(a: SupportedFeatures) #foreign;

ProcSupportedInstanceFeaturesFreeMembers :: ?*fn(a: SupportedInstanceFeatures) #foreign;

ProcSupportedWGSLLanguageFeaturesFreeMembers :: ?*fn(a: SupportedWGSLLanguageFeatures) #foreign;

ProcSurfaceConfigure :: ?*fn(a: Surface, b: ?*SurfaceConfiguration) #foreign;

ProcSurfaceGetCapabilities :: ?*fn(a: Surface, b: Adapter, c: ?*SurfaceCapabilities) -> Status #foreign;

ProcSurfaceGetCurrentTexture :: ?*fn(a: Surface, b: ?*SurfaceTexture) #foreign;

ProcSurfacePresent :: ?*fn(a: Surface) -> Status #foreign;

ProcSurfaceSetLabel :: ?*fn(a: Surface, b: StringView) #foreign;

ProcSurfaceUnconfigure :: ?*fn(a: Surface) #foreign;

ProcSurfaceAddRef :: ?*fn(a: Surface) #foreign;

ProcSurfaceRelease :: ?*fn(a: Surface) #foreign;

ProcSurfaceCapabilitiesFreeMembers :: ?*fn(a: SurfaceCapabilities) #foreign;

ProcTextureCreateView :: ?*fn(a: Texture, b: ?*TextureViewDescriptor) -> TextureView #foreign;

ProcTextureDestroy :: ?*fn(a: Texture) #foreign;

ProcTextureGetDepthOrArrayLayers :: ?*fn(a: Texture) -> u32 #foreign;

ProcTextureGetDimension :: ?*fn(a: Texture) -> TextureDimension #foreign;

ProcTextureGetFormat :: ?*fn(a: Texture) -> TextureFormat #foreign;

ProcTextureGetHeight :: ?*fn(a: Texture) -> u32 #foreign;

ProcTextureGetMipLevelCount :: ?*fn(a: Texture) -> u32 #foreign;

ProcTextureGetSampleCount :: ?*fn(a: Texture) -> u32 #foreign;

ProcTextureGetUsage :: ?*fn(a: Texture) -> TextureUsage #foreign;

ProcTextureGetWidth :: ?*fn(a: Texture) -> u32 #foreign;

ProcTextureSetLabel :: ?*fn(a: Texture, b: StringView) #foreign;

ProcTextureAddRef :: ?*fn(a: Texture) #foreign;

ProcTextureRelease :: ?*fn(a: Texture) #foreign;

ProcTextureViewSetLabel :: ?*fn(a: TextureView, b: StringView) #foreign;

ProcTextureViewAddRef :: ?*fn(a: TextureView) #foreign;

ProcTextureViewRelease :: ?*fn(a: TextureView) #foreign;

CreateInstance :: fn(
	descriptor: ?*InstanceDescriptor
) -> Instance #foreign #link="wgpuCreateInstance";

GetInstanceFeatures :: fn(
	features: ?*SupportedInstanceFeatures
) #foreign #link="wgpuGetInstanceFeatures";

GetInstanceLimits :: fn(
	limits: ?*InstanceLimits
) -> Status #foreign #link="wgpuGetInstanceLimits";

HasInstanceFeature :: fn(
	feature: InstanceFeatureName
) -> Bool #foreign #link="wgpuHasInstanceFeature";

GetProcAddress :: fn(
	procName: StringView
) -> Proc #foreign #link="wgpuGetProcAddress";

AdapterGetFeatures :: fn(
	adapter: Adapter,
	features: ?*SupportedFeatures
) #foreign #link="wgpuAdapterGetFeatures";

AdapterGetInfo :: fn(
	adapter: Adapter,
	info: ?*AdapterInfo
) -> Status #foreign #link="wgpuAdapterGetInfo";

AdapterGetLimits :: fn(
	adapter: Adapter,
	limits: ?*Limits
) -> Status #foreign #link="wgpuAdapterGetLimits";

AdapterHasFeature :: fn(
	adapter: Adapter,
	feature: FeatureName
) -> Bool #foreign #link="wgpuAdapterHasFeature";

AdapterRequestDevice :: fn(
	adapter: Adapter,
	descriptor: ?*DeviceDescriptor,
	callbackInfo: RequestDeviceCallbackInfo
) -> Future #foreign #link="wgpuAdapterRequestDevice";

AdapterAddRef :: fn(
	adapter: Adapter
) #foreign #link="wgpuAdapterAddRef";

AdapterRelease :: fn(
	adapter: Adapter
) #foreign #link="wgpuAdapterRelease";

AdapterInfoFreeMembers :: fn(
	adapterInfo: AdapterInfo
) #foreign #link="wgpuAdapterInfoFreeMembers";

BindGroupSetLabel :: fn(
	bindGroup: BindGroup,
	label: StringView
) #foreign #link="wgpuBindGroupSetLabel";

BindGroupAddRef :: fn(
	bindGroup: BindGroup
) #foreign #link="wgpuBindGroupAddRef";

BindGroupRelease :: fn(
	bindGroup: BindGroup
) #foreign #link="wgpuBindGroupRelease";

BindGroupLayoutSetLabel :: fn(
	bindGroupLayout: BindGroupLayout,
	label: StringView
) #foreign #link="wgpuBindGroupLayoutSetLabel";

BindGroupLayoutAddRef :: fn(
	bindGroupLayout: BindGroupLayout
) #foreign #link="wgpuBindGroupLayoutAddRef";

BindGroupLayoutRelease :: fn(
	bindGroupLayout: BindGroupLayout
) #foreign #link="wgpuBindGroupLayoutRelease";

BufferDestroy :: fn(
	buffer: Buffer
) #foreign #link="wgpuBufferDestroy";

BufferGetConstMappedRange :: fn(
	buffer: Buffer,
	offset: uint,
	size: uint
) -> ?* #foreign #link="wgpuBufferGetConstMappedRange";

BufferGetMappedRange :: fn(
	buffer: Buffer,
	offset: uint,
	size: uint
) -> ?* #foreign #link="wgpuBufferGetMappedRange";

BufferGetMapState :: fn(
	buffer: Buffer
) -> BufferMapState #foreign #link="wgpuBufferGetMapState";

BufferGetSize :: fn(
	buffer: Buffer
) -> u64 #foreign #link="wgpuBufferGetSize";

BufferGetUsage :: fn(
	buffer: Buffer
) -> BufferUsage #foreign #link="wgpuBufferGetUsage";

BufferMapAsync :: fn(
	buffer: Buffer,
	mode: MapMode,
	offset: uint,
	size: uint,
	callbackInfo: BufferMapCallbackInfo
) -> Future #foreign #link="wgpuBufferMapAsync";

BufferReadMappedRange :: fn(
	buffer: Buffer,
	offset: uint,
	data: ?*,
	size: uint
) -> Status #foreign #link="wgpuBufferReadMappedRange";

BufferSetLabel :: fn(
	buffer: Buffer,
	label: StringView
) #foreign #link="wgpuBufferSetLabel";

BufferUnmap :: fn(
	buffer: Buffer
) #foreign #link="wgpuBufferUnmap";

BufferWriteMappedRange :: fn(
	buffer: Buffer,
	offset: uint,
	data: ?*,
	size: uint
) -> Status #foreign #link="wgpuBufferWriteMappedRange";

BufferAddRef :: fn(
	buffer: Buffer
) #foreign #link="wgpuBufferAddRef";

BufferRelease :: fn(
	buffer: Buffer
) #foreign #link="wgpuBufferRelease";

CommandBufferSetLabel :: fn(
	commandBuffer: CommandBuffer,
	label: StringView
) #foreign #link="wgpuCommandBufferSetLabel";

CommandBufferAddRef :: fn(
	commandBuffer: CommandBuffer
) #foreign #link="wgpuCommandBufferAddRef";

CommandBufferRelease :: fn(
	commandBuffer: CommandBuffer
) #foreign #link="wgpuCommandBufferRelease";

CommandEncoderBeginComputePass :: fn(
	commandEncoder: CommandEncoder,
	descriptor: ?*ComputePassDescriptor
) -> ComputePassEncoder #foreign #link="wgpuCommandEncoderBeginComputePass";

CommandEncoderBeginRenderPass :: fn(
	commandEncoder: CommandEncoder,
	descriptor: ?*RenderPassDescriptor
) -> RenderPassEncoder #foreign #link="wgpuCommandEncoderBeginRenderPass";

CommandEncoderClearBuffer :: fn(
	commandEncoder: CommandEncoder,
	buffer: Buffer,
	offset: u64,
	size: u64
) #foreign #link="wgpuCommandEncoderClearBuffer";

CommandEncoderCopyBufferToBuffer :: fn(
	commandEncoder: CommandEncoder,
	source: Buffer,
	sourceOffset: u64,
	destination: Buffer,
	destinationOffset: u64,
	size: u64
) #foreign #link="wgpuCommandEncoderCopyBufferToBuffer";

CommandEncoderCopyBufferToTexture :: fn(
	commandEncoder: CommandEncoder,
	source: ?*TexelCopyBufferInfo,
	destination: ?*TexelCopyTextureInfo,
	copySize: ?*Extent3D
) #foreign #link="wgpuCommandEncoderCopyBufferToTexture";

CommandEncoderCopyTextureToBuffer :: fn(
	commandEncoder: CommandEncoder,
	source: ?*TexelCopyTextureInfo,
	destination: ?*TexelCopyBufferInfo,
	copySize: ?*Extent3D
) #foreign #link="wgpuCommandEncoderCopyTextureToBuffer";

CommandEncoderCopyTextureToTexture :: fn(
	commandEncoder: CommandEncoder,
	source: ?*TexelCopyTextureInfo,
	destination: ?*TexelCopyTextureInfo,
	copySize: ?*Extent3D
) #foreign #link="wgpuCommandEncoderCopyTextureToTexture";

CommandEncoderFinish :: fn(
	commandEncoder: CommandEncoder,
	descriptor: ?*CommandBufferDescriptor
) -> CommandBuffer #foreign #link="wgpuCommandEncoderFinish";

CommandEncoderInsertDebugMarker :: fn(
	commandEncoder: CommandEncoder,
	markerLabel: StringView
) #foreign #link="wgpuCommandEncoderInsertDebugMarker";

CommandEncoderPopDebugGroup :: fn(
	commandEncoder: CommandEncoder
) #foreign #link="wgpuCommandEncoderPopDebugGroup";

CommandEncoderPushDebugGroup :: fn(
	commandEncoder: CommandEncoder,
	groupLabel: StringView
) #foreign #link="wgpuCommandEncoderPushDebugGroup";

CommandEncoderResolveQuerySet :: fn(
	commandEncoder: CommandEncoder,
	querySet: QuerySet,
	firstQuery: u32,
	queryCount: u32,
	destination: Buffer,
	destinationOffset: u64
) #foreign #link="wgpuCommandEncoderResolveQuerySet";

CommandEncoderSetLabel :: fn(
	commandEncoder: CommandEncoder,
	label: StringView
) #foreign #link="wgpuCommandEncoderSetLabel";

CommandEncoderWriteTimestamp :: fn(
	commandEncoder: CommandEncoder,
	querySet: QuerySet,
	queryIndex: u32
) #foreign #link="wgpuCommandEncoderWriteTimestamp";

CommandEncoderAddRef :: fn(
	commandEncoder: CommandEncoder
) #foreign #link="wgpuCommandEncoderAddRef";

CommandEncoderRelease :: fn(
	commandEncoder: CommandEncoder
) #foreign #link="wgpuCommandEncoderRelease";

ComputePassEncoderDispatchWorkgroups :: fn(
	computePassEncoder: ComputePassEncoder,
	workgroupCountX: u32,
	workgroupCountY: u32,
	workgroupCountZ: u32
) #foreign #link="wgpuComputePassEncoderDispatchWorkgroups";

ComputePassEncoderDispatchWorkgroupsIndirect :: fn(
	computePassEncoder: ComputePassEncoder,
	indirectBuffer: Buffer,
	indirectOffset: u64
) #foreign #link="wgpuComputePassEncoderDispatchWorkgroupsIndirect";

ComputePassEncoderEnd :: fn(
	computePassEncoder: ComputePassEncoder
) #foreign #link="wgpuComputePassEncoderEnd";

ComputePassEncoderInsertDebugMarker :: fn(
	computePassEncoder: ComputePassEncoder,
	markerLabel: StringView
) #foreign #link="wgpuComputePassEncoderInsertDebugMarker";

ComputePassEncoderPopDebugGroup :: fn(
	computePassEncoder: ComputePassEncoder
) #foreign #link="wgpuComputePassEncoderPopDebugGroup";

ComputePassEncoderPushDebugGroup :: fn(
	computePassEncoder: ComputePassEncoder,
	groupLabel: StringView
) #foreign #link="wgpuComputePassEncoderPushDebugGroup";

ComputePassEncoderSetBindGroup :: fn(
	computePassEncoder: ComputePassEncoder,
	groupIndex: u32,
	group: BindGroup,
	dynamicOffsetCount: uint,
	dynamicOffsets: ?*u32
) #foreign #link="wgpuComputePassEncoderSetBindGroup";

ComputePassEncoderSetLabel :: fn(
	computePassEncoder: ComputePassEncoder,
	label: StringView
) #foreign #link="wgpuComputePassEncoderSetLabel";

ComputePassEncoderSetPipeline :: fn(
	computePassEncoder: ComputePassEncoder,
	pipeline: ComputePipeline
) #foreign #link="wgpuComputePassEncoderSetPipeline";

ComputePassEncoderAddRef :: fn(
	computePassEncoder: ComputePassEncoder
) #foreign #link="wgpuComputePassEncoderAddRef";

ComputePassEncoderRelease :: fn(
	computePassEncoder: ComputePassEncoder
) #foreign #link="wgpuComputePassEncoderRelease";

ComputePipelineGetBindGroupLayout :: fn(
	computePipeline: ComputePipeline,
	groupIndex: u32
) -> BindGroupLayout #foreign #link="wgpuComputePipelineGetBindGroupLayout";

ComputePipelineSetLabel :: fn(
	computePipeline: ComputePipeline,
	label: StringView
) #foreign #link="wgpuComputePipelineSetLabel";

ComputePipelineAddRef :: fn(
	computePipeline: ComputePipeline
) #foreign #link="wgpuComputePipelineAddRef";

ComputePipelineRelease :: fn(
	computePipeline: ComputePipeline
) #foreign #link="wgpuComputePipelineRelease";

DeviceCreateBindGroup :: fn(
	device: Device,
	descriptor: ?*BindGroupDescriptor
) -> BindGroup #foreign #link="wgpuDeviceCreateBindGroup";

DeviceCreateBindGroupLayout :: fn(
	device: Device,
	descriptor: ?*BindGroupLayoutDescriptor
) -> BindGroupLayout #foreign #link="wgpuDeviceCreateBindGroupLayout";

DeviceCreateBuffer :: fn(
	device: Device,
	descriptor: ?*BufferDescriptor
) -> Buffer #foreign #link="wgpuDeviceCreateBuffer";

DeviceCreateCommandEncoder :: fn(
	device: Device,
	descriptor: ?*CommandEncoderDescriptor
) -> CommandEncoder #foreign #link="wgpuDeviceCreateCommandEncoder";

DeviceCreateComputePipeline :: fn(
	device: Device,
	descriptor: ?*ComputePipelineDescriptor
) -> ComputePipeline #foreign #link="wgpuDeviceCreateComputePipeline";

DeviceCreateComputePipelineAsync :: fn(
	device: Device,
	descriptor: ?*ComputePipelineDescriptor,
	callbackInfo: CreateComputePipelineAsyncCallbackInfo
) -> Future #foreign #link="wgpuDeviceCreateComputePipelineAsync";

DeviceCreatePipelineLayout :: fn(
	device: Device,
	descriptor: ?*PipelineLayoutDescriptor
) -> PipelineLayout #foreign #link="wgpuDeviceCreatePipelineLayout";

DeviceCreateQuerySet :: fn(
	device: Device,
	descriptor: ?*QuerySetDescriptor
) -> QuerySet #foreign #link="wgpuDeviceCreateQuerySet";

DeviceCreateRenderBundleEncoder :: fn(
	device: Device,
	descriptor: ?*RenderBundleEncoderDescriptor
) -> RenderBundleEncoder #foreign #link="wgpuDeviceCreateRenderBundleEncoder";

DeviceCreateRenderPipeline :: fn(
	device: Device,
	descriptor: ?*RenderPipelineDescriptor
) -> RenderPipeline #foreign #link="wgpuDeviceCreateRenderPipeline";

DeviceCreateRenderPipelineAsync :: fn(
	device: Device,
	descriptor: ?*RenderPipelineDescriptor,
	callbackInfo: CreateRenderPipelineAsyncCallbackInfo
) -> Future #foreign #link="wgpuDeviceCreateRenderPipelineAsync";

DeviceCreateSampler :: fn(
	device: Device,
	descriptor: ?*SamplerDescriptor
) -> Sampler #foreign #link="wgpuDeviceCreateSampler";

DeviceCreateShaderModule :: fn(
	device: Device,
	descriptor: ?*ShaderModuleDescriptor
) -> ShaderModule #foreign #link="wgpuDeviceCreateShaderModule";

DeviceCreateTexture :: fn(
	device: Device,
	descriptor: ?*TextureDescriptor
) -> Texture #foreign #link="wgpuDeviceCreateTexture";

DeviceDestroy :: fn(
	device: Device
) #foreign #link="wgpuDeviceDestroy";

DeviceGetAdapterInfo :: fn(
	device: Device,
	adapterInfo: ?*AdapterInfo
) -> Status #foreign #link="wgpuDeviceGetAdapterInfo";

DeviceGetFeatures :: fn(
	device: Device,
	features: ?*SupportedFeatures
) #foreign #link="wgpuDeviceGetFeatures";

DeviceGetLimits :: fn(
	device: Device,
	limits: ?*Limits
) -> Status #foreign #link="wgpuDeviceGetLimits";

DeviceGetLostFuture :: fn(
	device: Device
) -> Future #foreign #link="wgpuDeviceGetLostFuture";

DeviceGetQueue :: fn(
	device: Device
) -> Queue #foreign #link="wgpuDeviceGetQueue";

DeviceHasFeature :: fn(
	device: Device,
	feature: FeatureName
) -> Bool #foreign #link="wgpuDeviceHasFeature";

DevicePopErrorScope :: fn(
	device: Device,
	callbackInfo: PopErrorScopeCallbackInfo
) -> Future #foreign #link="wgpuDevicePopErrorScope";

DevicePushErrorScope :: fn(
	device: Device,
	filter: ErrorFilter
) #foreign #link="wgpuDevicePushErrorScope";

DeviceSetLabel :: fn(
	device: Device,
	label: StringView
) #foreign #link="wgpuDeviceSetLabel";

DeviceAddRef :: fn(
	device: Device
) #foreign #link="wgpuDeviceAddRef";

DeviceRelease :: fn(
	device: Device
) #foreign #link="wgpuDeviceRelease";

InstanceCreateSurface :: fn(
	instance: Instance,
	descriptor: ?*SurfaceDescriptor
) -> Surface #foreign #link="wgpuInstanceCreateSurface";

InstanceGetWGSLLanguageFeatures :: fn(
	instance: Instance,
	features: ?*SupportedWGSLLanguageFeatures
) #foreign #link="wgpuInstanceGetWGSLLanguageFeatures";

InstanceHasWGSLLanguageFeature :: fn(
	instance: Instance,
	feature: WGSLLanguageFeatureName
) -> Bool #foreign #link="wgpuInstanceHasWGSLLanguageFeature";

InstanceProcessEvents :: fn(
	instance: Instance
) #foreign #link="wgpuInstanceProcessEvents";

InstanceRequestAdapter :: fn(
	instance: Instance,
	options: ?*RequestAdapterOptions,
	callbackInfo: RequestAdapterCallbackInfo
) -> Future #foreign #link="wgpuInstanceRequestAdapter";

InstanceWaitAny :: fn(
	instance: Instance,
	futureCount: uint,
	futures: ?*FutureWaitInfo,
	timeoutNS: u64
) -> WaitStatus #foreign #link="wgpuInstanceWaitAny";

InstanceAddRef :: fn(
	instance: Instance
) #foreign #link="wgpuInstanceAddRef";

InstanceRelease :: fn(
	instance: Instance
) #foreign #link="wgpuInstanceRelease";

PipelineLayoutSetLabel :: fn(
	pipelineLayout: PipelineLayout,
	label: StringView
) #foreign #link="wgpuPipelineLayoutSetLabel";

PipelineLayoutAddRef :: fn(
	pipelineLayout: PipelineLayout
) #foreign #link="wgpuPipelineLayoutAddRef";

PipelineLayoutRelease :: fn(
	pipelineLayout: PipelineLayout
) #foreign #link="wgpuPipelineLayoutRelease";

QuerySetDestroy :: fn(
	querySet: QuerySet
) #foreign #link="wgpuQuerySetDestroy";

QuerySetGetCount :: fn(
	querySet: QuerySet
) -> u32 #foreign #link="wgpuQuerySetGetCount";

QuerySetGetType :: fn(
	querySet: QuerySet
) -> QueryType #foreign #link="wgpuQuerySetGetType";

QuerySetSetLabel :: fn(
	querySet: QuerySet,
	label: StringView
) #foreign #link="wgpuQuerySetSetLabel";

QuerySetAddRef :: fn(
	querySet: QuerySet
) #foreign #link="wgpuQuerySetAddRef";

QuerySetRelease :: fn(
	querySet: QuerySet
) #foreign #link="wgpuQuerySetRelease";

QueueOnSubmittedWorkDone :: fn(
	queue: Queue,
	callbackInfo: QueueWorkDoneCallbackInfo
) -> Future #foreign #link="wgpuQueueOnSubmittedWorkDone";

QueueSetLabel :: fn(
	queue: Queue,
	label: StringView
) #foreign #link="wgpuQueueSetLabel";

QueueSubmit :: fn(
	queue: Queue,
	commandCount: uint,
	commands: ?*CommandBuffer
) #foreign #link="wgpuQueueSubmit";

QueueWriteBuffer :: fn(
	queue: Queue,
	buffer: Buffer,
	bufferOffset: u64,
	data: ?*,
	size: uint
) #foreign #link="wgpuQueueWriteBuffer";

QueueWriteTexture :: fn(
	queue: Queue,
	destination: ?*TexelCopyTextureInfo,
	data: ?*,
	dataSize: uint,
	dataLayout: ?*TexelCopyBufferLayout,
	writeSize: ?*Extent3D
) #foreign #link="wgpuQueueWriteTexture";

QueueAddRef :: fn(
	queue: Queue
) #foreign #link="wgpuQueueAddRef";

QueueRelease :: fn(
	queue: Queue
) #foreign #link="wgpuQueueRelease";

RenderBundleSetLabel :: fn(
	renderBundle: RenderBundle,
	label: StringView
) #foreign #link="wgpuRenderBundleSetLabel";

RenderBundleAddRef :: fn(
	renderBundle: RenderBundle
) #foreign #link="wgpuRenderBundleAddRef";

RenderBundleRelease :: fn(
	renderBundle: RenderBundle
) #foreign #link="wgpuRenderBundleRelease";

RenderBundleEncoderDraw :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	vertexCount: u32,
	instanceCount: u32,
	firstVertex: u32,
	firstInstance: u32
) #foreign #link="wgpuRenderBundleEncoderDraw";

RenderBundleEncoderDrawIndexed :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	indexCount: u32,
	instanceCount: u32,
	firstIndex: u32,
	baseVertex: i32,
	firstInstance: u32
) #foreign #link="wgpuRenderBundleEncoderDrawIndexed";

RenderBundleEncoderDrawIndexedIndirect :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	indirectBuffer: Buffer,
	indirectOffset: u64
) #foreign #link="wgpuRenderBundleEncoderDrawIndexedIndirect";

RenderBundleEncoderDrawIndirect :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	indirectBuffer: Buffer,
	indirectOffset: u64
) #foreign #link="wgpuRenderBundleEncoderDrawIndirect";

RenderBundleEncoderFinish :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	descriptor: ?*RenderBundleDescriptor
) -> RenderBundle #foreign #link="wgpuRenderBundleEncoderFinish";

RenderBundleEncoderInsertDebugMarker :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	markerLabel: StringView
) #foreign #link="wgpuRenderBundleEncoderInsertDebugMarker";

RenderBundleEncoderPopDebugGroup :: fn(
	renderBundleEncoder: RenderBundleEncoder
) #foreign #link="wgpuRenderBundleEncoderPopDebugGroup";

RenderBundleEncoderPushDebugGroup :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	groupLabel: StringView
) #foreign #link="wgpuRenderBundleEncoderPushDebugGroup";

RenderBundleEncoderSetBindGroup :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	groupIndex: u32,
	group: BindGroup,
	dynamicOffsetCount: uint,
	dynamicOffsets: ?*u32
) #foreign #link="wgpuRenderBundleEncoderSetBindGroup";

RenderBundleEncoderSetIndexBuffer :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	buffer: Buffer,
	format: IndexFormat,
	offset: u64,
	size: u64
) #foreign #link="wgpuRenderBundleEncoderSetIndexBuffer";

RenderBundleEncoderSetLabel :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	label: StringView
) #foreign #link="wgpuRenderBundleEncoderSetLabel";

RenderBundleEncoderSetPipeline :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	pipeline: RenderPipeline
) #foreign #link="wgpuRenderBundleEncoderSetPipeline";

RenderBundleEncoderSetVertexBuffer :: fn(
	renderBundleEncoder: RenderBundleEncoder,
	slot: u32,
	buffer: Buffer,
	offset: u64,
	size: u64
) #foreign #link="wgpuRenderBundleEncoderSetVertexBuffer";

RenderBundleEncoderAddRef :: fn(
	renderBundleEncoder: RenderBundleEncoder
) #foreign #link="wgpuRenderBundleEncoderAddRef";

RenderBundleEncoderRelease :: fn(
	renderBundleEncoder: RenderBundleEncoder
) #foreign #link="wgpuRenderBundleEncoderRelease";

RenderPassEncoderBeginOcclusionQuery :: fn(
	renderPassEncoder: RenderPassEncoder,
	queryIndex: u32
) #foreign #link="wgpuRenderPassEncoderBeginOcclusionQuery";

RenderPassEncoderDraw :: fn(
	renderPassEncoder: RenderPassEncoder,
	vertexCount: u32,
	instanceCount: u32,
	firstVertex: u32,
	firstInstance: u32
) #foreign #link="wgpuRenderPassEncoderDraw";

RenderPassEncoderDrawIndexed :: fn(
	renderPassEncoder: RenderPassEncoder,
	indexCount: u32,
	instanceCount: u32,
	firstIndex: u32,
	baseVertex: i32,
	firstInstance: u32
) #foreign #link="wgpuRenderPassEncoderDrawIndexed";

RenderPassEncoderDrawIndexedIndirect :: fn(
	renderPassEncoder: RenderPassEncoder,
	indirectBuffer: Buffer,
	indirectOffset: u64
) #foreign #link="wgpuRenderPassEncoderDrawIndexedIndirect";

RenderPassEncoderDrawIndirect :: fn(
	renderPassEncoder: RenderPassEncoder,
	indirectBuffer: Buffer,
	indirectOffset: u64
) #foreign #link="wgpuRenderPassEncoderDrawIndirect";

RenderPassEncoderEnd :: fn(
	renderPassEncoder: RenderPassEncoder
) #foreign #link="wgpuRenderPassEncoderEnd";

RenderPassEncoderEndOcclusionQuery :: fn(
	renderPassEncoder: RenderPassEncoder
) #foreign #link="wgpuRenderPassEncoderEndOcclusionQuery";

RenderPassEncoderExecuteBundles :: fn(
	renderPassEncoder: RenderPassEncoder,
	bundleCount: uint,
	bundles: ?*RenderBundle
) #foreign #link="wgpuRenderPassEncoderExecuteBundles";

RenderPassEncoderInsertDebugMarker :: fn(
	renderPassEncoder: RenderPassEncoder,
	markerLabel: StringView
) #foreign #link="wgpuRenderPassEncoderInsertDebugMarker";

RenderPassEncoderPopDebugGroup :: fn(
	renderPassEncoder: RenderPassEncoder
) #foreign #link="wgpuRenderPassEncoderPopDebugGroup";

RenderPassEncoderPushDebugGroup :: fn(
	renderPassEncoder: RenderPassEncoder,
	groupLabel: StringView
) #foreign #link="wgpuRenderPassEncoderPushDebugGroup";

RenderPassEncoderSetBindGroup :: fn(
	renderPassEncoder: RenderPassEncoder,
	groupIndex: u32,
	group: BindGroup,
	dynamicOffsetCount: uint,
	dynamicOffsets: ?*u32
) #foreign #link="wgpuRenderPassEncoderSetBindGroup";

RenderPassEncoderSetBlendConstant :: fn(
	renderPassEncoder: RenderPassEncoder,
	color: ?*Color
) #foreign #link="wgpuRenderPassEncoderSetBlendConstant";

RenderPassEncoderSetIndexBuffer :: fn(
	renderPassEncoder: RenderPassEncoder,
	buffer: Buffer,
	format: IndexFormat,
	offset: u64,
	size: u64
) #foreign #link="wgpuRenderPassEncoderSetIndexBuffer";

RenderPassEncoderSetLabel :: fn(
	renderPassEncoder: RenderPassEncoder,
	label: StringView
) #foreign #link="wgpuRenderPassEncoderSetLabel";

RenderPassEncoderSetPipeline :: fn(
	renderPassEncoder: RenderPassEncoder,
	pipeline: RenderPipeline
) #foreign #link="wgpuRenderPassEncoderSetPipeline";

RenderPassEncoderSetScissorRect :: fn(
	renderPassEncoder: RenderPassEncoder,
	x: u32,
	y: u32,
	width: u32,
	height: u32
) #foreign #link="wgpuRenderPassEncoderSetScissorRect";

RenderPassEncoderSetStencilReference :: fn(
	renderPassEncoder: RenderPassEncoder,
	reference: u32
) #foreign #link="wgpuRenderPassEncoderSetStencilReference";

RenderPassEncoderSetVertexBuffer :: fn(
	renderPassEncoder: RenderPassEncoder,
	slot: u32,
	buffer: Buffer,
	offset: u64,
	size: u64
) #foreign #link="wgpuRenderPassEncoderSetVertexBuffer";

RenderPassEncoderSetViewport :: fn(
	renderPassEncoder: RenderPassEncoder,
	x: f32,
	y: f32,
	width: f32,
	height: f32,
	minDepth: f32,
	maxDepth: f32
) #foreign #link="wgpuRenderPassEncoderSetViewport";

RenderPassEncoderAddRef :: fn(
	renderPassEncoder: RenderPassEncoder
) #foreign #link="wgpuRenderPassEncoderAddRef";

RenderPassEncoderRelease :: fn(
	renderPassEncoder: RenderPassEncoder
) #foreign #link="wgpuRenderPassEncoderRelease";

RenderPipelineGetBindGroupLayout :: fn(
	renderPipeline: RenderPipeline,
	groupIndex: u32
) -> BindGroupLayout #foreign #link="wgpuRenderPipelineGetBindGroupLayout";

RenderPipelineSetLabel :: fn(
	renderPipeline: RenderPipeline,
	label: StringView
) #foreign #link="wgpuRenderPipelineSetLabel";

RenderPipelineAddRef :: fn(
	renderPipeline: RenderPipeline
) #foreign #link="wgpuRenderPipelineAddRef";

RenderPipelineRelease :: fn(
	renderPipeline: RenderPipeline
) #foreign #link="wgpuRenderPipelineRelease";

SamplerSetLabel :: fn(
	sampler: Sampler,
	label: StringView
) #foreign #link="wgpuSamplerSetLabel";

SamplerAddRef :: fn(
	sampler: Sampler
) #foreign #link="wgpuSamplerAddRef";

SamplerRelease :: fn(
	sampler: Sampler
) #foreign #link="wgpuSamplerRelease";

ShaderModuleGetCompilationInfo :: fn(
	shaderModule: ShaderModule,
	callbackInfo: CompilationInfoCallbackInfo
) -> Future #foreign #link="wgpuShaderModuleGetCompilationInfo";

ShaderModuleSetLabel :: fn(
	shaderModule: ShaderModule,
	label: StringView
) #foreign #link="wgpuShaderModuleSetLabel";

ShaderModuleAddRef :: fn(
	shaderModule: ShaderModule
) #foreign #link="wgpuShaderModuleAddRef";

ShaderModuleRelease :: fn(
	shaderModule: ShaderModule
) #foreign #link="wgpuShaderModuleRelease";

SupportedFeaturesFreeMembers :: fn(
	supportedFeatures: SupportedFeatures
) #foreign #link="wgpuSupportedFeaturesFreeMembers";

SupportedInstanceFeaturesFreeMembers :: fn(
	supportedInstanceFeatures: SupportedInstanceFeatures
) #foreign #link="wgpuSupportedInstanceFeaturesFreeMembers";

SupportedWGSLLanguageFeaturesFreeMembers :: fn(
	supportedWGSLLanguageFeatures: SupportedWGSLLanguageFeatures
) #foreign #link="wgpuSupportedWGSLLanguageFeaturesFreeMembers";

SurfaceConfigure :: fn(
	surface: Surface,
	config: ?*SurfaceConfiguration
) #foreign #link="wgpuSurfaceConfigure";

SurfaceGetCapabilities :: fn(
	surface: Surface,
	adapter: Adapter,
	capabilities: ?*SurfaceCapabilities
) -> Status #foreign #link="wgpuSurfaceGetCapabilities";

SurfaceGetCurrentTexture :: fn(
	surface: Surface,
	surfaceTexture: ?*SurfaceTexture
) #foreign #link="wgpuSurfaceGetCurrentTexture";

SurfacePresent :: fn(
	surface: Surface
) -> Status #foreign #link="wgpuSurfacePresent";

SurfaceSetLabel :: fn(
	surface: Surface,
	label: StringView
) #foreign #link="wgpuSurfaceSetLabel";

SurfaceUnconfigure :: fn(
	surface: Surface
) #foreign #link="wgpuSurfaceUnconfigure";

SurfaceAddRef :: fn(
	surface: Surface
) #foreign #link="wgpuSurfaceAddRef";

SurfaceRelease :: fn(
	surface: Surface
) #foreign #link="wgpuSurfaceRelease";

SurfaceCapabilitiesFreeMembers :: fn(
	surfaceCapabilities: SurfaceCapabilities
) #foreign #link="wgpuSurfaceCapabilitiesFreeMembers";

TextureCreateView :: fn(
	texture: Texture,
	descriptor: ?*TextureViewDescriptor
) -> TextureView #foreign #link="wgpuTextureCreateView";

TextureDestroy :: fn(
	texture: Texture
) #foreign #link="wgpuTextureDestroy";

TextureGetDepthOrArrayLayers :: fn(
	texture: Texture
) -> u32 #foreign #link="wgpuTextureGetDepthOrArrayLayers";

TextureGetDimension :: fn(
	texture: Texture
) -> TextureDimension #foreign #link="wgpuTextureGetDimension";

TextureGetFormat :: fn(
	texture: Texture
) -> TextureFormat #foreign #link="wgpuTextureGetFormat";

TextureGetHeight :: fn(
	texture: Texture
) -> u32 #foreign #link="wgpuTextureGetHeight";

TextureGetMipLevelCount :: fn(
	texture: Texture
) -> u32 #foreign #link="wgpuTextureGetMipLevelCount";

TextureGetSampleCount :: fn(
	texture: Texture
) -> u32 #foreign #link="wgpuTextureGetSampleCount";

TextureGetUsage :: fn(
	texture: Texture
) -> TextureUsage #foreign #link="wgpuTextureGetUsage";

TextureGetWidth :: fn(
	texture: Texture
) -> u32 #foreign #link="wgpuTextureGetWidth";

TextureSetLabel :: fn(
	texture: Texture,
	label: StringView
) #foreign #link="wgpuTextureSetLabel";

TextureAddRef :: fn(
	texture: Texture
) #foreign #link="wgpuTextureAddRef";

TextureRelease :: fn(
	texture: Texture
) #foreign #link="wgpuTextureRelease";

TextureViewSetLabel :: fn(
	textureView: TextureView,
	label: StringView
) #foreign #link="wgpuTextureViewSetLabel";

TextureViewAddRef :: fn(
	textureView: TextureView
) #foreign #link="wgpuTextureViewAddRef";

TextureViewRelease :: fn(
	textureView: TextureView
) #foreign #link="wgpuTextureViewRelease";

