main

struct Foo {
	x: [1024]fn(a: ?*) -> i32,
}

struct SFloat {
    a: f32,
    b: f32,
}

something :: fn(arg: SFloat) -> SFloat {
    return arg;
}

sum_o :: fn(list: ...) -> i32 {
    return *@*i32 list[0].val;
}

sum :: fn(list: ...) -> i32 {
    res := list[0];
    return *@*i32 res.val;
}

my_str :: fn(f: *SFloat) -> f32 {
    x := *f;
    x.a = 1;
    return f.a;
}

#if Windows
(
    main :: fn() -> i32 {
        return 0b1000_1111;
    }
)

#if Unix
(
    main :: fn() -> i32 {
        return 0b1100_1111;
    }
)

// #import stuff as f2
// 
// struct BigStruct {
// 	bar: f2.x,
//     foo: [100]i32,
// }
// 
// struct SmallStruct {
//     num1: i16,
//     num2: i16,
// }
// 
// make_bs :: fn(num: i32) -> BigStruct {
//     res := BigStruct { foo = {}, bar = f2.x { y = 10 } };
//     for i := 0; i < 100;  i += 1 {
//         res.foo[i] = num;
//     }
// 
//     return res;
// }
// 
// make_ss :: fn(num: i32) -> SmallStruct {
//     res := SmallStruct { num1 = @i16 num, num2 = @i16 num };
//     return res;
// }
// 
// make_array :: fn(num: i32) -> [100]i32 {
//     arr:[100]i32 = {};
//     for i := 0; i < 50; i += 1 {
//         arr[i] = num;
//     }
//     for i := 50; i < 100; i += 1 {
//         arr[i] = num * 2;
//     }
//     return arr;
// }
// 
// get_fn :: fn() -> fn(foo1: BigStruct, foo2: SmallStruct, foo3: [100]i32) -> i32 {
// 	return fn(foo1: BigStruct, foo2: SmallStruct, foo3: [100]i32) -> i32 {
// 		return foo1.foo[50] - foo2.num2 - foo3[0] - foo3[50] + 1;
// 	};
// }
// 
// main :: fn() -> i32 {
//     foo1 := make_bs(100);
//     foo2 := make_ss(25);
//     foo3 := make_array(25);
// 	my_arr :: {1, 2, 3};
//     //     100 - 25 - 25 - 50
// 	return get_fn()(foo1, foo2, foo3);
// }


